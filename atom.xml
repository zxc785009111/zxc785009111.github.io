<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王瞬|卡丘</title>
  
  <subtitle>王瞬的私人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-09T16:00:39.188Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王瞬|卡丘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringCloud学习(1)服务治理与服务发现——Eurka</title>
    <link href="http://yoursite.com/2019/01/09/SpringCloud%E5%AD%A6%E4%B9%A0-1-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%8F%91%E7%8E%B0%E2%80%94%E2%80%94Eurka/"/>
    <id>http://yoursite.com/2019/01/09/SpringCloud学习-1-服务治理与服务发发现——Eurka/</id>
    <published>2019-01-09T14:21:05.000Z</published>
    <updated>2019-01-09T16:00:39.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h2><p>1.是纯正的 servlet 应用，需构建成jar/war包部署</p><p>2.使用了 Jersey 框架实现自身的 RESTful HTTP接口</p><p>3.peer之间的同步与服务的注册全部通过 HTTP 协议实现</p><p>4.定时任务(发送心跳、定时清理过期服务、节点同步等)通过 JDK 自带的 Timer 实现</p><p>5.内存缓存使用Google的guava包实现</p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.activation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;activation&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之所以要引入除了eureka之外的包，是因为我只引入这一个包的时候启动项目报错了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.ClassNotFoundException: javax.xml.bind.JAXBContext</span><br></pre></td></tr></table></figure></p><p>网上查了一下，说是jdk9的新特性不再默认加载这些包，好，那和我JDK8有鸡毛关系！（鄙视MyEclipse）<br>鄙视归鄙视，该需要的包还是要加上去的..</p><h3 id="配置文件编写"><a href="#配置文件编写" class="headerlink" title="配置文件编写"></a>配置文件编写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761  <span class="comment">#官方写的就是 8761</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: server <span class="comment">#一个微服务的标识，如果第二个微服务启动时，也将这个配置成server，则Spring Cloud会认为它也是server这个微服务的一个节点</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost <span class="comment">#配置主机名</span></span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span> <span class="comment">#配置服务注册中心是否以自己为客户端进行注册(配置false)</span></span><br><span class="line">    fetch-registry: <span class="literal">false</span> <span class="comment">#是否取得注册信息(配置false)</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</span><br><span class="line">      <span class="comment">#配置eureka客户端的缺省域(该配置可能没有提示,请复制或者手动输入,切勿使用有提示的service-url会引起内置tomcat报错)</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot-启动项加入注解-EnableEurekaServer"><a href="#SpringBoot-启动项加入注解-EnableEurekaServer" class="headerlink" title="SpringBoot 启动项加入注解@EnableEurekaServer"></a>SpringBoot 启动项加入注解@EnableEurekaServer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class SpringCloudLeaning1EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1EurekaServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目 访问<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> 看到以下图就证明没问题啦~<br><img src="/images/SpringCloud/Eureka/eureka-1.png"></p><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>注册服务就会用到服务发现，这里新建一个SpringBoot工程，并且引入Eureka Client需要的包</p><h3 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: product <span class="comment">#一个微服务的标识，如果第二个微服务启动时，也将这个配置成product，则Spring Cloud会认为它也是product这个微服务的一个节点</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost   <span class="comment">#配置主机名</span></span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br><span class="line">      <span class="comment">#配置eureka客户端的缺省域(该配置可能没有提示,请复制或者手动输入,切勿使用有提示的service-url会引起内置tomcat报错)</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>本次启动类基于spring-cloud-starter-netflix-eureka-client不需要添加额外注解。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringCloudLeaning1EurekaClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1EurekaClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller类必须要写，如果不写的话，服务注册上去一秒就会关闭….,你再刷新页面就看不到服务了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Value(<span class="string">"<span class="variable">$&#123;spring.application.name&#125;</span>"</span>)</span><br><span class="line">    String applicationName;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/hello"</span>)</span><br><span class="line">    public String home(@RequestParam String email) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"My Name's :"</span> + applicationName + <span class="string">" Email:"</span> + email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后先启动服务端，再启动客户端</p><p>访问localhost:8761<br>你就可以看到我们的服务实例已经注册上去了，当然一个错误的声明警告也有…这个警告在使用服务治理的单机中经常出现，是Eureka server的一种自我保护 检测心跳的失败比率是否在15s内低于百分之85%，不用管他。</p><p><img src="/images/SpringCloud/Eureka/eureka-2.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>访问<a href="http://localhost:9001/hello?email=785009111@qq.com" target="_blank" rel="noopener">http://localhost:9001/hello?email=785009111@qq.com</a></p><p>显示：My Name’s :product Email:<a href="mailto:785009111@qq.com" target="_blank" rel="noopener">785009111@qq.com</a>   就大功告成啦~</p><p>参考文献：<br>    <a href="https://blog.csdn.net/hadues/article/details/79188793" target="_blank" rel="noopener">https://blog.csdn.net/hadues/article/details/79188793</a><br>    <a href="https://blog.battcn.com/2017/07/25/springcloud/dalston/spring-cloud-discovery/" target="_blank" rel="noopener">https://blog.battcn.com/2017/07/25/springcloud/dalston/spring-cloud-discovery/</a><br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Eureka简介&quot;&gt;&lt;a href=&quot;#Eureka简介&quot; class=&quot;headerlink&quot; title=&quot;Eureka简介&quot;&gt;&lt;/a&gt;Eureka简介&lt;/h2&gt;&lt;p&gt;1.是纯正的 servlet 应用，需构建成jar/war包部署&lt;/p&gt;
&lt;p&gt;2.使用了 
      
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>oracle数据库增加表空间</title>
    <link href="http://yoursite.com/2019/01/08/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%8A%A0%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2019/01/08/oracle数据库增加表空间/</id>
    <published>2019-01-08T13:30:56.000Z</published>
    <updated>2019-01-08T13:40:27.102Z</updated>
    
    <content type="html"><![CDATA[<p>今天数据库表空间满了导致插入不了新的数据了，第一次扩容，记下一笔</p><h2 id="报错截图"><a href="#报错截图" class="headerlink" title="报错截图"></a>报错截图</h2><p><img src="/images/linux/oracleDatanaseAdd/reson.png"></p><p>原因大概在网上查了查，是指USERS这个表空间满了所以导致的新数据insert失败。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>注意：以下操作均需要DBA权限。</p><h3 id="查询表空间使用情况"><a href="#查询表空间使用情况" class="headerlink" title="查询表空间使用情况"></a>查询表空间使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT UPPER(F.TABLESPACE_NAME) <span class="string">"表空间名"</span>, </span><br><span class="line">D.TOT_GROOTTE_MB <span class="string">"表空间大小(M)"</span>, </span><br><span class="line">D.TOT_GROOTTE_MB - F.TOTAL_BYTES <span class="string">"已使用空间(M)"</span>, </span><br><span class="line">TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),<span class="string">'990.99'</span>) <span class="string">"使用比"</span>, </span><br><span class="line">F.TOTAL_BYTES <span class="string">"空闲空间(M)"</span>, </span><br><span class="line">F.MAX_BYTES <span class="string">"最大块(M)"</span> </span><br><span class="line">FROM (SELECT TABLESPACE_NAME, </span><br><span class="line">ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES, </span><br><span class="line">ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES </span><br><span class="line">FROM SYS.DBA_FREE_SPACE </span><br><span class="line">GROUP BY TABLESPACE_NAME) F, </span><br><span class="line">(SELECT DD.TABLESPACE_NAME, </span><br><span class="line">ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB </span><br><span class="line">FROM SYS.DBA_DATA_FILES DD </span><br><span class="line">GROUP BY DD.TABLESPACE_NAME) D </span><br><span class="line">WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME </span><br><span class="line">ORDER BY 4 DESC;</span><br></pre></td></tr></table></figure><h3 id="查找表空间文件的路径"><a href="#查找表空间文件的路径" class="headerlink" title="查找表空间文件的路径"></a>查找表空间文件的路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT tablespace_name, </span><br><span class="line">file_id, </span><br><span class="line">file_name, </span><br><span class="line">round(bytes / (1024 * 1024), 0) total_space </span><br><span class="line">FROM dba_data_files </span><br><span class="line">ORDER BY tablespace_name;</span><br></pre></td></tr></table></figure><h3 id="新增表空间并开启自动扩容"><a href="#新增表空间并开启自动扩容" class="headerlink" title="新增表空间并开启自动扩容"></a>新增表空间并开启自动扩容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace USERS</span><br><span class="line">     add datafile <span class="string">' /u02/ORCL/datafile/user02.dbf'</span> size 320000m AUTOEXTEND ON</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天数据库表空间满了导致插入不了新的数据了，第一次扩容，记下一笔&lt;/p&gt;
&lt;h2 id=&quot;报错截图&quot;&gt;&lt;a href=&quot;#报错截图&quot; class=&quot;headerlink&quot; title=&quot;报错截图&quot;&gt;&lt;/a&gt;报错截图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/linu
      
    
    </summary>
    
      <category term="linux学习" scheme="http://yoursite.com/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(3)深入学习Spring5新框架——WebFlux框架</title>
    <link href="http://yoursite.com/2019/01/07/Spring%E7%9B%B8%E5%85%B3-3-WebFlux%E6%A1%86%E6%9E%B6-2/"/>
    <id>http://yoursite.com/2019/01/07/Spring相关-3-WebFlux框架-2/</id>
    <published>2019-01-07T11:21:28.000Z</published>
    <updated>2019-01-07T16:16:37.732Z</updated>
    
    <content type="html"><![CDATA[<p>上次有说过Webflux框架基本的服务端的开发，其最大的好处就是支持异步处理，可以提高性能，那么当今时代，微服务的架构十分盛行的情况下，多个一个大型的系统可能被拆分成多个系统，这样拆分的好处就是，首先各个系统相对独立，便于维护和开发，简化了开发人员的负担，比如一个电商系统，它可能存在产品微服务，用来发布和管理产品，可能还有客户信息微服务等等，当然他们之前并不是孤立的，他们之前可以相互调用的，各个微服务主要以Rest风格请求的接口来实现相互调用的…<a id="more"></a></p><p>为了方便各个微服务之间调用，WebFlux提供了WebClient类供开发者使用，它比RestTemplate还要强大一些，下面来说说它对于我们之前写的几个实现的调用</p><h2 id="客户端开发WebClient"><a href="#客户端开发WebClient" class="headerlink" title="客户端开发WebClient"></a>客户端开发WebClient</h2><h3 id="使用WebClient-请求后端接口"><a href="#使用WebClient-请求后端接口" class="headerlink" title="使用WebClient 请求后端接口"></a>使用WebClient 请求后端接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.client;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.filter.reactive.HiddenHttpMethodFilter;</span><br><span class="line">import org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import org.springframework.web.server.WebFilterChain;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">public class UserWebClient &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">WebClient webClient2 = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setId(<span class="string">"1"</span>);</span><br><span class="line">user.setSex(<span class="string">"男"</span>);</span><br><span class="line">user.setNote(<span class="string">"123"</span>);</span><br><span class="line">user.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">//新增用户</span><br><span class="line">insertUser(webClient, user);</span><br><span class="line">//获取用户</span><br><span class="line">getUser(webClient2, user.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void insertUser(WebClient webClient,User user) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.post()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user"</span>)</span><br><span class="line">//设置请求体为Json数据流</span><br><span class="line">.contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求体内容</span><br><span class="line">.body(Mono.just(user),User.class)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"用户ID"</span>+user2.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getUser(WebClient webClient,String id) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.get()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user/&#123;id&#125;"</span>,id)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"用户ID"</span>+user2.getUserName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后先运行SpringBoot的主程序，在运行main方法就可以了。<br>日志太长…不太好整….<br>这里如果是基于SpringBoot2.05版本及其以上，可能在调用2个方法时发生报错(java.lang.IllegalStateException: Only one connection receive subscriber allowed)<br>这个是SpringBoot2.05以上版本的Bug，我个人的解决办法是退回到2.04版本，可以在pom文件中修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></p><p>使用代码修改(这种方法我尝试了…但是失败了)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public HiddenHttpMethodFilter <span class="function"><span class="title">hiddenHttpMethodFilter</span></span>() &#123;</span><br><span class="line">       <span class="built_in">return</span> new <span class="function"><span class="title">HiddenHttpMethodFilter</span></span>() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;</span><br><span class="line">               <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>原文地址：<a href="https://github.com/spring-projects/spring-boot/issues/14509" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues/14509</a></p><h2 id="WebFlux-服务端开发"><a href="#WebFlux-服务端开发" class="headerlink" title="WebFlux 服务端开发"></a>WebFlux 服务端开发</h2><h3 id="类型转换器-Converter"><a href="#类型转换器-Converter" class="headerlink" title="类型转换器 Converter"></a>类型转换器 Converter</h3><p>在之前使用SpringMVC的时候也使用过转换器，当时就是把一个字符串”userName-sex-note”转换成一个User类<br>这次依旧是以字符串为例子，实现WebFlux的转换器</p><h4 id="转换器类代码"><a href="#转换器类代码" class="headerlink" title="转换器类代码"></a>转换器类代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.core.convert.converter.Converter;</span><br><span class="line">import org.springframework.format.FormatterRegistry;</span><br><span class="line">import org.springframework.web.reactive.config.WebFluxConfigurer;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * WebFlux配置类</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月7日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebFluxConfig implements WebFluxConfigurer&#123;</span><br><span class="line"></span><br><span class="line">//注册Converter</span><br><span class="line">@Override</span><br><span class="line">public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">registry.addConverter(stringToUserConverter());</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Converter&lt;String, User&gt; <span class="function"><span class="title">stringToUserConverter</span></span>()&#123;</span><br><span class="line">Converter&lt;String, User&gt; converter = new Converter&lt;String, User&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public User convert(String str) &#123;</span><br><span class="line">String[] split = str.split(<span class="string">"-"</span>);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setUserName(split[0]);</span><br><span class="line">user.setSex(split[1]);</span><br><span class="line">user.setNote(split[2]);</span><br><span class="line"><span class="built_in">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">return</span> converter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是实现WebFluxConfigurer 接口，然后重写其注册Converter的方法addFormatters,然后自己构建一个Bean，也就是转换的Bean，加上@Bean注解就可以了。</p><h4 id="Controller-类编写"><a href="#Controller-类编写" class="headerlink" title="Controller 类编写"></a>Controller 类编写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value=<span class="string">"/user/&#123;user&#125;"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser2(@PathVariable(<span class="string">"user"</span>) User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebClient-测试片段"><a href="#WebClient-测试片段" class="headerlink" title="WebClient 测试片段"></a>WebClient 测试片段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void insertUserByString(WebClient webClient) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient.get()</span><br><span class="line">.uri(<span class="string">"/user/&#123;user&#125;"</span>,<span class="string">"张三-男-gay"</span>).accept(MediaType.APPLICATION_STREAM_JSON).retrieve().bodyToMono(User.class);</span><br><span class="line">User user = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"UserId:"</span>+user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">21:37:33.580 [reactor-http-nio-4] DEBUG reactor.ipc.netty.http.client.HttpClientOperations - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Received response (auto-read:<span class="literal">false</span>) : [Content-Type=application/stream+json;charset=UTF-8, Content-Length=78, Date=Mon, 07 Jan 2019 13:37:33 GMT]</span><br><span class="line">21:37:33.581 [reactor-http-nio-4] DEBUG org.springframework.web.reactive.function.client.ExchangeFunctions - Response received, status: 200 OK</span><br><span class="line">21:37:33.661 [reactor-http-nio-4] DEBUG reactor.ipc.netty.channel.FluxReceive - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Subscribing inbound receiver [pending: 0, cancelled:<span class="literal">false</span>, inboundDone: <span class="literal">false</span>]</span><br><span class="line">21:37:33.666 [reactor-http-nio-4] DEBUG reactor.ipc.netty.http.client.HttpClientOperations - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Received last HTTP packet</span><br><span class="line">UserId:5c33561d84cda64d6ce7121e</span><br></pre></td></tr></table></figure><p>至此，转换器就完美撒花了。</p><h3 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h3><p>验证器其实和SpringMVC 的区别不大，分为局部验证器和全局验证器，验证器本身是和MVC一致的，就只是WebFlux 初始化的时候修改一下验证器即可</p><h4 id="User验证器"><a href="#User验证器" class="headerlink" title="User验证器"></a>User验证器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.validator;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">/**</span><br><span class="line"> * 用户验证器</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月7日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class UserValidator implements Validator &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean supports(Class&lt;?&gt; user) &#123;</span><br><span class="line"><span class="built_in">return</span> user.equals(User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void validate(Object target, Errors errors) &#123;</span><br><span class="line">User user = (User) target;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(user.getUserName())) </span><br><span class="line">errors.reject(<span class="string">"userName"</span>,null,<span class="string">"用户名不能为空"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebFlux中添加验证器"><a href="#WebFlux中添加验证器" class="headerlink" title="WebFlux中添加验证器"></a>WebFlux中添加验证器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置全局验证器</span><br><span class="line">@Override</span><br><span class="line">public Validator <span class="function"><span class="title">getValidator</span></span>() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"><span class="built_in">return</span> new UserValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller类加入-Valid注解"><a href="#Controller类加入-Valid注解" class="headerlink" title="Controller类加入@Valid注解"></a>Controller类加入@Valid注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value=<span class="string">"/user/&#123;user&#125;"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser2(@Valid @PathVariable(<span class="string">"user"</span>) User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说只希望这一个类使用这个验证器，也可以参照SpringMVC的写法，在Controller类中添加@InitBinder注解<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void InitBinder (DataBinder dataBinder) &#123;</span><br><span class="line">dataBinder.setValidator(new UserValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebFlux-客户端深入开发"><a href="#WebFlux-客户端深入开发" class="headerlink" title="WebFlux 客户端深入开发"></a>WebFlux 客户端深入开发</h2><h3 id="处理服务端的错误"><a href="#处理服务端的错误" class="headerlink" title="处理服务端的错误"></a>处理服务端的错误</h3><p>之前客户端的开发是基于retrieve方法将服务端的数据流转换的，实际上还需要处理错误的数据，比如http返回一个错误的状态码，这时候就需要我们在客户端进行异常处理<br>，假设之前get方法存在get的结果集为空的情况。</p><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void getUser2(WebClient webClient,String id) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient.get().uri(<span class="string">"/user/&#123;id&#125;"</span>,id).accept(MediaType.APPLICATION_STREAM_JSON).retrieve()</span><br><span class="line">.onStatus(</span><br><span class="line">//如果服务端返回4开头或者5开头的状态吗 则返回<span class="literal">true</span> ，4代表客户端错误，5开头是服务器错误 </span><br><span class="line">status -&gt; status.is4xxClientError()||status.is5xxServerError(),</span><br><span class="line">//如果发生异常，则用第二个(下面这个)表达式作为结果</span><br><span class="line">response -&gt; Mono.empty())</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">User user = userMono.block();</span><br><span class="line"><span class="keyword">if</span>(user!=null) &#123;</span><br><span class="line">System.out.println(<span class="string">"success"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h3><p>服务端的代码也就是加一个@RequestHeader(“id”) 类似的注解。</p><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static String insertUser(WebClient webClient,User user) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.post()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user"</span>).header(<span class="string">"id"</span>, user.getId())</span><br><span class="line">//设置请求体为Json数据流</span><br><span class="line">.contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求体内容</span><br><span class="line">.body(Mono.just(user),User.class)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line"><span class="built_in">return</span> user2.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是在uri后面加一个.header(key,value).<br>也挺简单的。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振<br>    <a href="https://my.oschina.net/thinkgem/blog/2249665?from=timeline" target="_blank" rel="noopener">https://my.oschina.net/thinkgem/blog/2249665?from=timeline</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次有说过Webflux框架基本的服务端的开发，其最大的好处就是支持异步处理，可以提高性能，那么当今时代，微服务的架构十分盛行的情况下，多个一个大型的系统可能被拆分成多个系统，这样拆分的好处就是，首先各个系统相对独立，便于维护和开发，简化了开发人员的负担，比如一个电商系统，它可能存在产品微服务，用来发布和管理产品，可能还有客户信息微服务等等，当然他们之前并不是孤立的，他们之前可以相互调用的，各个微服务主要以Rest风格请求的接口来实现相互调用的…
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(2)Spring5新框架——WebFlux框架</title>
    <link href="http://yoursite.com/2019/01/06/Spring%E7%9B%B8%E5%85%B3-2-WebFlux%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/01/06/Spring相关-2-WebFlux框架/</id>
    <published>2019-01-06T04:04:50.000Z</published>
    <updated>2019-01-07T11:18:12.561Z</updated>
    
    <content type="html"><![CDATA[<p>在当前互联网应用中，存在电商和金融行业等企业，这些企业对于业务逻辑的严谨性要求特别高，因为他们的业务关系到用户和商家账户以及财产安全，对于数据的一致性非常高，所以一般情况下通过锁等其他机制保证数据的一致性，但是这也会造成性能的下降。对于另外一些互联网应用就不一样了，比如游戏，视频，新闻，门户，(毕业设计~=。=)，他们一般不会涉及操作财产和账户，相对更在意的是并发数和响应速度，而传统的开发模式会引入一致性的机制，这也是造成他们性能瓶颈的原因之一，为此就提出了响应式编程的概念。</p><p>在Servlet3.1规范开始，javaEE支持异步处理，即收到请求之后，Servlet线程可以将耗时的操作委派给另外一个线程来完成，在不生成响应的情况下返回给容器，使得Java可以更好的支持响应式编程，也就是在Spring5中发布了新的响应式Web框架——WebFlux,不过要注意的是，Spring2.X才支持WebFlux框架…..<a id="more"></a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Spring-WebFlux-概述："><a href="#Spring-WebFlux-概述：" class="headerlink" title="Spring WebFlux 概述："></a>Spring WebFlux 概述：</h3><p>   在Servlet3.1之前，Web容器都是基于阻塞机制开发的，而Servlet3.1开始，就有了非阻塞的规范(异步)，对于高并发的网站，使用韩说是编程显得更为直观和简易，特别是那些需要高速响应并且对于业务逻辑要求并不十分严格的网站，如游戏，视频等等</p><p>   在Java8 开始，引入了Lambda表达式和Functional接口等新特性，也使得java的语法更加丰富<br>   对于响应式编程而言，分为Router Functions、Spring Webflux和Http/Reactive Streams<br>   Router Functions 是一个路由分发，他会根据请求时间，决定采用什么类的什么方法来处理请求，也就是Selector，不参与实际业务逻辑的处理，只是起到一个分发的作用。</p><p>   Spring WebFlux，也就是控制层，参与实际业务逻辑的处理及Stream 流的返回。</p><p>   Http/ReactiveStream:将结果转换为流的过程。</p><p>   Spring WebFlux 是需要支持Servlet3.1+的容器，比如Tomcat、Netty、Jetty等等， SpringBoot中默认的依赖是Netty库。<br>   最后，说一说数据流的封装，也就是Flux 和Mono。它们都是封装数据流的类，其中Flux 是存放的0~N个数据流序列，响应式编程会一个接一个的将它们发送给客户端；而对于Mono而言，它存放的是0~1个数据流序列，这就是它们之前的不同，当然，它们是可以相互转换的。</p><h3 id="WebHandler接口"><a href="#WebHandler接口" class="headerlink" title="WebHandler接口"></a>WebHandler接口</h3><p>在SpringMVC中，是使用的DispatcherServlet来处理分发请求和响应的，在WebFlux中采用的是WebHandler，它和前者很相似。而对于WebHandler，最重要的就是DispatcherHandler，而在这其中，设计WebFlux流程的就是handle方法，下面放源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class="line">   //日志</span><br><span class="line"><span class="keyword">if</span> (this.handlerMappings == null) &#123;</span><br><span class="line"><span class="built_in">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> Flux</span><br><span class="line">       //Reactive框架封装的数据流类Flux</span><br><span class="line">       //循环HandlerMapping</span><br><span class="line">       .fromIterable(this.handlerMappings)</span><br><span class="line">//找到合适的控制器</span><br><span class="line">       .concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">       //处理第一条合适的记录</span><br><span class="line">.next()</span><br><span class="line">//如果出现找不到处理器的情况</span><br><span class="line">       .switchIfEmpty(createNotFoundError())</span><br><span class="line">//通过反射运行处理器</span><br><span class="line">       .flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line">//解析结果，将其转换成对应的数据流序列</span><br><span class="line">       .flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和SpringMVC一样，都是从HanlerMapping找到对应的处理器，这也就是为什么可以使用@Controller等注解的原因，通过这些配置的路径能够通过getHandler方法找到对应的处理器(和MVC一致，处理器包含控制器逻辑)，找到处理器之后通过invokeHandler方法运行处理器最后将结果通过handlerResult返回，转换成对应的数据流。</p><h2 id="使用SpringMVC开发WebFlux"><a href="#使用SpringMVC开发WebFlux" class="headerlink" title="使用SpringMVC开发WebFlux"></a>使用SpringMVC开发WebFlux</h2><h3 id="pom文件中添加依赖"><a href="#pom文件中添加依赖" class="headerlink" title="pom文件中添加依赖"></a>pom文件中添加依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>上面有3个依赖，一个是WebFlux所需要的依赖，一个是tomcat的依赖，主要说的是MongoDB的依赖，使用WebFlux主要目的就是异步请求相应，也就是非阻塞的数据响应，而目前主流数据库(Oracle、MySql等等都是不支持非阻塞开发的。)所以这里没办法使用工作中经常使用的数据库，这里就可以使用一个Spring-data-Reactive 支持的NoSql数据库(MongoDB)，所以引入的以上相关的一些jar</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line">import org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line">//标记未Mongo文档</span><br><span class="line">@Document</span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 939273844324506896L;</span><br><span class="line">@Id</span><br><span class="line">private String id;</span><br><span class="line"></span><br><span class="line">private String sex;</span><br><span class="line">//在MongoDB中使用user_name 来保存</span><br><span class="line">@Field(<span class="string">"user_name"</span>)</span><br><span class="line">private String userName;</span><br><span class="line">private String note;</span><br><span class="line">/*省略get/<span class="built_in">set</span> 以及构造方法*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类没啥特别需要注意的，也就是需要实现序列化接口</p><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.dao;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">/**</span><br><span class="line"> * 注意：这里需要继承ReactiveMongoRepository接口，这样就相当自动帮我们整合了增删改查</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月6日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">@Repository</span><br><span class="line">public interface IUserDao extends ReactiveMongoRepository&lt;User, Long&gt;&#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据用户名和备注进行模糊查询</span><br><span class="line"> * @param userName</span><br><span class="line"> * @param note</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">Flux&lt;User&gt; findByUserNameLikeAndNoteLike(String userName,String note);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要继承ReactiveMongoRepository 接口，这样就相当于WebFlux为MongoDB封装好了的一个增删改查的接口</p><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">public interface IUserService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mono&lt;User&gt; insertUser(User user);</span><br><span class="line"></span><br><span class="line">Mono&lt;User&gt; updateUser(User user);</span><br><span class="line"></span><br><span class="line">Flux&lt;User&gt; findUsers(String userName,String note);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.dao.IUserDao;</span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IUserService;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IUserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;User&gt; insertUser(User user) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;User&gt; updateUser(User user) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Flux&lt;User&gt; findUsers(String userName, String note) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.findByUserNameLikeAndNoteLike(userName, note);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IUserService;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IUserService userService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新用户</span><br><span class="line"> * @param user</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PutMapping(<span class="string">"/user"</span>)</span><br><span class="line">public Mono&lt;User&gt; updateUser(@RequestBody User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.updateUser(user);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 新增用户</span><br><span class="line"> * @param user</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PostMapping(value=<span class="string">"/user"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser(@RequestBody User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/like/&#123;userName&#125;/&#123;note&#125;"</span>)</span><br><span class="line">public Flux&lt;User&gt; <span class="built_in">test</span>(@PathVariable(<span class="string">"userName"</span>)String userName,@PathVariable(<span class="string">"note"</span>)String note)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.findUsers(userName, note);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: localhost</span><br><span class="line">      username: weblogic</span><br><span class="line">      password: password1</span><br><span class="line">      port: 27017</span><br><span class="line">      database: springboot</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line">import org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">//因为引入了JPA包，所以默认情况下会加载数据源，需要排除原本自动装配的数据源</span><br><span class="line">@EnableAutoConfiguration(exclude= &#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">//驱动Mongo注解</span><br><span class="line">@EnableReactiveMongoRepositories(basePackages=<span class="string">"com.wangshun.leaning.dao"</span>)</span><br><span class="line">public class SpringBootLeaning10WebFluxApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringBootLeaning10WebFluxApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><h4 id="模糊查询方法"><a href="#模糊查询方法" class="headerlink" title="模糊查询方法"></a>模糊查询方法</h4><p><img src="/images/Spring/Spring2/spring1.png"></p><h4 id="save方法："><a href="#save方法：" class="headerlink" title="save方法："></a>save方法：</h4><p><img src="/images/Spring/Spring2/spring2.png"></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h3><p>参考地址：<br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p><h3 id="MongoDB-可视化界面使用-需要git"><a href="#MongoDB-可视化界面使用-需要git" class="headerlink" title="MongoDB 可视化界面使用(需要git)"></a>MongoDB 可视化界面使用(需要git)</h3><p>参考地址：<br><a href="https://www.cnblogs.com/shiweida/p/7692468.html" target="_blank" rel="noopener">https://www.cnblogs.com/shiweida/p/7692468.html</a></p><h3 id="MongoDB创建用户"><a href="#MongoDB创建用户" class="headerlink" title="MongoDB创建用户"></a>MongoDB创建用户</h3><p>注意：需要切换到对应的数据库下进行创建才能连接<br>切换数据库命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use xxxxx（数据库名称）</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">user: <span class="string">"weblogic"</span>,</span><br><span class="line"><span class="built_in">pwd</span>: <span class="string">"password1"</span>,</span><br><span class="line">roles: [&#123;</span><br><span class="line">role: <span class="string">"userAdminAnyDatabase"</span>,</span><br><span class="line">db: <span class="string">"admin"</span></span><br><span class="line">&#125;],</span><br><span class="line">mechanisms: [<span class="string">"SCRAM-SHA-1"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整了一下午才弄好，踩了无数个坑，说几个常见的坑吧：</p><h3 id="错误解决方案"><a href="#错误解决方案" class="headerlink" title="错误解决方案"></a>错误解决方案</h3><h4 id="com-mongodb-MongoSecurityException-Exception-authenticating-MongoCredential-mechanism-SCRAM-SHA-1-userName-’weblogic’-source-’springboot’-password-mechanismProperties-”"><a href="#com-mongodb-MongoSecurityException-Exception-authenticating-MongoCredential-mechanism-SCRAM-SHA-1-userName-’weblogic’-source-’springboot’-password-mechanismProperties-”" class="headerlink" title="com.mongodb.MongoSecurityException:Exception authenticating MongoCredential{mechanism=SCRAM-SHA-1, userName=’weblogic’, source=’springboot’, password=, mechanismProperties={}}”"></a>com.mongodb.MongoSecurityException:Exception authenticating MongoCredential{mechanism=SCRAM-SHA-1, userName=’weblogic’, source=’springboot’, password=<hidden>, mechanismProperties={}}”</hidden></h4><p>这个报错是因为你所配置的数据库不存在这个用户 或者用户名密码错误，正如上面我所说的那样，需要先切换到一些数据库之后再创建用户。</p><h4 id="message”-“E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-nested-exception-is-com-mongodb-MongoWriteException-E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-”"><a href="#message”-“E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-nested-exception-is-com-mongodb-MongoWriteException-E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-”" class="headerlink" title="message”: “E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }; nested exception is com.mongodb.MongoWriteException: E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }”"></a>message”: “E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }; nested exception is com.mongodb.MongoWriteException: E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }”</h4><p>这个是因为主键冲突了，一般当你把ID定义成int 类型的时候使用@Id 注解之后它第一次确实会给你生成一个ID  是0，但是后续不会自增长，如果说你有需要使用数字主键请自行百度Mongo实现主键自增长，目前我还没有研究出来这个。</p><p>ps：代码Service层没有写默认的根据ID查询的方法是因为  默认的接口中实现是采用Long 类型的参数查询的，而这里Long类型的参数由于没有自定义主键自增长，所以我暂时还没有实现，还有一种方法就是采用另外一种指定参数的查询，现没找到.<br>就先说这么多吧，时间也不早了，吃饭去……</p><p>参考文献：<br>    《深入浅出SpringBoot2.x》——杨开振<br>    <a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a><br>    <a href="https://www.cnblogs.com/shiweida/p/7692468.html" target="_blank" rel="noopener">https://www.cnblogs.com/shiweida/p/7692468.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当前互联网应用中，存在电商和金融行业等企业，这些企业对于业务逻辑的严谨性要求特别高，因为他们的业务关系到用户和商家账户以及财产安全，对于数据的一致性非常高，所以一般情况下通过锁等其他机制保证数据的一致性，但是这也会造成性能的下降。对于另外一些互联网应用就不一样了，比如游戏，视频，新闻，门户，(毕业设计~=。=)，他们一般不会涉及操作财产和账户，相对更在意的是并发数和响应速度，而传统的开发模式会引入一致性的机制，这也是造成他们性能瓶颈的原因之一，为此就提出了响应式编程的概念。&lt;/p&gt;
&lt;p&gt;在Servlet3.1规范开始，javaEE支持异步处理，即收到请求之后，Servlet线程可以将耗时的操作委派给另外一个线程来完成，在不生成响应的情况下返回给容器，使得Java可以更好的支持响应式编程，也就是在Spring5中发布了新的响应式Web框架——WebFlux,不过要注意的是，Spring2.X才支持WebFlux框架…..
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(1)异步线程池和jms</title>
    <link href="http://yoursite.com/2019/01/05/Spring%E7%9B%B8%E5%85%B3-1-%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8Cjms/"/>
    <id>http://yoursite.com/2019/01/05/Spring相关-1-异步线程池和jms/</id>
    <published>2019-01-05T04:26:29.000Z</published>
    <updated>2019-01-05T09:40:09.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步线程池"><a href="#异步线程池" class="headerlink" title="异步线程池"></a>异步线程池</h2><p>在之前的学习中，除了Redis之外，其他所有的都是同步应用，那么其实在开发的过程中，有些时候我们需要使用异步线程，即一个请求需要2个或者2个异常线程去请求，比如生成报表，运维人员只需要点击生成报表即可，并不是需要立即查看报表，那么生成报表可能需要牵扯大量的数据查询并生成，这如果在同一个线程中是很耗费时间的。而且用户的体验也不是很好，接下来 就来说说异步线程。</p><p>就以上的需求大概的逻辑是这样的，运维人员点击生成报表，启动线程1执行生成报表的一些基本操作，同时启动线程2，由线程2去独立完成生成报表的一些大量操作，而线程一无需等待，直接进入下一步操作，这样的话运维人员就不需要等待线程的完成，可以是很好的用户体验…<a id="more"></a></p><h2 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h2><h3 id="定义线程池和开启异步可用"><a href="#定义线程池和开启异步可用" class="headerlink" title="定义线程池和开启异步可用"></a>定义线程池和开启异步可用</h3><p>在Spring 中存在一个AsyncConfigurer接口，它是一个可以配置异步线程池的接口，他的源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.scheduling.annotation;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">public interface AsyncConfigurer &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取线程池</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">default Executor <span class="function"><span class="title">getAsyncExecutor</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步异常处理器</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">default AsyncUncaughtExceptionHandler <span class="function"><span class="title">getAsyncUncaughtExceptionHandler</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上代码可以看出方法本身还是比较简单的，其中getAsyncExecutor方法返回的是一个自定义的线程池，这样在开启异步时，线程池就会提空空闲线程来执行异步任务，因为线程中的业务逻辑可能出现异常，所以也定义了一个处理异常的方法，使得异常可以自定义处理，为了使得这个接口方便使用，Spring还提供了空的实现，所以我们只需要实现AsyncConfigurer接口覆盖掉对应的方法即可。</p><p>因此我们只需要java配置文件类，实现AsyncConfigurer接口，实现getAsyncExecutor方法返回的线程池，这样Spring就会将这个线程池作为异步调用的线程。为了使得异步可用，Spring还提供了一个注解@EnableAnsync,如果java配置文件配置它，那么Spring就会开启异步即可，这样就可以使用@Async注解来驱动Spring使用异步调用，接下来用一个例子来进行说明</p><h3 id="异步实例"><a href="#异步实例" class="headerlink" title="异步实例"></a>异步实例</h3><h4 id="java配置类"><a href="#java配置类" class="headerlink" title="java配置类"></a>java配置类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line">/**</span><br><span class="line"> * 定义线程池和启用异步调用</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月5日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">@EnableAsync</span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig implements AsyncConfigurer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Executor <span class="function"><span class="title">getAsyncExecutor</span></span>() &#123;</span><br><span class="line">//定义线程池</span><br><span class="line">ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class="line">//设置核心线程数</span><br><span class="line">taskExecutor.setCorePoolSize(10);</span><br><span class="line">//设置线程池最大线程数</span><br><span class="line">taskExecutor.setMaxPoolSize(30);</span><br><span class="line">//设置线程队列最大线程数</span><br><span class="line">taskExecutor.setQueueCapacity(2000);</span><br><span class="line">taskExecutor.initialize();</span><br><span class="line"><span class="built_in">return</span> taskExecutor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，注解@EnableAsync 代表开启异步，这样就可以使用@Async驱动Spring使用异步，但是异步需要提供可用的线程池，所以这里的配置类实现了AsyncConfigurer接口，实现其中方法，这样就可以定义一个线程池，并在实现的方法中定义了一些属性和初始化线程池，这样异步就可以使用了。</p><h4 id="Service-实现类-接口省略-，略略略"><a href="#Service-实现类-接口省略-，略略略" class="headerlink" title="Service 实现类(接口省略 ，略略略~)"></a>Service 实现类(接口省略 ，略略略~)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IAsynccService;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class AsyncServiceImpl implements IAsynccService&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//声明采用异步调用</span><br><span class="line">@Async</span><br><span class="line">public void <span class="function"><span class="title">generateReport</span></span>() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(<span class="string">"报表线程名称:"</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IAsynccService;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value=<span class="string">"/async"</span>)</span><br><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IAsynccService asynccService;</span><br><span class="line">@GetMapping(value=<span class="string">"/test"</span>)</span><br><span class="line">public String <span class="function"><span class="title">asyncPage</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"请求线程名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">//开启异步调用</span><br><span class="line">asynccService.generateReport();</span><br><span class="line"><span class="built_in">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试日志"><a href="#测试日志" class="headerlink" title="测试日志"></a>测试日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-05 12:58:23.000  INFO 19264 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 8 ms</span><br><span class="line">请求线程名称:http-nio-8080-exec-6</span><br><span class="line">2019-01-05 12:58:52.122  INFO 19264 --- [nio-8080-exec-6] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService</span><br><span class="line">报表线程名称:ThreadPoolTaskExecutor-1</span><br></pre></td></tr></table></figure><p>通过日志可以看到控制器方法和异步方法是由不同的线程完成的，通过类似的方法就可以在Spring中使用异步调用</p><h2 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h2><p>有时候需要和其他系统集成，最常见的就是短信系统，网站中注册的时候，经常会有点击发送验证码。对于业务系统而言，只需要发送请求到短信系统就可以，短信系统就是一个异步系统，当发送消息之后，短信系统可能没有立刻将短信发出，正如生活中有时候收到短信会慢一样(举报暴雪的邮件系统~)。</p><p>为了给其他系统发送消息，java中引入了JMS(java消息服务)，jms按照其规范分为点对点和发布订阅两种形式，点对点就是将一个系统的消息发布到另外一个指定系统，而订阅就是一个系统约定将消息发布到一个主题中，然后各个系统通过订阅这个主题可以收到发送过来的信息处理对应的业务，大部分情况下是需要采用订阅模式的，因为可以进行更多的扩展(适用于一对多系统)<br>。</p><p>在实际的工作中，JMS服务的规范啊有很多，常见的就是ActiveMQ和分布式kafka。为了更为可靠和安全，还存在AMQP协议，实现它比较常见的有RabbitMQ等等，接下来就说说ActiveMQ和RabbitMQ。</p><h3 id="JMS实例——ActiveMQ"><a href="#JMS实例——ActiveMQ" class="headerlink" title="JMS实例——ActiveMQ"></a>JMS实例——ActiveMQ</h3><h4 id="下载并启动ActiveMQ"><a href="#下载并启动ActiveMQ" class="headerlink" title="下载并启动ActiveMQ"></a>下载并启动ActiveMQ</h4><p>下载的话，地址为：activemq.apache.org，下载完成后解压进入bin目录下，按照计算机操作系统启动其activemq.bat即可。</p><p>启动之后输入<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a>  使用admin/admin登录，就可以看到以下界面了<br><img src="/images/Spring/Spring1/spring1.png"><br>启动完成之后就可以在java中进行使用了</p><h4 id="java中使用ActiveMQ"><a href="#java中使用ActiveMQ" class="headerlink" title="java中使用ActiveMQ"></a>java中使用ActiveMQ</h4><h5 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ActiveMQ依赖  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--ActiveMQ连接依赖  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第一个包是引入ActiveMQ的starter，这样就可以在application.yml文件中对于ActiveMQ进行配置，第二个是引入了连接池机制，有了这些依赖，我们就可以进行配置了。</p><h5 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ActiveMq地址</span></span><br><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line">spring.activemq.user=admin</span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line">spring.activemq.password=admin</span><br><span class="line"><span class="comment">#是否使用发布订阅模式，默认false 采用点对点模式</span></span><br><span class="line">spring.jms.pub-sub-domain=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 默认目标地址</span></span><br><span class="line">spring.jms.template.default-destination=activemq.default.destination</span><br><span class="line"><span class="comment">#是否启用连接池</span></span><br><span class="line">spring.active.pool.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment">#连接池最大数量配置</span></span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure><p>上面的配置如果启用订阅模式就会报错，我也不知道是为什么…所以暂时采用点对点吧。<br>SpringBoot会根据上述的配置生成许多ActiveMQ相关对象，如jms连接工厂、连接池和jmsTemplate，而对于消息的发送和接收可以通过jmsTemplate处理，关于接收消息，Spring提供了一个注解@JmsListener进一步简化了我们的工作，因此需要定义一个接口，它既能发送jms消息，也可以接收jms消息<br>这里没使用yml文件是因为一样的配置 yml文件配置启动会报错找不到jmsTemplate 对象，我也不知道为什么。。。。。</p><h5 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jms.annotation.JmsListener;</span><br><span class="line">import org.springframework.jms.core.JmsTemplate;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IActiveMqService;</span><br><span class="line"></span><br><span class="line">public class ActiveMqServiceImpl implements IActiveMqService &#123;</span><br><span class="line">/**</span><br><span class="line"> * 注入由SpringBoot自动生产的JMsTemplate、</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">@Autowired</span><br><span class="line">private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sendMsg(String message) &#123;</span><br><span class="line">System.out.println(<span class="string">"发送消息:"</span>+message);</span><br><span class="line">jmsTemplate.convertAndSend(message);</span><br><span class="line">//自定义发送地址</span><br><span class="line">//jmsTemplate.convertAndSend(<span class="string">"your-destinnation"</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//使用注解监听地址发送过来的消息</span><br><span class="line">@JmsListener(destination=<span class="string">"<span class="variable">$spring</span>.jms.template.default-destionation"</span>)</span><br><span class="line">public void receiveMsg(String message) &#123;</span><br><span class="line">System.out.println(<span class="string">"接收到的消息为："</span>+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是注入了jmsTemplate，这个对象是由SpringBoot自动配置机制生成的，接着是sendMsg方法，它是发送jms消息，这里调用的是convertAndSend ，就是转化并发送的方法，把我们传入的消息通过默认的转化器进行转化之后再发送出去，如果我们需要修改转化器，只需要调用sendMessageConvert方法即可。</p><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(<span class="string">"/activemq"</span>)</span><br><span class="line">public class ActiveMqController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IActiveMqService activeMqService;</span><br><span class="line">@GetMapping(value=<span class="string">"/send/&#123;msg&#125;"</span>)</span><br><span class="line">public Map&lt;String, Object&gt; sendMsg(@PathVariable(value=<span class="string">"msg"</span>)String message)&#123;</span><br><span class="line">Map&lt;String, Object&gt; resultsMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">activeMqService.sendMsg(message);</span><br><span class="line">resultsMap.put(<span class="string">"success"</span>, message);</span><br><span class="line"><span class="built_in">return</span> resultsMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-01-05 15:57:29.774  INFO 27860 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2019-01-05 15:57:29.774  INFO 27860 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2019-01-05 15:57:29.785  INFO 27860 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 11 ms</span><br><span class="line">发送消息:123345</span><br><span class="line">接收到的消息为：123345</span><br></pre></td></tr></table></figure><p>当然，我们有时候可能传递的不止是一个String 字符串，比如我们想传递一个对象，就可以这样写：</p><h4 id="AcitiveMQ-传递User对象"><a href="#AcitiveMQ-传递User对象" class="headerlink" title="AcitiveMQ 传递User对象"></a>AcitiveMQ 传递User对象</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 939273844324506896L;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line">private String userName;</span><br><span class="line">private String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类没啥好说的，只有实现Serializable接口，实现序列化~</p><h5 id="Service-实现类"><a href="#Service-实现类" class="headerlink" title="Service 实现类"></a>Service 实现类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.jms.annotation.JmsListener;</span><br><span class="line">import org.springframework.jms.core.JmsTemplate;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IActiveMqUserService;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class ActiveMqUserServiceImpl implements IActiveMqUserService&#123;</span><br><span class="line"></span><br><span class="line">private static final String myDestination = <span class="string">"my-destination"</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注入由SpringBoot自动生产的JMsTemplate、</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">@Autowired</span><br><span class="line">private JmsTemplate jmsTemplate = null;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sendMsg(User user) &#123;</span><br><span class="line">System.out.println(<span class="string">"发送消息:"</span>+user);</span><br><span class="line">//自定义发送地址</span><br><span class="line">jmsTemplate.convertAndSend(myDestination,user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//使用注解监听地址发送过来的消息</span><br><span class="line">@JmsListener(destination=myDestination)</span><br><span class="line">public void receiveMsg(User user) &#123;</span><br><span class="line">System.out.println(<span class="string">"接收到的消息为："</span>+user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   @Autowired</span><br><span class="line">private IActiveMqUserService activeMqUserService;</span><br><span class="line"></span><br><span class="line">@GetMapping(value=<span class="string">"/send/&#123;id&#125;/&#123;name&#125;"</span>)</span><br><span class="line">public Map&lt;String, Object&gt; sendUserMsg(@PathVariable(value=<span class="string">"id"</span>)Long id,@PathVariable(value=<span class="string">"name"</span>)String name)&#123;</span><br><span class="line">User user = new User(id,name,<span class="string">""</span>);</span><br><span class="line">Map&lt;String, Object&gt; resultsMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">activeMqUserService.sendMsg(user);</span><br><span class="line">resultsMap.put(<span class="string">"success"</span>, user);</span><br><span class="line"><span class="built_in">return</span> resultsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件中添加active信任包"><a href="#配置文件中添加active信任包" class="headerlink" title="配置文件中添加active信任包"></a>配置文件中添加active信任包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.packages.trust-all=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里我尝试过使用个别包的设置,但是失败了…留一个坑….</p><h5 id="测试日志-1"><a href="#测试日志-1" class="headerlink" title="测试日志"></a>测试日志</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送消息:com.wangshun.leaning.entity.User@15f7b9a0</span><br><span class="line">接收到的消息为：com.wangshun.leaning.entity.User@4b08eec1</span><br></pre></td></tr></table></figure><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步线程池&quot;&gt;&lt;a href=&quot;#异步线程池&quot; class=&quot;headerlink&quot; title=&quot;异步线程池&quot;&gt;&lt;/a&gt;异步线程池&lt;/h2&gt;&lt;p&gt;在之前的学习中，除了Redis之外，其他所有的都是同步应用，那么其实在开发的过程中，有些时候我们需要使用异步线程，即一个请求需要2个或者2个异常线程去请求，比如生成报表，运维人员只需要点击生成报表即可，并不是需要立即查看报表，那么生成报表可能需要牵扯大量的数据查询并生成，这如果在同一个线程中是很耗费时间的。而且用户的体验也不是很好，接下来 就来说说异步线程。&lt;/p&gt;
&lt;p&gt;就以上的需求大概的逻辑是这样的，运维人员点击生成报表，启动线程1执行生成报表的一些基本操作，同时启动线程2，由线程2去独立完成生成报表的一些大量操作，而线程一无需等待，直接进入下一步操作，这样的话运维人员就不需要等待线程的完成，可以是很好的用户体验…
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(10)构建Rest风格的网站</title>
    <link href="http://yoursite.com/2019/01/01/SpringBoot-10-%E6%9E%84%E5%BB%BARest%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2019/01/01/SpringBoot-10-构建Rest风格的网站/</id>
    <published>2019-01-01T03:11:58.000Z</published>
    <updated>2019-01-02T13:33:50.307Z</updated>
    
    <content type="html"><![CDATA[<p>Rest接口，又或者是Rest风格的网站，现在已经是非常的流行了，在ESB中Rest是一种协议方式，正如WebService一样，之前我一直以为我使用SSM框架写的那种/xxx/xxx,do这种就是Rest风格，其实不然，有一些细微的差别，Rest风格是有自己的规范的，按照Rest规范构建的才能算是Rest风格。让我第一次接触Rest以及印象深刻的是17年年底在公司看到的面试题：“如何使用Spring构建一个Restful API”emmmmmmm到现在还是不会做……看来我当年进公司纯属幸运……hhh….<a id="more"></a></p><h2 id="Rest简述"><a href="#Rest简述" class="headerlink" title="Rest简述"></a>Rest简述</h2><p>Rest这个词，全拼为Representational State Transfer,翻译过来也就是表现层状态转变，如果一个架构符合Rest的原则，那么它就是Rest风格的架构。</p><h3 id="Http动作"><a href="#Http动作" class="headerlink" title="Http动作"></a>Http动作</h3><p>Rest风格的资源是通过Http的行为去操作资源的，对于资源而言，它存在 创建、修改、访问、删除的状态转换，这样也就对应Http行为的五种动作</p><h4 id="Get-VISIT"><a href="#Get-VISIT" class="headerlink" title="Get(VISIT)"></a>Get(VISIT)</h4><pre><code>访问服务器资源(一个或者多个)</code></pre><h4 id="POST-CREATE"><a href="#POST-CREATE" class="headerlink" title="POST(CREATE)"></a>POST(CREATE)</h4><pre><code>提交服务器资源信息，用来创建新的资源</code></pre><h4 id="PUT-UPDATE"><a href="#PUT-UPDATE" class="headerlink" title="PUT(UPDATE)"></a>PUT(UPDATE)</h4><pre><code>修改服务器已经存在的资源，使用PUT时需要把资源的所有属性一并提交</code></pre><h4 id="PATCH-UPDATE"><a href="#PATCH-UPDATE" class="headerlink" title="PATCH(UPDATE)"></a>PATCH(UPDATE)</h4><pre><code>修改服务器已经存在的资源，使用PATCH时只需要把部分资源的属性提交</code></pre><h4 id="DELETE-DELETE"><a href="#DELETE-DELETE" class="headerlink" title="DELETE(DELETE)"></a>DELETE(DELETE)</h4><pre><code>从服务器删除资源</code></pre><p><strong>除了 以上五种常用的动作，还有两种不常用的动作。</strong></p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><pre><code>获取资源的元数据(content-type)</code></pre><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><pre><code>提供资源可供客户端修改属性信息</code></pre><p>有了以上的动作，接来下说说Rest风格的URL设计</p><h3 id="Rest风格URL设计"><a href="#Rest风格URL设计" class="headerlink" title="Rest风格URL设计"></a>Rest风格URL设计</h3><h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><pre><code>GET /user/1</code></pre><h4 id="查询多个用户信息"><a href="#查询多个用户信息" class="headerlink" title="查询多个用户信息"></a>查询多个用户信息</h4><pre><code>GET /users/{userName}/{note}</code></pre><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><pre><code>POST /user/{userName}/{note}/{sex}</code></pre><h4 id="修改用户全部信息"><a href="#修改用户全部信息" class="headerlink" title="修改用户全部信息"></a>修改用户全部信息</h4><pre><code>PUT /user/{id}/{userName}/{note}/{sex}</code></pre><h4 id="修改用户名称-部分信息"><a href="#修改用户名称-部分信息" class="headerlink" title="修改用户名称(部分信息)"></a>修改用户名称(部分信息)</h4><pre><code>PATCH /user/{id}/{userName}</code></pre><p><strong>注意：</strong> 在URL中并没有出现动词，对于参数主要是通过url设计去获取的，对于参数超过5个的可以考虑采用JSON的方式去传递参数。</p><h3 id="Rest风格的一些误区"><a href="#Rest风格的一些误区" class="headerlink" title="Rest风格的一些误区"></a>Rest风格的一些误区</h3><p>在设计Url时，Rest风格存在一些规范如下：</p><h4 id="1-一般不应在URL中存在动词"><a href="#1-一般不应在URL中存在动词" class="headerlink" title="1.一般不应在URL中存在动词"></a>1.一般不应在URL中存在动词</h4><pre><code>比如：GET /user/get/1应该修改为： GET /user/1</code></pre><h4 id="2-URL中不应该添加版本号"><a href="#2-URL中不应该添加版本号" class="headerlink" title="2.URL中不应该添加版本号"></a>2.URL中不应该添加版本号</h4><pre><code>比如： GET /v1/user/1在Rest风格的资源的URL是唯一的，这有点和微服务的思想有些类似，如果存在版本号，可以通过设置Http请求头来进行区分。例如：Accept：version=1.0</code></pre><h4 id="不推荐采用原本的Get方式传递参数"><a href="#不推荐采用原本的Get方式传递参数" class="headerlink" title="不推荐采用原本的Get方式传递参数"></a>不推荐采用原本的Get方式传递参数</h4><pre><code>例如:PUT /user?username=1&amp;password=1应该修改为 put /user/{username}/{password}</code></pre><h2 id="使用SpringMVC开发Rest风格端点"><a href="#使用SpringMVC开发Rest风格端点" class="headerlink" title="使用SpringMVC开发Rest风格端点"></a>使用SpringMVC开发Rest风格端点</h2><p>Spring 对于Rest风格的机制是基于Spring MVC的设计基础上的。</p><h3 id="SpringMVC整合REST"><a href="#SpringMVC整合REST" class="headerlink" title="SpringMVC整合REST"></a>SpringMVC整合REST</h3><p>在之前也说过了，Rest这种风格，其实也就是使用@RequestMapping然后其中的命名符合Rest的规范即可。<br>那么为了方便Rest接口的开发，Spring现如今还提供了以下5个注解<br>@GetMapping:对应http的Get请求</p><p>@PostMapping:对应http的post请求</p><p>@PutMapping:对应http的Put请求</p><p>@PatchMapping:对应http的Patch请求</p><p>@DeleteMapping:对应http的Delete请求</p><p>而使用了Rest风格的传参风格之后，可以在后台使用@PathVariable注解来获取参数，这样就可以满足Rest风格的传参的要求了。<br>当然，对于字段较多的，还是建议@RequestBody 传递Json</p><h3 id="使用Spring-开发Rest接口"><a href="#使用Spring-开发Rest接口" class="headerlink" title="使用Spring 开发Rest接口"></a>使用Spring 开发Rest接口</h3><p>接下来以一个简单的例子来模拟Rest风格的接口开发</p><h4 id="学生实体类"><a href="#学生实体类" class="headerlink" title="学生实体类"></a>学生实体类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line">@Alias(<span class="string">"student"</span>)</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String name;</span><br><span class="line">private String age;</span><br><span class="line">private String sex;</span><br><span class="line"></span><br><span class="line">/*省略get/<span class="built_in">set</span>  以及构造方法*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>)</span><br><span class="line">public int insertStudent(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line"><span class="built_in">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(<span class="string">"/student/&#123;id&#125;"</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Student getStudentInfoById(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line"><span class="built_in">return</span> studentService.getStudentById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的类似于Put/Delete等等的也是大同小异，使用Rest风格的接口大多数都是使用@PathVariable注解来获取参数<br>只要命名注意规范其他的都差不多……</p><p>当然，在现在前后端分离的大局势下，返回Json 格式是最常用的一种数据格式了，那么每个接口都写上@ResponsoBody又显得麻烦…所以我们可以在Controller类上面统一加上@RestController注解  这样其类下面的每个方法都相当于添加了@ResponseBody注解</p><p>当然，可能前后端的接口参数可能会有不同，比如前段sex参数传的是男女，后端存数据库的是01 这样的话可能还需要类似于DTO和Entity的转化….这里较懒所以没加入，如果有兴趣的可以添加一下</p><h4 id="RequestMapping-的2个属性"><a href="#RequestMapping-的2个属性" class="headerlink" title="@RequestMapping 的2个属性"></a>@RequestMapping 的2个属性</h4><p>在@RequestMapping、@GetMapping 等等注解中 还有2个参数，一个是produces  另外一个是consumes<br>这个在前面也说过，consumes是指请求体的类型，比如我们可能接收的请求体是文本(text)等等，如果做了限制，其他类型的就无法传入进来了。<br>而produces是指限制返回的媒体类型，比如application/json 等等。<br>比如：@PostMapping(value=”/student”,produces=”application/json;charset=utf-8”,consumes=MediaType.ALL_VALUE)</p><h3 id="处理HTTP状态码、异常和响应头"><a href="#处理HTTP状态码、异常和响应头" class="headerlink" title="处理HTTP状态码、异常和响应头"></a>处理HTTP状态码、异常和响应头</h3><p>再此之前，我们只是讨论了如何能够找到数据并进行资源处理，而没有讨论当没有找到资源处理或者说发生异常了应该如何处理，接下来来说说这些。</p><p>当资源找不到或者程序发生异常以后，我们应该返回给客户端HTTP状态码以及错误消息信息，为了简化这些开发，Spring提供了实体封装类ResponseEntity 以及注解@ResponseStatus，前者可以有效的封装错误信息和状态码，后者可以配置指定的响应码给客户端。</p><p>在大部分情况下，后台请求成功会返回一个200的状态码，代表请求成功，但是这还不够具体，比如说新增用户以后，返回201代表新增成功会更加具体一些，因为201代表新增资源成功，200只是代表请求成功而已。<br>这时候就可以使用ResponseEntity类或者@ResponseStatus注解来标识本次请求的状态码。除了在Http响应头中可以添加响应数据之外，还可以给响应头添加一些信息来提供成功或者失败的消息。下面以修改方法为例。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用注解完成状态码</span><br><span class="line"> * @param student</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@ResponseBody</span><br><span class="line">//指定状态码为201(资源创建成功)</span><br><span class="line">@ResponseStatus(value=HttpStatus.CREATED)</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>,consumes=MediaType.ALL_VALUE)</span><br><span class="line">public int insertStudent(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line"><span class="built_in">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line"> * 使用ResponseEntity返回状态码</span><br><span class="line"> * @param student</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>,consumes=MediaType.ALL_VALUE)</span><br><span class="line">public ResponseEntity&lt;Student&gt; insertStudent2(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">String success = (rows&gt;0)? <span class="string">"true"</span>:<span class="string">"false"</span>;</span><br><span class="line">//设置响应头，比较常用的方式</span><br><span class="line">headers.add(<span class="string">"success"</span>, success);</span><br><span class="line">//下面是使用集合(List)方式，不太常用</span><br><span class="line">//headers.put(<span class="string">"success"</span>, Arrays.asList(success));</span><br><span class="line">//返回创建的状态码</span><br><span class="line"><span class="built_in">return</span> new ResponseEntity&lt;Student&gt;(student,headers,HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个方法中有一个需要注意的地方，就是返回的时候，构造的ResponseEntity对象的第一个参数不能是int类型，由于我返回的就是int  所以只要写了student</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>student 方法<br><img src="/images/SpringBoot/SpringBoot10/sp10-1.png"></p><p>student2方法<br><img src="/images/SpringBoot/SpringBoot10/sp10-2.png"></p><p>可以看到写的状态码都已经成功返回给客户端了。</p><p>成功的情况讨论完了，来说说失败的情况，失败有很多种，比如get方法获取结果集为空，以及程序本身某处发生异常等等，默认情况下这些不做处理返回页面一个大大的500和报错内容是很不友好的<br>，而且在此之前也学习了一些异常的处理，比如控制层的@ControllerAdvice和@ExceptionHandler等等，当然，网上推荐的那种报错之后页面直接跳转<a href="http://www.baidu.com?pwd=#{exceptionInfo}" target="_blank" rel="noopener">www.baidu.com?pwd=#{exceptionInfo}</a> 也是很不错的一种想法~哈哈哈<br>不开玩笑了，说说正经的处理<br>@ControllerAdvice是用来定义控制器通知的，而@ExceptionHandler是指定异常发生时的处理办法，有这些只是就足以处理异常了。在此之前，先定义查找失败的异常，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.exception;</span><br><span class="line">/**</span><br><span class="line"> * 定义学生类找不到异常</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月2日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class NotFoundException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = -2533075100361102139L;</span><br><span class="line">//异常编码</span><br><span class="line">private Integer code;</span><br><span class="line">//异常信息</span><br><span class="line">private String message;</span><br><span class="line">public <span class="function"><span class="title">NotFoundException</span></span>() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public NotFoundException(Integer code, String message) &#123;</span><br><span class="line">super();</span><br><span class="line">this.code = code;</span><br><span class="line">this.message = message;</span><br><span class="line">&#125;</span><br><span class="line">public Integer <span class="function"><span class="title">getCode</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line">public void setCode(Integer code) &#123;</span><br><span class="line">this.code = code;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">getMessage</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">public void setMessage(String message) &#123;</span><br><span class="line">this.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了异常类，其继承于运行时异常类，所以可以在找不到用户时抛出异常，而在控制器抛出异常之后，则可以在控制器(@ControllerAdvice)中处理这些异常，这时候就需要使用注解@ExceptionHandler了，实际上，在SpringBoot的机制中早就准备好了BasicErrorController对象去处理发生的异常，但是它并不是很友好，所以我们还需要自定义一个控制通知。</p><h4 id="定义控制器通知来处理异常"><a href="#定义控制器通知来处理异常" class="headerlink" title="定义控制器通知来处理异常"></a>定义控制器通知来处理异常</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.exception;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice(</span><br><span class="line">//指定拦截包的控制器</span><br><span class="line">basePackages= &#123;<span class="string">"com.wangshun.leaning.controller.*"</span>&#125;,</span><br><span class="line">//限定为指定为@RestController  和@Controller 注解的才会被拦截</span><br><span class="line">annotations= &#123;Controller.class,RestController.class&#125;</span><br><span class="line">)</span><br><span class="line">public class StudentAdviceController &#123;</span><br><span class="line">//异常类型，可以定义异常类型进行拦截处理</span><br><span class="line">@ExceptionHandler(value=NotFoundException.class)</span><br><span class="line">@ResponseBody</span><br><span class="line">@ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">public Map&lt;String, Object&gt; exception(HttpServletRequest request,NotFoundException exception)&#123;</span><br><span class="line">Map&lt;String , Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(<span class="string">"code"</span>, exception.getCode());</span><br><span class="line">map.put(<span class="string">"message"</span>, exception.getMessage());</span><br><span class="line"><span class="built_in">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了@ControllerAdvice注解来标注类，说明在定义一个控制器的通知，配合它所拦截的包，限定了那些被标注为@Controller 和@RestController注解的控制器，按照其定义就可以拦截之前写好的控制器，这里的@ExceptionHandler定义了拦截NotFoundException，@ResponseBody标明了返回json格式，而@ResponseStatus注解定义了状态码为500(服务器内部错误)，这样就会把状态码传递给请求者。</p><p>接下来写一个测试类来进行测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/student/&#123;id&#125;"</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Student getStudentInfoById(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line">Student student = studentService.getStudentById(id);</span><br><span class="line"><span class="keyword">if</span>(student == null) &#123;</span><br><span class="line">throw new NotFoundException(1,<span class="string">"找不到用户"</span>+id+<span class="string">"的信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="soapUI测试结果"><a href="#soapUI测试结果" class="headerlink" title="soapUI测试结果"></a>soapUI测试结果</h4><p><img src="/images/SpringBoot/SpringBoot10/sp10-3.png"></p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rest接口，又或者是Rest风格的网站，现在已经是非常的流行了，在ESB中Rest是一种协议方式，正如WebService一样，之前我一直以为我使用SSM框架写的那种/xxx/xxx,do这种就是Rest风格，其实不然，有一些细微的差别，Rest风格是有自己的规范的，按照Rest规范构建的才能算是Rest风格。让我第一次接触Rest以及印象深刻的是17年年底在公司看到的面试题：“如何使用Spring构建一个Restful API”emmmmmmm到现在还是不会做……看来我当年进公司纯属幸运……hhh….
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>年度总结~</title>
    <link href="http://yoursite.com/2019/01/01/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/01/年度总结/</id>
    <published>2018-12-31T16:17:29.000Z</published>
    <updated>2019-01-01T05:57:12.510Z</updated>
    
    <content type="html"><![CDATA[<p>新的一年已经开始啦~<br>想了一下，当初在2017年计划的事情到现在还是没有完成。MD…………<a id="more"></a><br>今年我的心态好了很多，至少不会没事想着自杀了，今年也学了不少东西，感觉进步还是不少的，感谢公司的大佬和小伙伴们的帮助啦~<br>ESB接口开发，linux服务器基本操作，weblogic 服务器/oracle 数据库/keepalived 等等，至少今年让我感觉收获还是不少的。<br>但是原本在2017年计划的学习SpringBoot  到了2019年还是没有学完，而且没咋学…每次下定决心 但是好像都没有持续好久….<br>回顾一下去年的几次比较重要的事情吧~<br>18年2月份，过完年回潍坊出差，第一次见到大领导(貌似是个总裁还是啥的….)，年龄不小了…是个当爷爷的岁数了，是个台湾的企业家~我有幸和他说上话~  但是他一口流利的英语 差点没把我整自闭….<br>其实也和自闭差不多了 当时….他还对我说了一个很伤人的话，”不是什么阿猫阿狗都可以来的.”…那时候有2个想法，一个是学好英语，第二个是考研。<br>至始至终，我都很羡慕学习好的人，也很羡慕能够继续上学的人，只不过我现在已经不后悔没能继续上学了，没错！ 我放弃了那个考研的计划，学英语的计划最多能算延期~ 2333<br>我记得那会我跟我妈妈说，我自己尝试了，失败了 我不会怪任何人，但是你不许我做，那么一切的一切我都会怪在你的头上~<br>后来我妈妈也支持了我的考研计划~  当时还挺有梦想的，想考计算机系的AI，后来被自己的胆怯击倒了，一是怕自己考不上 怕这怕那的，二是觉得那个要求的线太高了，总而言之就是找各种理由给自己开脱，后来就慢慢放弃了，不过还是坚持了一段时间的，大概一个月吧….</p><p>2018年4月，我离开潍坊项目组来到泸州项目组~这个项目组教会了我太多东西了，也改变了我很多~比如我学会了很多ESB的东西，顺便把自己之前没整明白的也整明白了，感谢张哥和姜哥啦~<br>生活中的话~7月份除了我所有的项目组成员都离开了~ 我那是第一次自己独立做所有的事情，工作也好，生活也罢，那大概是我真正独立的第一次吧~ 什么都要自己做，而且自己还挺蠢的，经常做错事情。<br>人们总说，独立是一个好事情，但是没人告诉我们独立的坏处~  当你领悟到这个坏处之后，你也独立的差不多了…真特喵的是个坏的循环..<br>人呐~ 总是习惯性用自己的行为去约束别人，比如这个事情我可以自己做，我就不希望别人来找我帮忙~<br>我记得微博上有一句话我特别喜欢，”我不喜欢麻烦别人 这句话的潜台词是我也不喜欢被别人麻烦，望周知。”<br>说说别的~  我之前选择这一行的原因是因为我觉得可以靠技术吃饭~  我一直以为技术牛就可以为所欲为~  后来发现还是需要和人好好沟通的~所以我现在…有点甲方舔狗的味道吧(笑)，也不算虚伪，有点半开玩笑的话，毕竟甲方是个和我差不多大的小姐姐~</p><p>心态好了之后，写东西也更加的凌乱了….完全没有啥头绪~ 果然还是应该列个提纲的……<br>说说家里吧，今年家里还算是比较顺利，家人没生啥病，除了我找对象这个事情，其他的还好~年底的时候开始给家里寄钱，虽然是准备买电脑，但是至少还是存钱了…..但是真的快被饿死啦~~~花呗要顶不住了！！！<br>可是我还是觉得是因为大家都有钱了，我到现在还是认为，人有钱了确实是会和大家比较友好的相处，我姐家也罢~  我哥哥家也好~  说白了现在联系比较多的也就和我哥哥了，一是当年他天天带我去网吧~  一直到大三那年在他家玩了一整个寒假，包吃包住~ 有点不好意思吧~ 所以给他也好，给我姐姐也罢，都买了点礼物~<br>其实我也差不多明白，我在家这么多年可以为所欲为，或者说回家有人善意的对待，有很重要的原因就是我姐姐有钱，不可否认~  我在老家可以混饭吃多亏了我姐姐，如果我家很贫穷，估计大家也不会那么热情的招待我把…..<br>今年我也终于有幸成为了别人家的孩子~赚的钱不算多，但是还行吧，没让家里人操心，听说我姐姐还偶尔喝别人炫耀我呢~咋说呢…..  这工资…..还好吧…..<br>还是不要探讨人性了，我这应该也算是有偏见吧。。。。但是我觉得这也是家庭带来的影响吧…..我虽然变得友善了，但是我觉得过去的有些事情还是无法原谅，无所谓啦~ 反正也见不着面了。</p><p>期间学习了几次，买了不少书，但是都没咋看，最近算是坚持下来了一点点吧，计划很多~但是又没有具体的计划~  而且学时间长就开始厌烦，不是很有耐心，慢慢来吧~<br>距离第一个计划只剩下半年了，应该可以实现吧….第二个计划我给自己定的时间是五年…..也说不准将来的5年我能否坚持下来<br>之前有个习惯，就是一有计划就马上和别人说，都来也都不了了之了…..所以 现在不说了吧….5年后见…希望自己可以加油~<br>写的好乱……..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的一年已经开始啦~&lt;br&gt;想了一下，当初在2017年计划的事情到现在还是没有完成。MD…………
    
    </summary>
    
      <category term="闲谈" scheme="http://yoursite.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="年度总结~" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(9)深入SpringMVC开发-2</title>
    <link href="http://yoursite.com/2018/12/31/SpringBoot-9-%E6%B7%B1%E5%85%A5SpringMVC%E5%BC%80%E5%8F%91-2/"/>
    <id>http://yoursite.com/2018/12/31/SpringBoot-9-深入SpringMVC开发-2/</id>
    <published>2018-12-31T04:53:16.000Z</published>
    <updated>2018-12-31T09:10:25.009Z</updated>
    
    <content type="html"><![CDATA[<p>上次说到可以使用@RequestBody等等一些注解来实现获取参数，包括自动封装成对应对象等等，当然，获取参数还有可能更复杂，比如和第三方系统合作，采用密文传输等等，这样的话其定义的参数规则SpringMVC就无法支持了，这时候就需要使用到自定义参数转换规则了。<br>在之前的SpringMVC中，我们可以使用注解 甚至连注解都不使用就可以获取参数了。这是因为SpringMVC提供的处理器会优先使用一套规则来实现参数的转换，而大部分情况下，开发者是不需要知道这些规则的。<br>但是自定义就需要知道这些规则了….</p><p>Http的请求包含请求头(Header)、请求体(Body)、URL和参数等内容，服务器还包含其上下文环境和客户端交互会话(Session)机制，这里的消息转换是指请求体的转换，接下来说说SpringMVC如何从Http请求中获取参数的….<a id="more"></a></p><h2 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h2><p>当一个请求到来之后，在处理器处理的过程中，会优先通过上下文环境和Http请求来获取参数，如果是简易的参数类型他就会使用简单的转换器进行转换，而这些简单的转换器是SpringMVC封装好了的。但是如果是对Http请求体(Body)，它就会调用HttpMessageConverter接口的方法对请求体信息进行转换，首先是判断能否对请求体进行转换，如果可以就将其转换成Java类型。</p><h3 id="HttpMessageConverter接口源码"><a href="#HttpMessageConverter接口源码" class="headerlink" title="HttpMessageConverter接口源码"></a>HttpMessageConverter接口源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.http.converter;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.HttpInputMessage;</span><br><span class="line">import org.springframework.http.HttpOutputMessage;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否可读，其中Clazz为Java类型，mediaType为Http请求类型</span><br><span class="line"> */</span><br><span class="line">boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断clzz能否转换成mediaType媒体类型，其中Clazz为Java类型，mediaType为Http请求类型</span><br><span class="line"> */</span><br><span class="line">boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取可支持的媒体类型列表</span><br><span class="line"> */</span><br><span class="line">List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当canRead验证通过后，读取Http请求信息</span><br><span class="line"> */</span><br><span class="line">T <span class="built_in">read</span>(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span><br><span class="line">throws IOException, HttpMessageNotReadableException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当canWrite方法验证通过后，写入响应</span><br><span class="line"> */</span><br><span class="line">void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)</span><br><span class="line">throws IOException, HttpMessageNotWritableException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里优先讨论canRead和Read方法，当代码控制器方法中的参数标注了@RequestBody注解之后，处理器会采用请求体的内容进行参数转换，而前端传过来的是Json格式，所以这里首先它会调用canRead方法来确认请求体是否可读，然后再调用read方法，将前端提交的用户Json类型请求体转换成控制器User类型参数，这样控制器就可以得到参数了(代码在上一节使用注解获取参数里面…)。</p><p>上述只是将请求体转换 成为Java对象，接下来说说其他的参数类型，比如性别吧，Sex  前端传入男女、而后台传的是枚举类型(最简单的比如男对1 女对2)，这时候我们就需要自定义参数转过程了、</p><h3 id="处理器转换参数过程"><a href="#处理器转换参数过程" class="headerlink" title="处理器转换参数过程"></a>处理器转换参数过程</h3><p>在SpringMVC中，是通过WebDataBinder机制来获取参数的，它主要是解析Http请求的上下文，然后在控制器的调用之前转换参数并提供验证功能，为调用控制器方法做准备。处理器会从Http请求中读取数据，然后通过Converter(基本类型转换器)、Fomatter(时间格式等转换器)、GenericConverter(字符串变数组转换器)这3个接口来进行各种参数转换，这三个接口采用了注册机的机制，在默认情况下SpringMVC已经在注册机里面注册了大量的转换器，这也就是我们在前端传值String 类型，而我们在控制层得到Long类型参数的原因。</p><p>同样的，当需要自定义转换规则时，只需要再注册机上面注册自己的转换器就可以了。</p><p>在SpringBoot中，其提供了一个特殊的机制来管理这些转换器，那就是SpringBoot的自动配置类WebMvcAutoConfiguration,还定义了一个内部类WebMvcAutoConfigurationAdapter,源代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//注册各种转换器，registry 实际为DefaultFormattingConversionService对象</span><br><span class="line">@Override</span><br><span class="line">public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">            //遍历IOC容器，找到Converter类型的Bean注册到服务类中</span><br><span class="line"><span class="keyword">for</span> (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;</span><br><span class="line">registry.addConverter(converter);</span><br><span class="line">&#125;</span><br><span class="line">            //遍历IOC容器，找到GenericConverter类型的Bean注册到服务中</span><br><span class="line"><span class="keyword">for</span> (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;</span><br><span class="line">registry.addConverter(converter);</span><br><span class="line">&#125;</span><br><span class="line">            //遍历IOC容器，找到Formatter类型的Bean注册到服务中</span><br><span class="line"><span class="keyword">for</span> (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;</span><br><span class="line">registry.addFormatter(formatter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在SpringBoot初始化中，会将对应用户自定义的上述三种接口的实现类所创建的Spring Bean自动注册到DefaultFormattingConversionService对象中。</p><p>说了那么多，来说说实际在SpringBoot中，如何自定义吧。</p><h2 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h2><h3 id="一对一转换器-Converter"><a href="#一对一转换器-Converter" class="headerlink" title="一对一转换器(Converter)"></a>一对一转换器(Converter)</h3><p>Converter是一对一的转换器，也就是从一种类型转换到另外一种类型，常见的比如说String 转Integer等等<br>源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Converter&lt;S, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 转换方法  S代表原类型，T代表目标类型</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">T convert(S <span class="built_in">source</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们存在这么一个需求，前端传的是一个字符串，格式为”name-age”这种，但是我们后台需要的是一个Student对象，这时候就可以自定义转换格式了。</p><h4 id="转换类"><a href="#转换类" class="headerlink" title="转换类"></a>转换类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.converter;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.convert.converter.Converter;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.Student;</span><br><span class="line">@Component</span><br><span class="line">public class StringToStudentConverter implements Converter&lt;String, Student&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Student convert(String str) &#123;</span><br><span class="line">String[] studentStr = str.split(<span class="string">"-"</span>);</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setName(studentStr[0]);</span><br><span class="line">student.setAge(studentStr[1]);</span><br><span class="line"><span class="built_in">return</span> student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@GetMapping(value=<span class="string">"/conver.do"</span>,produces=<span class="string">"application/json;chaset=utf-8"</span>)</span><br><span class="line">public Student ConverStudent(Student student) &#123;</span><br><span class="line">System.out.println(student);</span><br><span class="line"><span class="built_in">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 启动项目后执行<a href="http://localhost:8080/student/conver.do?student=%E5%BC%A0%E4%B8%89-18" target="_blank" rel="noopener">http://localhost:8080/student/conver.do?student=%E5%BC%A0%E4%B8%89-18</a><br> (第一个是张三)</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/images/SpringBoot/SpringBoot9/sp9-1.png"></p><h3 id="GenericConverter集合和数组转换"><a href="#GenericConverter集合和数组转换" class="headerlink" title="GenericConverter集合和数组转换"></a>GenericConverter集合和数组转换</h3><p>GenericConverter是数组转换器，因为SpringMVC自身提供了一些数组转换器，所以需要自定义的并不多。<br>假设需要同时新增多个学生，这样便需要传递一个学生列表(List<student>)给控制器，此时SpringMVC会使用StringToCollectionConverter转换，这个类实现了GenericConverter接口，并且是SpringMVC内部已经注册号了的数组转换器，它首先将字符串用逗号分隔成一个个的子字符串，然后通过原泛型为String,目标泛型为Student类，找到对应的Converter进行转换，这里会使用之前写过的转换类。</student></p><p>根据这样的场景，可以使用以下代码进行测试</p><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试使用集合传递多个用户</span><br><span class="line"> * @param students</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@ResponseBody</span><br><span class="line">@GetMapping(value=<span class="string">"/converToList.do"</span>,produces=<span class="string">"application/json;chaset=utf-8"</span>)</span><br><span class="line">public List&lt;Student&gt; list(@RequestParam(value=<span class="string">"students"</span> ,required=<span class="literal">true</span>) List&lt;Student&gt; students)&#123;</span><br><span class="line"><span class="built_in">return</span> students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述要注意的地方就是如果你前端传递集合的时候，在集合的位置需要加上@RequestParam(value=”students” ,required=true)  这个，不加的话会报错<br>java.lang.NoSuchMethodException: java.util.List.<init>()<br>具体原因未知…..这里先提供一个解决办法</init></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>地址栏输入<a href="http://localhost:8080/student/converToList.do?students=zhangsan-1,lisi-2,wangwu-3" target="_blank" rel="noopener">http://localhost:8080/student/converToList.do?students=zhangsan-1,lisi-2,wangwu-3</a></p><p>结果如下<br><img src="/images/SpringBoot/SpringBoot9/sp9-2.png"></p><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><p>之前说过，处理器逻辑中，参数转换之后，就是数据验证了。因此SpringMVC提供了验证参数的机制，一方面，它支持JSR-303注解规范(SpringBoot默认引入的是Hibernate Validator机制)，另一方面，因为业务会比较复杂，所以需要自定义验证规则</p><h3 id="JSR-303验证"><a href="#JSR-303验证" class="headerlink" title="JSR-303验证"></a>JSR-303验证</h3><p>JSR-303验证主要是通过注解的方式进行的。下面定义一个需要验证的POJO，并根据需求使用相应注解</p><h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.Email;</span><br><span class="line">import javax.validation.constraints.Future;</span><br><span class="line">import javax.validation.constraints.Max;</span><br><span class="line">import javax.validation.constraints.Min;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line">import org.hibernate.validator.constraints.Range;</span><br><span class="line"></span><br><span class="line">public class ValidatorPojo &#123;</span><br><span class="line">@NotNull(message=<span class="string">"id不能为空"</span>)</span><br><span class="line">private Integer id;</span><br><span class="line"></span><br><span class="line">@Future(message=<span class="string">"需要一个将来的日期"</span>)</span><br><span class="line">@NotNull(message=<span class="string">"日期不能为空"</span>)</span><br><span class="line">private Date date;</span><br><span class="line"></span><br><span class="line">@Min(value=0,message=<span class="string">"最小值为0"</span>)</span><br><span class="line">@Max(value=100,message=<span class="string">"最大值为100"</span>)</span><br><span class="line">private Integer score;</span><br><span class="line"></span><br><span class="line">@Range(min=1,max=888,message=<span class="string">"范围为1-888"</span>)</span><br><span class="line">private Integer range;</span><br><span class="line"></span><br><span class="line">@Email(message=<span class="string">"邮箱格式错误"</span>)</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line">@Size(min=5,max=10,message=<span class="string">"字符串 长度应为5-10之间"</span>)</span><br><span class="line">private String str;</span><br><span class="line"></span><br><span class="line">/**省略get/<span class="built_in">set</span>以及构造函数**/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value=<span class="string">"/valid"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>)</span><br><span class="line">public Map&lt;String , Object&gt; validate(@Valid @RequestBody ValidatorPojo vp ,Errors errors)&#123;</span><br><span class="line">Map&lt;String , Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">//获取错误列表</span><br><span class="line">List&lt;ObjectError&gt; oes = errors.getAllErrors();</span><br><span class="line"><span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line">String key = null;</span><br><span class="line">String msg = null;</span><br><span class="line">//字段错误</span><br><span class="line"><span class="keyword">if</span>(oe instanceof FieldError) &#123;</span><br><span class="line">FieldError fe = (FieldError) oe;</span><br><span class="line">key = fe.getField();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">key = oe.getObjectName();</span><br><span class="line">&#125;</span><br><span class="line">msg = oe.getDefaultMessage();</span><br><span class="line">map.put(key, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用@RequestBody代表接收一个Json参数，@Valid注解表示启动验证机制，这样Spring就会启用JSR-303机制进行验证。它会自动将最后的验证结果放入Errors对象中，这样就可以从中得到相关验证后的信息</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>这里依旧是懒散的使用SOAPUI测试…..<br><img src="/images/SpringBoot/SpringBoot9/sp9-3.png"></p><h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>除了一些常规的验证，在面对一些非常规验证的时候，比如比较总金额是否等于单价*数量  在这样类似的情况下，我们就需要使用自定义验证了。</p><p>在Spring中，Spring还提供了自己的验证机制，在参数转换的时候，我们可以看到SpringMVC中，存在WebDataBinder机制进行管理，在默认的情况下Spring会自动根据上下文通过注册了的转换器转换出控制器所需要的参数，在WebDataBinder中除了可以注册转换器之外，还可以注册验证器(Validator)</p><p>在Spring控制器中，它还允许使用注解@InitBinder，这个注解是允许在进入控制器的方法之前修改WebDataBinder机制，下面就在验证机制的场景下演示，在此之前，先认识一下SpringMVC的验证机制，其中定义了一个Validator接口，此接口源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.validation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface Validator &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判定当前验证器是否支持Class类型验证</span><br><span class="line"> * @param clazz pojo类型</span><br><span class="line"> * @<span class="built_in">return</span> 当前验证器是否支持POJO验证</span><br><span class="line"> */</span><br><span class="line">boolean supports(Class&lt;?&gt; clazz);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果supports 返回<span class="literal">true</span>，则这个方法执行验证逻辑</span><br><span class="line"> * @param target 被验证的POJO对象</span><br><span class="line"> * @param errors 错误对象</span><br><span class="line"> */</span><br><span class="line">void validate(Object target, Errors errors);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自定义学生验证器"><a href="#自定义学生验证器" class="headerlink" title="自定义学生验证器"></a>自定义学生验证器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.validator;</span><br><span class="line"></span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.util.StringUtils;</span><br><span class="line">import com.wangshun.leaning.entity.Student;</span><br><span class="line"></span><br><span class="line">public class StudentValidator implements Validator&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean supports(Class&lt;?&gt; clazz) &#123;</span><br><span class="line"><span class="built_in">return</span> clazz.equals(Student.class);</span><br><span class="line">&#125;</span><br><span class="line">//验证逻辑</span><br><span class="line">@Override</span><br><span class="line">public void validate(Object target, Errors errors) &#123;</span><br><span class="line"><span class="keyword">if</span>(target==null) &#123;</span><br><span class="line">errors.rejectValue(<span class="string">""</span>, null,<span class="string">"用户不能为空"</span>);</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student student = (Student) target;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(student.getName())) &#123;</span><br><span class="line">errors.rejectValue(<span class="string">"name"</span>, null,<span class="string">"用户名不能为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，上面的errors.rejectValue方法中的第一个参数，上面的是name  这个是要跟你的实体类的属性名称对应的，否则是会报错找不到属性的。</p><p>有了这个验证器之后，Spring还是不能自动启动它，正如前面说的那样，@InitBinder注解可以实现在进入控制器方法之前更改WebDataBinder机制<br>所以在Controller 类中添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">binder.setValidator(new StudentValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/images/SpringBoot/SpringBoot9/sp9-4.png"></p><p>这里留一个坑，如果自定义验证和注解验证同时存在，那么执行的先后顺序 是怎样的呢(应该不会只执行一个吧……)</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次说到可以使用@RequestBody等等一些注解来实现获取参数，包括自动封装成对应对象等等，当然，获取参数还有可能更复杂，比如和第三方系统合作，采用密文传输等等，这样的话其定义的参数规则SpringMVC就无法支持了，这时候就需要使用到自定义参数转换规则了。&lt;br&gt;在之前的SpringMVC中，我们可以使用注解 甚至连注解都不使用就可以获取参数了。这是因为SpringMVC提供的处理器会优先使用一套规则来实现参数的转换，而大部分情况下，开发者是不需要知道这些规则的。&lt;br&gt;但是自定义就需要知道这些规则了….&lt;/p&gt;
&lt;p&gt;Http的请求包含请求头(Header)、请求体(Body)、URL和参数等内容，服务器还包含其上下文环境和客户端交互会话(Session)机制，这里的消息转换是指请求体的转换，接下来说说SpringMVC如何从Http请求中获取参数的….
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(8)深入SpringMVC开发-1</title>
    <link href="http://yoursite.com/2018/12/28/SpringBoot-8-%E6%B7%B1%E5%85%A5SpringMVC%E5%BC%80%E5%8F%91-1/"/>
    <id>http://yoursite.com/2018/12/28/SpringBoot-8-深入SpringMVC开发-1/</id>
    <published>2018-12-28T12:10:21.000Z</published>
    <updated>2018-12-28T15:17:18.227Z</updated>
    
    <content type="html"><![CDATA[<p>上次说到SpringMVC的大致流程，这次就主要来深入的说说SpringMVC的开发细节，以及在SpringBoot中的应用</p><h2 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h2><p>如果Web工程使用了SpringMVC,那么在启动时就会将注解@RequestMapping中的信息存储到处理器映射(HandlerMapping)机制中去，然后当我们每次请求的时候，通过DispatcherServlet与HandlerMapping中的url进行匹配，找到对应的处理器(其包含控制器的逻辑)并将处理器和拦截器保存到HandlerExecutionChain对象中，并返回给DispatcherServlet。</p><p>也就是说，HandlerMapping 的主要任务是将求情定位到具体的处理器上面…..<a id="more"></a></p><h3 id="RequestMapping源码分析"><a href="#RequestMapping源码分析" class="headerlink" title="@RequestMapping源码分析"></a>@RequestMapping源码分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Mapping</span><br><span class="line">public @interface RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置请求映射名称</span><br><span class="line"> */</span><br><span class="line">String name() default <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过路径映射</span><br><span class="line"> */</span><br><span class="line">@AliasFor(<span class="string">"path"</span>)</span><br><span class="line">String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过路径映射回path配置项</span><br><span class="line"> */</span><br><span class="line">@AliasFor(<span class="string">"value"</span>)</span><br><span class="line">String[] path() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 限定只响应http请求类型，如get/post/head/options/put等等，默认可以响应所有的请求类型</span><br><span class="line"> */</span><br><span class="line">RequestMethod[] method() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 当存在http参数时才响应请求</span><br><span class="line"> */</span><br><span class="line">String[] params() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 限定header头存在对应参数时才响应</span><br><span class="line"> */</span><br><span class="line">String[] headers() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 限制http请求体的提交类型，比如application/json</span><br><span class="line"> */</span><br><span class="line">String[] consumes() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 限定返回内容类型，仅当http请求头中的Accept类型中包含该指定类型才返回</span><br><span class="line"> */</span><br><span class="line">String[] produces() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是RequestMapping  源码的内容，可以通过path  或者value  来设置请求的url，从而让对应的请求映射到控制器或者其方法上面，当然，配置项value 和path  也可以通过正则表达式来让方法匹配多个请求。但是如果不是很有必要，尽量不要这么做。</p><p>method属性就是指定请求的方法，比如post  还有get。<br>当然，为了方便开发，在Spring4.3以后，配置项中又新增了几个注解，比如像@PostMapping等等。这种注解也就是简化了配置而已，就比如上面那个就不需要再配置method = “post” 了。</p><h2 id="获取控制参数"><a href="#获取控制参数" class="headerlink" title="获取控制参数"></a>获取控制参数</h2><p>这里也就是我们经常的在Controller 里面使用的几种获取页面传过来的值的几种方法。</p><p>接下来采用代码加截图的形式来学习一下参数的获取</p><h3 id="在无注解下获取参数"><a href="#在无注解下获取参数" class="headerlink" title="在无注解下获取参数"></a>在无注解下获取参数</h3><p>在无注解的情况下获取参数，一般是要求参数名称和http请求参数名称一致。</p><h4 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a>Controller代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.Student;</span><br><span class="line">import com.wangshun.leaning.service.IStudentService;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/student"</span>)</span><br><span class="line">public class StudentController implements WebMvcConfigurer&#123;</span><br><span class="line">@Autowired</span><br><span class="line">IStudentService batchStudent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 展示学生详情</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@GetMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public ModelAndView insert(Long id) &#123;</span><br><span class="line">//访问模型获取数据</span><br><span class="line">//Student student = batchStudent.get(id);</span><br><span class="line">//模型和试图</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">//定义模型视图</span><br><span class="line">mv.setViewName(<span class="string">"student/details"</span>);</span><br><span class="line">//加入数据模型</span><br><span class="line">//mv.addObject(<span class="string">"student"</span>,student);</span><br><span class="line">//返回模型和视图</span><br><span class="line"><span class="built_in">return</span> mv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debuge 模式启动项目，在浏览器地址栏输入：<a href="http://localhost:8080/student/details.do?id=1" target="_blank" rel="noopener">http://localhost:8080/student/details.do?id=1</a><br>进入debuge，如下图：<br><img src="/images/SpringBoot/SpringBoot8/sp8-1.png"></p><h3 id="使用-RequestParam-获取参数"><a href="#使用-RequestParam-获取参数" class="headerlink" title="使用@RequestParam 获取参数"></a>使用@RequestParam 获取参数</h3><p>在目前前后端分离的大趋势下，前端命名的规范可能和后端不一致，这时需要把前端的参数和后端的对应起来，那么就可以使用@RequestParam 来确定前后端参数名的映射关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 采用@RequestParam注解获取参数</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@GetMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public String insert(@RequestParam(<span class="string">"test_id"</span>)Long id) &#123;</span><br><span class="line">System.out.println(id);</span><br><span class="line"><span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入：<a href="http://localhost:8080/student/details.do?test_id=1" target="_blank" rel="noopener">http://localhost:8080/student/details.do?test_id=1</a><br>测试效果图如下：<br><img src="/images/SpringBoot/SpringBoot8/sp8-2.png"></p><h3 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 传递数组</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@GetMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public String insert(Integer[] intArr,String [] strArr) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器：<a href="http://localhost:8080/student/details.do?intArr=1,2,3&amp;strArr=str1,str2,str3" target="_blank" rel="noopener">http://localhost:8080/student/details.do?intArr=1,2,3&amp;strArr=str1,str2,str3</a><br>传递数组参数时，只要每个元素通过逗号分隔即可，而且string类型不需要加引号</p><h3 id="传递json"><a href="#传递json" class="headerlink" title="传递json"></a>传递json</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用@requestBody传递Json</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PostMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public String insert(@RequestBody Student student) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用@RequestBody注解来传递Json<br>这个注解的意思也就是接收Json 的参数  并将json中和Student实体类中属性相同的部分  赋值给Student 对象。</p><p>ps:由于本人较懒..所以干脆使用soapUI测试了…懒得再去写一个form表单…..(手动滑稽~)<br>下面是测试方法 以及测试结果的截图：<br>soapUI：<br><img src="/images/SpringBoot/SpringBoot8/sp8-3.png"></p><p>这里有两点需要注意一下，之前在调试的时候报错<br> Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Invalid UTF-8 middle byte 0xd0; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Invalid UTF-8 middle byte 0xd0</p><p> 这个在SoapUI中设置一下请求编码为UTF-8即可。</p><p> 第二点就是json中的key需要和实体类中的属性名一致~</p><p> 下面是测试结果图~<br> <img src="/images/SpringBoot/SpringBoot8/sp8-4.jpg"></p><h3 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h3><p>在一些Rest风格的网站中，这时候的参数需要通过url进行传递，比如获取用户的接口就应该是：/user/1<br>这样就变成了获取用户id 为1的接口<br>下面通过例子来演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用占位符+@PathVariable注解获取参数</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@GetMapping(<span class="string">"/details.do/&#123;id&#125;"</span>)</span><br><span class="line">public String insert(@PathVariable(<span class="string">"id"</span>) Long id) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问地址<a href="http://localhost:8080/student/details.do/1" target="_blank" rel="noopener">http://localhost:8080/student/details.do/1</a><br>测试结果：<br><img src="/images/SpringBoot/SpringBoot8/sp8-5.png"></p><p>首先是在@GetMapping 中指定url  以及占位符<br>然后在请求参数中 添加@PathVariable  注解 并指定参数名称，这样这里的参数就可以和url中的对应上了。</p><h3 id="获取格式化参数"><a href="#获取格式化参数" class="headerlink" title="获取格式化参数"></a>获取格式化参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用日期转换注解@DateTimeFormat</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PostMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public String insert(@DateTimeFormat(iso = ISO.DATE) Date date) &#123;</span><br><span class="line">System.out.println(date.toString());</span><br><span class="line"><span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>soapUI测试：<br><img src="/images/SpringBoot/SpringBoot8/sp8-6.png"></p><p>测试结果图：<br><img src="/images/SpringBoot/SpringBoot8/sp8-7.png"></p><p>这样 我们传入的日期就按照指定格式进行转换了。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次说到SpringMVC的大致流程，这次就主要来深入的说说SpringMVC的开发细节，以及在SpringBoot中的应用&lt;/p&gt;
&lt;h2 id=&quot;处理器映射&quot;&gt;&lt;a href=&quot;#处理器映射&quot; class=&quot;headerlink&quot; title=&quot;处理器映射&quot;&gt;&lt;/a&gt;处理器映射&lt;/h2&gt;&lt;p&gt;如果Web工程使用了SpringMVC,那么在启动时就会将注解@RequestMapping中的信息存储到处理器映射(HandlerMapping)机制中去，然后当我们每次请求的时候，通过DispatcherServlet与HandlerMapping中的url进行匹配，找到对应的处理器(其包含控制器的逻辑)并将处理器和拦截器保存到HandlerExecutionChain对象中，并返回给DispatcherServlet。&lt;/p&gt;
&lt;p&gt;也就是说，HandlerMapping 的主要任务是将求情定位到具体的处理器上面…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(7)初识SpringMVC</title>
    <link href="http://yoursite.com/2018/12/26/SpringBoot-7-%E5%88%9D%E8%AF%86SpringMVC/"/>
    <id>http://yoursite.com/2018/12/26/SpringBoot-7-初识SpringMVC/</id>
    <published>2018-12-26T11:13:55.000Z</published>
    <updated>2018-12-26T13:55:05.247Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC 的定位是一个比较松散的组合，展示给用户的视图(View),控制器返回的数据模型(Model),定位视图的视图解析器(ViewResolver)和处理适配器(HandlerAdapter)等内容都是独立的。换句话说，通过SpringMVC很容易把后台的数据转换成各种类型的数据，以满足互联网多样化的需求，比如目前用的最多的JSON格式，也可以转换成PDF、Excel和XML，再加上SpringMVC是基于Spring基础框架派生出来的Web框架，所以它可以十分方便的就整合到Spring框架中…..<a id="more"></a></p><h2 id="SpringMVC的框架设计"><a href="#SpringMVC的框架设计" class="headerlink" title="SpringMVC的框架设计"></a>SpringMVC的框架设计</h2><p>SpringMVC ，也就是我们常说的三层架构(controller、Service、dao),下面用一张图来简单说一下SpringMVC的框架设计<br><img src="/images/SpringBoot/SpringBoot7/sp7-1.png"></p><p>简单点来说 就是发起请求–&gt;controller–&gt;service–&gt;Redis–&gt;dao–&gt;数据库–&gt;dao–&gt;service–&gt;controller–&gt;view<br>这里如果缓存中存在数据就不会访问dao层进而访问数据库了</p><h2 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h2><p>尽管在SpringBoot的开发中，我们可以很快速的通过配置去实现SpringMVC的开发，但是为了解决实际问题，我们还是很有必要去了解一下SpringMVC中运行流程和组件，否则很难理解SpringBoot自动为我们生成了啥，配置了什么，这有什么用。<br>流程和组件是SpriingMVC的核心，SpringMVC的流程是围绕DispatcherServlet而工作的，所以在SpringMVC中DispatcherServlet就是最最重要的内容。在其基础上，还有其他的组件，掌握流程和组件就是SpringMVC开发的基础。</p><h3 id="SpringMVC全过程图"><a href="#SpringMVC全过程图" class="headerlink" title="SpringMVC全过程图"></a>SpringMVC全过程图</h3><p><img src="/images/SpringBoot/SpringBoot7/sp7-2.png"></p><p><strong>注意:</strong> SpringMVC的流程图中，并非每次都需要走完全过程，比如说我们常用的一个注解@ResponseBody<br>这个注解的表演意思也就是把返回的内容不作为页面进行返回，否则你默认返回的index字符串的话，它默认就会返回一个index.html</p><h3 id="SpringMVC初始化"><a href="#SpringMVC初始化" class="headerlink" title="SpringMVC初始化"></a>SpringMVC初始化</h3><p>首先，在Web服务器的启动过程中，如果在SpringBoot机制下启动SpringMVC，它就开始初始化一些重要组件，比如DispactherServelt、HandlerAdapter的实现类RequestMappingHandlerAdapter等组件对象。</p><p>关于这些组件的初始化，我们可以看到spring-webmvc-xxx.jar包中的属性文件DispatcherServlet.properties,它定义的对象都是在SprngMVC开始时就初始化，并且存放在Spring IoC容器中，其源代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default implementation classes for DispatcherServlet's strategy interfaces.</span></span><br><span class="line"><span class="comment"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span></span><br><span class="line"><span class="comment"># Not meant to be customized by application developers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#国际化解析器</span></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"><span class="comment">#主题解析器</span></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"><span class="comment">#HandlerMapping实例</span></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span><br><span class="line"><span class="comment">#处理器适配器</span></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><br><span class="line"><span class="comment">#处理器异常解析器</span></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"><span class="comment">#策略视图解析器，当你没有返回视图逻辑名称的时候，通过它可以生成默认的视图名称</span></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"><span class="comment">#视图解析器</span></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"><span class="comment">#FlashMap管理器。不常用.......</span></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure></p><p>以上的这些组件，会在SpringMVC初始化的时候进行初始化，这也是为什么我们不需要进行很多配置就可以开发SpringMVC程序，尤其是在SpringBoot中，更是如此，我们可以通过SpringBoot中的配置来定制这些组件的初始化。接来下通过代码我们来聊聊它的运行流程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/student"</span>)</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IStudentService batchStudent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 展示学生详情</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@GetMapping(<span class="string">"/details.do"</span>)</span><br><span class="line">public ModelAndView insert(Long id) &#123;</span><br><span class="line">//访问模型获取数据</span><br><span class="line">Student student = batchStudent.get(id);</span><br><span class="line">//模型和试图</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">//定义模型视图</span><br><span class="line">mv.setViewName(<span class="string">"student/details"</span>);</span><br><span class="line">//加入数据模型</span><br><span class="line">mv.addObject(<span class="string">"student"</span>,student);</span><br><span class="line">//返回模型和视图</span><br><span class="line"><span class="built_in">return</span> mv;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Controller 表示这是一个控制器，@RequestMapping代表请求路径和控制器(或者其方法)的映射关系，它会在Web服务器启动SpringMVC时，就被扫描到HandlerMapping的机制中存储，之后用户在法器请求被DispatcherServlet拦截后，通过URI或者其他条件，通过HandlerMapping机制就能找到对应的控制器(或者方法)进行相应，只是通过HandlerMapping返回的是一个HandlerExecutionChain对象，这个对象的源码如下：<br>ps:这也就说通了为啥新增一个接口必须要重启程序才能生效了~啦啦啦~<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line">//日志</span><br><span class="line">private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line">//处理器</span><br><span class="line">private final Object handler;</span><br><span class="line">//拦截器数组</span><br><span class="line">@Nullable</span><br><span class="line">private HandlerInterceptor[] interceptors;</span><br><span class="line">//拦截器列表</span><br><span class="line">@Nullable</span><br><span class="line">private List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">//拦截器当前下标</span><br><span class="line">private int interceptorIndex = -1;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在HandlerExecutionChain对象中，有一个处理器(handler),这里的处理器是对于Controller的包装，因为我们的控制器可能存在参数，那么处理器就会读取Http中和上下文相关的参数，并且传入给控制器中的方法。而且在控制器执行完成返回后，处理器又可以根据配置信息对控制器的返回结果进行处理。从这段话可以看出，处理器包含了控制器方法的逻辑以及处理器的拦截器(interceptor),这样就可以通过拦截处理器进一步增强处理器的功能。</p><p>在处理器调用控制器时，它首先通过模型层获取数据，再放入数据模型中，最后将返回数据和视图的对象，这样就走到了视图解析器(ViewResolver)，去解析视图逻辑名称了。</p><p>在DispatcherServlet.properties中，我们看到了视图解析器的自动初始化，为了定制InternalResourceViewResolver初始化，我们可在配置文件中添加以下属性(也就是指明页面路径以及默认后缀)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置前缀</span></span><br><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line"><span class="comment">#指定后缀</span></span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure></p><p>这样的设置之后，上面的controller 返回的内容，就会定位到/WEB-INF/jsp/student/details.jsp<br>不过现在基本前后端分离…所以这种用的不多了….</p><h2 id="定制SpringMVC初始化"><a href="#定制SpringMVC初始化" class="headerlink" title="定制SpringMVC初始化"></a>定制SpringMVC初始化</h2><p>正如SpringBoot承诺的那样，它会尽可能的配置Spring，SpringMVC也是如此。但是无论如何都有可能无法满足我们的需求，需要进一步的对SpringMVC进行定制。</p><p>在Servlet3.0的规范中，web.xml不再是一个必须的配置文件。为了适应这个规范，SpringMVC从3.1开始也进行了支持，也就是我们再也不需要基于XML去对环境进行配置。</p><p>为了支持SpringMVC的配置，SpringBoot提供了一个<strong>WebMvcConfigurer</strong>接口，这是一个基于Java8的接口，所以其大部分方法都是defalut类型的，但是它都是空实现，所以我们只需要<strong>实现这个接口，重写需要自定义的方法即可</strong>,它有一个静态内部类<strong><em>WebMvcAutoConfigurationAdapter</em></strong>,通过它SpringBoot就自动配置了MVC的初始化。</p><p>在WebMvcAutoConfigurationAdapter类中，它会自动读取Spring中配置SpringMVC的属性来初始化对应组件，这样便在一定程度上可以实现自定义。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringMVC 的定位是一个比较松散的组合，展示给用户的视图(View),控制器返回的数据模型(Model),定位视图的视图解析器(ViewResolver)和处理适配器(HandlerAdapter)等内容都是独立的。换句话说，通过SpringMVC很容易把后台的数据转换成各种类型的数据，以满足互联网多样化的需求，比如目前用的最多的JSON格式，也可以转换成PDF、Excel和XML，再加上SpringMVC是基于Spring基础框架派生出来的Web框架，所以它可以十分方便的就整合到Spring框架中…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SprongBoot(6)Redis</title>
    <link href="http://yoursite.com/2018/12/24/SprongBoot-6-redis/"/>
    <id>http://yoursite.com/2018/12/24/SprongBoot-6-redis/</id>
    <published>2018-12-24T12:05:50.000Z</published>
    <updated>2018-12-24T16:26:44.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  在如今互联网中，缓存的应用已经很广泛了，它能在互联网中起到加速系统的作用，有两种缓存使用最广泛，那就是Redis和MongoDB，下面就简单来说说Redis<br>  redis是一种运行在内存中的数据库，支持其中数据类型的存储，Redis是一个开源的、使用ANSIC语言编写、遵守BSD协议、支持网络、可基于内存也可以持久化的日志型、键值对数据库，并提供了多种语言API。由于Redis基于内存，所以运行速度很快，大概是关系型数据库的几倍到几十倍，使用Redis来代替关系数据库的查询访问，网站性能将得到很大的提升……<a id="more"></a></p><h2 id="在SpringBoot中使用Redis"><a href="#在SpringBoot中使用Redis" class="headerlink" title="在SpringBoot中使用Redis"></a>在SpringBoot中使用Redis</h2><h3 id="pom文件中引入相关依赖"><a href="#pom文件中引入相关依赖" class="headerlink" title="pom文件中引入相关依赖"></a>pom文件中引入相关依赖</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Redis缓存依赖  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 这里连接redis 一共有两种客户端，一种是引入redis依赖包的时候的默认依赖客户端lettuce，还有一种就是jedis<br> 两种都可以。这里就以默认的为例。</p><h3 id="在SpringBoot中配置Redis"><a href="#在SpringBoot中配置Redis" class="headerlink" title="在SpringBoot中配置Redis"></a>在SpringBoot中配置Redis</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">   host: localhost</span><br><span class="line">   password: password1</span><br><span class="line">   port: 6379</span><br><span class="line">   timeout:</span><br><span class="line">     10000</span><br><span class="line">   database: 0</span><br><span class="line">   lettuce:</span><br><span class="line">     pool:</span><br><span class="line">       max-active: 8</span><br><span class="line">       max-wait:</span><br><span class="line">         -1</span><br><span class="line">       max-idle: 8</span><br><span class="line">       min-idle: 0</span><br></pre></td></tr></table></figure><p> 这里配置了连接池和服务器的属性，用以连接Redis服务器，这样SpringBoot的自动装配机制就会读取这些属性并且自动帮我们生成RedisConnectionFactory、RedisTemplate、StringRedisTemplate等常用redis对象</p><h3 id="安装Redis单机版"><a href="#安装Redis单机版" class="headerlink" title="安装Redis单机版"></a>安装Redis单机版</h3><p>这里可能会有一个疑惑：就是说这个host  和password 怎么填写，这里其实在使用redis之前我们最起码需要在本地搭建一个redis(这里只是做单机redis，并没有做redis集群。)<br>参考地址：<a href="https://jingyan.baidu.com/article/7f766dafa0dae64100e1d052.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/7f766dafa0dae64100e1d052.html</a><br>安装完成就可以了，本地的环境变量的配置可以不做<br>然后我们进入到redis 的安装路径下 打开cmd 输入<br>redis-server.exe redis.windows.conf</p><p>启动的第一次可能会报错：creating server tcp listening socket 127.0.0.1:6379: bind No error(应该是系统默认启动了这个 然后你再启动一次导致的)<br>解决方案如下按顺序输入如下命令就可以连接成功</p><ol><li>redis-cli.exe</li><li>shutdown</li><li>exit</li><li>redis-server.exe redis.windows.conf</li></ol><p>下面是开启成功的截图<br><img src="/images/SpringBoot/SpringBoot6/sp6-1.png"></p><h3 id="设置redis密码"><a href="#设置redis密码" class="headerlink" title="设置redis密码"></a>设置redis密码</h3><p>密码是在redis.windows.conf文件中<br><img src="/images/SpringBoot/SpringBoot6/sp6-2.png"><br>这个位置 这里本来是带#的  去掉之后 后面输入你想设置的密码就可以了。</p><h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cache.annotation.CacheEvict;</span><br><span class="line">import org.springframework.cache.annotation.CachePut;</span><br><span class="line">import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import com.ithwua.dao.IRouteDao;</span><br><span class="line">import com.ithwua.entity.Route;</span><br><span class="line">import com.ithwua.service.IRouteService;</span><br><span class="line">@Service</span><br><span class="line">public class RouteServiceImpl implements IRouteService&#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       IRouteDao routeDao;</span><br><span class="line">       private static final Logger <span class="built_in">log</span> =  LoggerFactory.getLogger(RouteServiceImpl.class);</span><br><span class="line">       @Override</span><br><span class="line">       public List&lt;Route&gt; getAllInfo(String appid) &#123;</span><br><span class="line">             <span class="built_in">return</span> routeDao.getAllAddress(appid);</span><br><span class="line">       &#125;</span><br><span class="line">       /**</span><br><span class="line">        * value值其表示当前方法的返回值是会被缓存在哪个Cache上的，</span><br><span class="line">        * 对应Cache的名称。其可以是一个Cache也可以是多个Cache，</span><br><span class="line">        * 当需要指定多个Cache时其是一个数组 例如：&#123;<span class="string">"cache1"</span>, <span class="string">"cache2"</span>&#125;</span><br><span class="line">        *</span><br><span class="line">        * key值指的是参数的名字，写法：<span class="comment">#参数名,#p参数index(例如:#p0)</span></span><br><span class="line">        */</span><br><span class="line">       @Cacheable(value = <span class="string">"Route"</span>, key = <span class="string">"#appid"</span>)</span><br><span class="line">       @Override</span><br><span class="line">       public Route getInfoByAppid(String appid) &#123;</span><br><span class="line">             log.info(<span class="string">"进入 get 方法"</span>);</span><br><span class="line">             <span class="built_in">return</span> routeDao.getInfoByAppid(appid);</span><br><span class="line">       &#125;</span><br><span class="line">       @CachePut(value=<span class="string">"Route"</span>,key=<span class="string">"#route.appid"</span>)</span><br><span class="line">       @Override</span><br><span class="line">       public int saveOrUpdate(Route route) &#123;</span><br><span class="line">             </span><br><span class="line">             Route infoByAppid = routeDao.getInfoByAppid(route.getAppid());</span><br><span class="line">             <span class="keyword">if</span>(StringUtils.isEmpty(infoByAppid)) &#123;</span><br><span class="line">                    log.info(<span class="string">"进入 SaveOrUpdate 方法"</span>);</span><br><span class="line">                    routeDao.saveOrUpdate(route);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">return</span> 0;</span><br><span class="line">       &#125;</span><br><span class="line">       @CacheEvict(value=<span class="string">"route"</span>,key=<span class="string">"#id"</span>)</span><br><span class="line">       @Override</span><br><span class="line">       public int delete(String appid) &#123;</span><br><span class="line">             log.info(<span class="string">"进入 delete 方法"</span>);</span><br><span class="line">             <span class="built_in">return</span> routeDao.deleteByAppid(appid);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是这四个注解：@Cacheable    @CachePut  @CacheEvict @Caching</p><h4 id="Cacheable："><a href="#Cacheable：" class="headerlink" title="@Cacheable："></a>@Cacheable：</h4><p>@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable可以指定三个属性，value、key和condition</p><p>1.value属性指定Cache名称：<br>value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组例如：{ “cache1”, “cache2”}</p><p>2.key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。</p><p>自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例</p><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value=<span class="string">"users"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line">   public User find(Integer id) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br><span class="line">   @Cacheable(value=<span class="string">"users"</span>, key=<span class="string">"#p0"</span>)</span><br><span class="line">   public User find(Integer id) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br><span class="line">   @Cacheable(value=<span class="string">"users"</span>, key=<span class="string">"#user.id"</span>)</span><br><span class="line">   public User find(User user) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br><span class="line">   @Cacheable(value=<span class="string">"users"</span>, key=<span class="string">"#p0.id"</span>)</span><br><span class="line">   public User find(User user) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>3.condition属性指定发生的条件：有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value=&#123;<span class="string">"users"</span>&#125;, key=<span class="string">"#user.id"</span>, condition=<span class="string">"#user.id%2==0"</span>)</span><br><span class="line">   public User find(User user) &#123;</span><br><span class="line">      System.out.println(<span class="string">"find user by user "</span> + user);</span><br><span class="line">      <span class="built_in">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut:"></a>@CachePut:</h4><p>在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict:"></a>@CacheEvict:</h4><p>@CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。</p><p>1.allEntries属性： allEntries是boolean类型，表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@CacheEvict(value=<span class="string">"users"</span>, allEntries=<span class="literal">true</span>)</span><br><span class="line">   public void delete(Integer id) &#123;</span><br><span class="line">      System.out.println(<span class="string">"delete user by id: "</span> + id)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.beforeInvocation属性： 清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@CacheEvict(value=<span class="string">"users"</span>, beforeInvocation=<span class="literal">true</span>)</span><br><span class="line"> public void delete(Integer id) &#123;</span><br><span class="line">    System.out.println(<span class="string">"delete user by id: "</span> + id);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p>@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Caching(cacheable = @Cacheable(<span class="string">"users"</span>), evict = &#123; @CacheEvict(<span class="string">"cache2"</span>),</span><br><span class="line">         @CacheEvict(value = <span class="string">"cache3"</span>, allEntries = <span class="literal">true</span>) &#125;)</span><br><span class="line">   public User find(Integer id) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>注意:</strong> 需要在SpringBoot的启动项加上@EnableCaching注解，否则spring-data-cache相关注解不会生效…<br>测试结果(第一次执行get/saveOrUpdate/delete)<br><img src="/images/SpringBoot/SpringBoot6/sp6-3.png"></p><p>第二次执行结果<br><img src="/images/SpringBoot/SpringBoot6/sp6-4.png"><br>可以打开到这里是没有再执行get方法的，她是直接从缓存中获取的数据</p><p>参考文献<br>    <a href="https://jingyan.baidu.com/article/7f766dafa0dae64100e1d052.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/7f766dafa0dae64100e1d052.html</a><br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  在如今互联网中，缓存的应用已经很广泛了，它能在互联网中起到加速系统的作用，有两种缓存使用最广泛，那就是Redis和MongoDB，下面就简单来说说Redis&lt;br&gt;  redis是一种运行在内存中的数据库，支持其中数据类型的存储，Redis是一个开源的、使用ANSIC语言编写、遵守BSD协议、支持网络、可基于内存也可以持久化的日志型、键值对数据库，并提供了多种语言API。由于Redis基于内存，所以运行速度很快，大概是关系型数据库的几倍到几十倍，使用Redis来代替关系数据库的查询访问，网站性能将得到很大的提升……
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>linux启动Oracle数据库</title>
    <link href="http://yoursite.com/2018/12/23/linux%E5%90%AF%E5%8A%A8Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/23/linux启动Oracle数据库/</id>
    <published>2018-12-23T14:33:36.000Z</published>
    <updated>2018-12-23T14:53:13.356Z</updated>
    
    <content type="html"><![CDATA[<p>昨天公司服务器重启了….今天数据库连不上了…第一次手动启动服务器 记下一笔….<a id="more"></a></p><h4 id="登录root账户"><a href="#登录root账户" class="headerlink" title="登录root账户"></a>登录root账户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ su - oracle</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 注意中间这个 <strong>-</strong> 一定要加，不加的话会报错 command not found</p><p>因为su只是切换了root身份，但Shell环境仍然是普通用户的Shell；而su -连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误，报command not found的错误<br>当然  直接登录oracle 用户就不会有这个问题</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlplus / as sysdba</span><br></pre></td></tr></table></figure><h4 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ startup</span><br></pre></td></tr></table></figure><h4 id="退出数据库"><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h4 id="检查oracle-监听状态"><a href="#检查oracle-监听状态" class="headerlink" title="检查oracle 监听状态"></a>检查oracle 监听状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl status</span><br></pre></td></tr></table></figure><h4 id="启动oracle-监听"><a href="#启动oracle-监听" class="headerlink" title="启动oracle 监听"></a>启动oracle 监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl start</span><br></pre></td></tr></table></figure><h4 id="撒花截图"><a href="#撒花截图" class="headerlink" title="撒花截图"></a>撒花截图</h4><p><img src="/images/linux/startOracleDatabase/success.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天公司服务器重启了….今天数据库连不上了…第一次手动启动服务器 记下一笔….
    
    </summary>
    
      <category term="linux学习" scheme="http://yoursite.com/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(5)数据库事务处理</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-5-数据库事务处理/</id>
    <published>2018-12-23T12:03:59.000Z</published>
    <updated>2018-12-24T13:47:42.163Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网的数据库的使用中，对于电商和金融网站，最关注的就是数据库事务，对于热门商品的交易和库存以及金融产品的金额，是不允许发生错误的，当热门商品的抢购时，面临高并发的时候，这时候数据库事务处理就显得格外重要了</p><p>对于事务处理最简单的理解就是当高并发的时候对于数据库事务处理机制，此时数据库将在一个多事务的场景下运行。</p><p>说到事务处理，我的第一反应就是@Transactional这个注解<br>这个注解当时只学习了放到方法上，那么今天就来对这个注解以及背后的数据库事务进行深一步的了解…..<a id="more"></a></p><p>在Spring中，数据库事务是通过AOP技术来提供服务的，AOP(面向切面编程)把jdbc中大量的try catch  finally 代码擦出了。看到了非常干净的代码。</p><h2 id="Spring声明式事务的使用"><a href="#Spring声明式事务的使用" class="headerlink" title="Spring声明式事务的使用"></a>Spring声明式事务的使用</h2><p>根据SpringAOP的约定，它会吧我们的代码织入到约定的流程中，同样的，使用AOP的思维后，执行SQL的代码就可以织入到Spring约定的数据库事务的流程中，所以首先来说说这个约定</p><h3 id="Spring声明式数据库事务约定"><a href="#Spring声明式数据库事务约定" class="headerlink" title="Spring声明式数据库事务约定"></a>Spring声明式数据库事务约定</h3><p>对于事务，需要通过标注告诉Spring 在什么地方开启数据库事务，对于声明式事务，是使用@Transactional进行标注的，这个注解可以标注在类或者方法上，当它标注在类上的时候，代表这个类的所有公共非静态方法都将启用事务功能，在@Transactional中，还允许配置了许多属性，比如说事务的隔离级别和传播行为(这2个概念后续会说到)，在比如说异常类型，从而确定方法发生什么异常时回滚事务 或者说什么异常时不回滚事务。这些配置的内容，是在Spring IoC容器在加载的时候就会把这些信息解析出来了，然后把这些信息存到事务定义器(TransactionDefinition接口的实现类中)并且记录哪些类或者方法需要开启事务，采用什么策略去执行事务，这个过程我们就只需要给<strong>Transactional</strong>配置属性而已。</p><p>当Spring 的上下文开始被@Transactional标注的类或者方法的时候，Spring就会产生AOP的功能，当它启动事务的时候，就会根据事务定义器里的配置去设置事务，首先是根据传播行为去确定事务的策略，然后是隔离级别、超时时间、只读等内容，这些都是Spring事务拦截器通过我们对于@Transactional配置的内容来完成的。<br>当执行SQL发生异常之后，Spring数据库拦截器就会根据我们的配置去判断是提交事务 还是回滚(默认不配置的话是回滚)，无论发生异常与否，Spring都会释放事务资源，这样就可以保证数据库连接池正常可用了，这也是由Spring事务拦截器完成的内容。</p><h3 id="Transactional的配置项"><a href="#Transactional的配置项" class="headerlink" title="@Transactional的配置项"></a>@Transactional的配置项</h3><p>数据库的事务属性都是可以通过@Transactional来配置的，下面先来看一下其源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Transactional &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 通过Bean name 来指定事务管理器</span><br><span class="line">        * @see <span class="comment">#transactionManager</span></span><br><span class="line">        */</span><br><span class="line">       @AliasFor(<span class="string">"transactionManager"</span>)</span><br><span class="line">       String value() default <span class="string">""</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 同value属性</span><br><span class="line">        * @since 4.2</span><br><span class="line">        * @see <span class="comment">#value</span></span><br><span class="line">        */</span><br><span class="line">       @AliasFor(<span class="string">"value"</span>)</span><br><span class="line">       String transactionManager() default <span class="string">""</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 指定传播行为</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getPropagationBehavior()</span></span><br><span class="line">        */</span><br><span class="line">       Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line">       /**</span><br><span class="line">        * 指定隔离级别</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getIsolationLevel()</span></span><br><span class="line">        * @see org.springframework.transaction.support.AbstractPlatformTransactionManager<span class="comment">#setValidateExistingTransaction</span></span><br><span class="line">        */</span><br><span class="line">       Isolation isolation() default Isolation.DEFAULT;</span><br><span class="line">       /**</span><br><span class="line">        * 指定超时时间(单位秒)</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getTimeout()</span></span><br><span class="line">        */</span><br><span class="line">       int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line">       /**</span><br><span class="line">        * 是否只读事务</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#isReadOnly()</span></span><br><span class="line">        * @see org.springframework.transaction.support.TransactionSynchronizationManager<span class="comment">#isCurrentTransactionReadOnly()</span></span><br><span class="line">        */</span><br><span class="line">       boolean readOnly() default <span class="literal">false</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常时回滚，默认所有都回滚</span><br><span class="line">        * @see <span class="comment">#rollbackForClassName</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        *方法在发生指定异常名称时回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#rollbackFor</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       String[] rollbackForClassName() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常时不回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#noRollbackForClassName</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常名称时不回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#noRollbackFor</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是<strong>propagation</strong>和<strong>isolation</strong> 这2个属性，这两个属性是指传播行为和隔离级别，它需要了解数据库特性才能使用，也是企业最为关心的内容之一。<br>关于注解@Transactional  其实它是可以放到接口上的，也可以放在实现类上，只不过Spring推荐我们放在实现类上，因为放在接口上将使得你的类基于接口的代理时他们才会生效，在AOP中，Spring可以使用JDK动态代理，也可以使用CGLIG动态代理，如果使用接口，那么将不能使用CGLIG代理….</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID："><a href="#数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID：" class="headerlink" title="数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID："></a>数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID：</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a><strong>原子性（Atomicity）</strong></h4><p>　　<br>      原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a><strong>一致性（Consistency）</strong></h4><p>　　<br>     一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>    拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a><strong>隔离性（Isolation）</strong></h4><p>   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　<br>   即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　<br>   关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a><strong>持久性（Durability）</strong></h4><p>　　<br>  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h3 id="两类丢失更新"><a href="#两类丢失更新" class="headerlink" title="两类丢失更新"></a>两类丢失更新</h3><p><img src="/images/SpringBoot/SpringBoot5/sp5-1.png"></p><p>在第二类对视更新中，为了压制丢失更新，数据库标准提出了4类隔离级别，不同程度的压制丢失更新，这4类隔离级别分别是未提交读，读写提交，可重复读和串行化，他们会在不同程度上压制丢失更新的情景。</p><p>4个隔离级别对于压制丢失更新的程度是不同的，同样对服务器的性能影响也是不同的，现有的技术中有完全可以避免丢失更新的情况，但是这种情况要付出锁的代价，即在同一时间只有一个县城可以访问数据，这样在高并发的情况下，会导致大量线程被挂起和恢复，整个系统会十分缓慢。用户体验极差~</p><h3 id="4种隔离级别的区别："><a href="#4种隔离级别的区别：" class="headerlink" title="4种隔离级别的区别："></a>4种隔离级别的区别：</h3><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读:"></a>未提交读:</h4><p>   未提交读是最低级别的隔离级别，其含义是允许一个事务读取另一个事务中未提交的事务，未提交读是一种危险的隔离级别，所以一般在实际开发应用中不多，但是它的优点在于并发能力高，适合那些对于数据一致性没有要求而追求高并发的场景，它最大的坏处就是出现脏读。</p><p><img src="/images/SpringBoot/SpringBoot5/sp5-2.png"></p><p>如图，当T3时刻，由于采用了未提交读，所以事务2可以读取事务1中未提交的库存数据为1，这里当他扣除库存后数据为0，然后它提交了事务，然后事务1在T5时刻回滚了事务，最后的结果就变成了0，这样就出现了错误。<br>        脏读一般是比较危险的隔离级别，在实际应用中并不多，为了克服脏读，数据库隔离级别还提供了读写提交。</p><h4 id="读写提交"><a href="#读写提交" class="headerlink" title="读写提交:"></a>读写提交:</h4><p>读写提交是指一个事务只能读取另一个事务中已提交的数据，不能读取未提交的数据，可以克服脏读。<br><img src="/images/SpringBoot/SpringBoot5/sp5-3.png"></p><p>但是读写提交也会出现上面描述的问题，这就是我最开始想到的，一个事务执行到一半的时候另外一个事务进来了，这样的update操作可能会出现错误。<br>为了克服这个不足，数据库还提出了可重复读。</p><h4 id="可重复读："><a href="#可重复读：" class="headerlink" title="可重复读："></a>可重复读：</h4><p>可重复读是为了克服读写提交中的不可重复读的现象，因为在读写提交的时候，有些值的变化，影响当前事务的执行，如上述库存是个变化的值。</p><p>   简单点来说，就是当一个事务未提交的时候(特指增删改，查询时不会影响其他事务的读取)，数据库将会阻止其他事务对于数据的读取，只有当前第一个事务提交了之后，事务2才会读取库存的值。但是会引发新的问题：幻读：<br>上图~(其实这些东西主要以理解为主，至于我用图是因为我觉得不至于为了这些概念而单独打出来这些东西，理解第一)<br><img src="/images/SpringBoot/SpringBoot5/sp5-4.png"></p><h4 id="串行化："><a href="#串行化：" class="headerlink" title="串行化："></a>串行化：</h4><p>串行化是数据库最高的隔离级别，他要求所有的SQL都按照顺序执行，可以完全保证数据的一致性，但由于单线程锁，导致性能降低很多，可能会导致系统十分慢。</p><h3 id="使用隔离级别"><a href="#使用隔离级别" class="headerlink" title="使用隔离级别"></a>使用隔离级别</h3><p>之前也说过了，使用这些只需要在注解中添加配置即可，剩下的由Spring完成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(isolation=Isolation.SERIALIZABLE)</span><br><span class="line">@Override</span><br><span class="line">public int delete(String appid) &#123;</span><br><span class="line">       log.info(<span class="string">"进入 delete 方法"</span>);</span><br><span class="line">       <span class="built_in">return</span> routeDao.deleteByAppid(appid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果说一个一个方法单独制定隔离级别太麻烦 可以在配置文件中统一指定</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">        tomcat:</span><br><span class="line">        <span class="comment">#指定数据源默认隔离级别；</span></span><br><span class="line">        <span class="comment">#-1：数据库默认隔离级别</span></span><br><span class="line">        <span class="comment">#1 未提交读</span></span><br><span class="line">        <span class="comment">#2，读写提交</span></span><br><span class="line">        <span class="comment">#4 可重复读</span></span><br><span class="line">        <span class="comment">#8  串行化</span></span><br><span class="line">          default-transaction-isolation: 2</span><br></pre></td></tr></table></figure></p><h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><p>传播行为是指方法之间调用事务才去的策略问题，在默认情况下，一个事务调用的所有方法，要么一起成功，要么所有都失败，但是在实际过程中，比如有1000条数据，成功了900条，这时候如果全部回滚的话 这900条成功的数据也就回滚了，此时，我们的真实需求是 如果发生异常，则异常的数据不提交数据，也就是只回滚这些有问题的数据，那些正常的数据正常的提交事务。</p><p>在Spring中，当一个方法调用另外一个方法的时候，可以让事务才去不同的策略工作，比如新建事务或者挂起事务，这就是事务的传播行为。比如说我们在一个事务中for循环批量插入一千条数据，这当每一条数据插入时，这可以理解成整个事务的单个方法，这个方法执行时，可以让这个当个方法不在当前事务中执行，而是单独的信件一个事务去执行方法，我们就会将当前方法调用资方的传播行为为信件事务，此外，还可以让子方法在无事务、独立事务中执行，这完全取决于你的业务需求</p><p>在Spring事务机制中，对于数据存在七中传播行为，它通过枚举类Propagation定义的，下面放源代码！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public  enum Propagation &#123;       </span><br><span class="line">       /**</span><br><span class="line">        * 需要事务，它是默认的传播行为，如果当前存在事务，就沿用当前事务</span><br><span class="line">        * 否则就新建一个事务运行子方法</span><br><span class="line">        */</span><br><span class="line">       REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">       /**</span><br><span class="line">        * 支持事务，如果当前存在事务，就沿用当前事务</span><br><span class="line">        * 如果不存在，则继续采用无事务的方式运行子方法</span><br><span class="line">        */</span><br><span class="line">       SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">       /**</span><br><span class="line">        * 必须使用事务，如果当前没有事务，则会抛出异常</span><br><span class="line">        * 如果存在事务，则沿用当前事务</span><br><span class="line">        */</span><br><span class="line">       MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">       /**</span><br><span class="line">        * 无论当前事务是否存在，都会创建新的事务运行方法，这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立</span><br><span class="line">        */</span><br><span class="line">       REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">       /**</span><br><span class="line">        * 不支持事务，如果当前存在事务将挂起事务，运行方法</span><br><span class="line">        */</span><br><span class="line">       NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">       /**</span><br><span class="line">        * 不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行</span><br><span class="line">        */</span><br><span class="line">       NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">       /**</span><br><span class="line">        * 在当前方法调用子方法时，如果子方法发生异常，只回滚子方法执行的SQL，而不回滚当前方法的事务</span><br><span class="line">        */</span><br><span class="line">       NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line">       private final int value;</span><br><span class="line">       Propagation(int value) &#123; this.value = value; &#125;</span><br><span class="line">       public int <span class="function"><span class="title">value</span></span>() &#123; <span class="built_in">return</span> this.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的也就是 <strong>NESTED(TransactionDefinition.PROPAGATION_NESTED)</strong><br><strong>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)</strong><br><strong>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)</strong></p><p>接下来通过测试来理解几种常用的传播行为</p><h4 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED:"></a><strong>REQUIRED:</strong></h4><p>需要事务，它是默认的传播行为，如果当前存在事务，就沿用当前事务,否则就新建一个事务运行子方法</p><h4 id="Mapper文件编写"><a href="#Mapper文件编写" class="headerlink" title="Mapper文件编写"></a>Mapper文件编写</h4><p><strong>注意:</strong> mapper文件要注意的是在默认执行student赋值的时候，如果不加后面的jdbcTYPE=XXX  会报错无效的列类型..因为他无法默认给你识别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.wangshun.leaning.dao.IStudentDao"</span> &gt;</span><br><span class="line">  &lt;sql id=<span class="string">"BASE_TABLE"</span>&gt;</span><br><span class="line">    student</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;sql id=<span class="string">"BASE_COLUMN"</span>&gt;</span><br><span class="line">    id,name,age,sex</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"student"</span>&gt;</span><br><span class="line">      SELECT</span><br><span class="line">        &lt;include refid=<span class="string">"BASE_COLUMN"</span>/&gt;</span><br><span class="line">      FROM</span><br><span class="line">        &lt;include refid=<span class="string">"BASE_TABLE"</span>/&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">  &lt;insert id=<span class="string">"saveOrUpdate"</span> parameterType=<span class="string">"student"</span>&gt;</span><br><span class="line">    insert into student(id,name,age,sex) VALUES(<span class="comment">#&#123;id,jdbcType=NUMERIC&#125;,#&#123;name,jdbcType=VARCHAR&#125;,#&#123;age,jdbcType=VARCHAR&#125;,#&#123;sex,jdbcType=VARCHAR&#125;)</span></span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><p><strong>注意:</strong> @Alias(“student”) 注解的使用，这个注解必须配合配置文件中的自动扫描 才能使用，否则在mapper文件中是无法使用类别名的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Alias(<span class="string">"student"</span>)</span><br><span class="line">public class Student &#123;</span><br><span class="line">       private int id;</span><br><span class="line">       private String name;</span><br><span class="line">       private String age;</span><br><span class="line">       private String sex;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       public int <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> id;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setId(int id) &#123;</span><br><span class="line">              this.id = id;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> name;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setName(String name) &#123;</span><br><span class="line">              this.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> age;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setAge(String age) &#123;</span><br><span class="line">              this.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> sex;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setSex(String sex) &#123;</span><br><span class="line">              this.sex = sex;</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>注意：</strong>配置文件中要注意2个点，一个是日志配置中必须吧springframework  这个的日志打开，否则是看不到测试结果的，第二个就是在Mybatis配置中type-aliases-package: com.wangshun.leaning.entity  # 注意：对应实体类的路径 这个必须和实体类路径必须和你@Alias注解所在的包对应才，这个@Alias 注解才能生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">        tomcat:</span><br><span class="line">        <span class="comment">#指定数据源默认隔离级别；</span></span><br><span class="line">        <span class="comment">#-1：数据库默认隔离级别</span></span><br><span class="line">        <span class="comment">#1 未提交读</span></span><br><span class="line">        <span class="comment">#2，读写提交</span></span><br><span class="line">        <span class="comment">#4 可重复读</span></span><br><span class="line">        <span class="comment">#8  串行化</span></span><br><span class="line">          default-transaction-isolation: 2</span><br><span class="line">        name: oracle_test</span><br><span class="line">        <span class="built_in">type</span>: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">        <span class="comment">#druid相关配置</span></span><br><span class="line">        druid:</span><br><span class="line">          <span class="comment">#监控统计拦截的filters</span></span><br><span class="line">          filters: <span class="built_in">stat</span></span><br><span class="line">          driver-class-name: oracle.jdbc.OracleDriver</span><br><span class="line">          <span class="comment">#基本属性</span></span><br><span class="line">          url: jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class="line">          username: weblogic</span><br><span class="line">          password: password1</span><br><span class="line">          <span class="comment">#配置初始化大小/最小/最大</span></span><br><span class="line">          initial-size: 1</span><br><span class="line">          min-idle: 1</span><br><span class="line">          max-active: 20</span><br><span class="line">          <span class="comment">#获取连接等待超时时间</span></span><br><span class="line">          max-wait: 60000</span><br><span class="line">          <span class="comment">#间隔多久进行一次检测，检测需要关闭的空闲连接</span></span><br><span class="line">          time-between-eviction-runs-millis: 60000</span><br><span class="line">          <span class="comment">#一个连接在池中最小生存的时间</span></span><br><span class="line">          min-evictable-idle-time-millis: 300000</span><br><span class="line">          validation-query: SELECT <span class="string">'x'</span> FROM DUAL</span><br><span class="line">          <span class="built_in">test</span>-while-idle: <span class="literal">true</span></span><br><span class="line">          <span class="built_in">test</span>-on-borrow: <span class="literal">false</span></span><br><span class="line">          <span class="built_in">test</span>-on-return: <span class="literal">false</span></span><br><span class="line">          <span class="comment">#打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false</span></span><br><span class="line">          pool-prepared-statements: <span class="literal">true</span></span><br><span class="line">          max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line"><span class="comment">##日志配置,这里只是写了显示日志，后面服务器需要可能需要记录日志可以参考battch的博客</span></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: warn</span><br><span class="line">    <span class="comment">#设置Mybatis打印Sql,下面的包是dao层的包路径，不是mapper的路径</span></span><br><span class="line">    com.wangshun.leaning.dao: DEBUG</span><br><span class="line">    org:</span><br><span class="line">      mybatis: INFO</span><br><span class="line">      springframework: debug</span><br><span class="line">       </span><br><span class="line"><span class="comment">## Mybatis 配置</span></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml  <span class="comment">#注意：一定要对应mapper映射xml文件的所在路径</span></span><br><span class="line">  <span class="built_in">type</span>-aliases-package: com.wangshun.leaning.entity  <span class="comment"># 注意：对应实体类的路径</span></span><br><span class="line">  <span class="comment">#驼峰命名规范 如：数据库字段是  order_id 那么 实体字段就要写成 orderId，</span></span><br><span class="line">  <span class="comment">#这个配置是为我们简化ResultMap的配置</span></span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface IStudentDao &#123;</span><br><span class="line">       </span><br><span class="line">       List&lt;Student&gt; selectAll();</span><br><span class="line">       </span><br><span class="line">       int saveOrUpdate(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service实现类"><a href="#service实现类" class="headerlink" title="service实现类"></a>service实现类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量类BatchService"><a href="#批量类BatchService" class="headerlink" title="批量类BatchService"></a>批量类BatchService</h4><p>这里是需要2个service的，之前也说了 传播行为是方法与方法之间的，同样这里添加事务注解，并且声明传播行为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BatchStudentImpl implements IBatchStudent&#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       IStudneService stuentService;</span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation=Propagation.REQUIRED)</span><br><span class="line">       public int saveOrUpdate(List&lt;Student&gt; students) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">                     stuentService.saveOrUpdate(student);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">return</span> 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       IBatchStudent batchStudent;</span><br><span class="line">       </span><br><span class="line">       /**</span><br><span class="line">        * 测试数据库传播行为</span><br><span class="line">        * @<span class="built_in">return</span></span><br><span class="line">        */</span><br><span class="line">       @GetMapping(<span class="string">"/insertStudents.do"</span>)</span><br><span class="line">       @ResponseBody</span><br><span class="line">       public String <span class="function"><span class="title">insert</span></span>() &#123;</span><br><span class="line">              List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();</span><br><span class="line">              <span class="keyword">for</span>(int i = 0;i&lt;=3;i++) &#123;</span><br><span class="line">                     Student student = new Student();</span><br><span class="line">                     student.setId(i);</span><br><span class="line">                     student.setName(<span class="string">"张三"</span>+i);</span><br><span class="line">                     student.setAge(<span class="string">""</span>+i);</span><br><span class="line">                     list.add(student);</span><br><span class="line">              &#125;</span><br><span class="line">              batchStudent.saveOrUpdate(list);</span><br><span class="line">              <span class="built_in">return</span> <span class="string">"success"</span>;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码 执行<a href="http://localhost:8080/insertStudents.do" target="_blank" rel="noopener">http://localhost:8080/insertStudents.do</a><br>后台日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:03:56.227 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.227 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.228 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 0(Integer), 张三0(String), 0(String), null</span><br><span class="line">2018-12-20 23:03:56.229 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 1(Integer), 张三1(String), 1(String), null</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.233 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.233 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br></pre></td></tr></table></figure></p><p>注意这个：Participating in existing transaction<br>也就是说 它这里执行后面的sql还是沿用的之前的事务。</p><h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p>改动的代码也就是单条插入的那个service 的实现类中的事务标注的设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:23:03.360  INFO 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2018-12-20 23:23:03.361 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Detected StandardServletMultipartResolver</span><br><span class="line">2018-12-20 23:23:03.373 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : enableLoggingRequestDetails=<span class="string">'false'</span>: request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data</span><br><span class="line">2018-12-20 23:23:03.373  INFO 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 12 ms</span><br><span class="line">2018-12-20 23:23:03.392 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET <span class="string">"/insertStudents.do"</span>, parameters=&#123;&#125;</span><br><span class="line">2018-12-20 23:23:03.400 DEBUG 16640 --- [nio-8080-exec-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to public java.lang.String com.wangshun.leaning.controller.StudentController.insert()</span><br><span class="line"><span class="comment">#创建当前方法事务(com.wangshun.leaning.service.impl.BatchStudentImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.419 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [com.wangshun.leaning.service.impl.BatchStudentImpl.saveOrUpdate]: PROPAGATION_REQUIRED,ISOLATION_READ_COMMITTED</span><br><span class="line">2018-12-20 23:23:03.425 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#设置当前事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.433 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] to 2</span><br><span class="line">2018-12-20 23:23:03.433 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] to manual commit</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.439 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.497 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.499 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.499 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.543 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.658 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 0(Integer), 张三0(String), 0(String), null</span><br><span class="line">2018-12-20 23:23:03.665 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.667 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.667 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 1(Integer), 张三1(String), 1(String), null</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 3(Integer), 张三3(String), 3(String), null</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885]</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] after transaction</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.721 DEBUG 16640 --- [nio-8080-exec-1] m.m.a.RequestResponseBodyMethodProcessor : Using <span class="string">'text/html'</span>, given [text/html, application/xhtml+xml, image/webp, image/apng, application/xml;q=0.9, */*;q=0.8] and supported [text/plain, */*, text/plain, */*, application/json, application/*+json, application/json, application/*+json]</span><br><span class="line">2018-12-20 23:23:03.722 DEBUG 16640 --- [nio-8080-exec-1] m.m.a.RequestResponseBodyMethodProcessor : Writing [<span class="string">"success"</span>]</span><br><span class="line">2018-12-20 23:23:03.730 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2018-12-20 23:23:03.755 DEBUG 16640 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : GET <span class="string">"/favicon.ico"</span>, parameters=&#123;&#125;</span><br><span class="line">2018-12-20 23:23:03.757 DEBUG 16640 --- [nio-8080-exec-2] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped to ResourceHttpRequestHandler [class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/], ServletContext resource [/], class path resource []]</span><br><span class="line">2018-12-20 23:23:03.790 DEBUG 16640 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br></pre></td></tr></table></figure><p>通过上图的测试结果可以看出来，每次执行新增操作的时候，它都是启用一个新的数据库事务去执行这个saveOrUpdate方法，并且独立提交，完全脱离了原本事务的管控，每一个事务都可以拥有自己独立的隔离级别和锁。</p><h4 id="Propagation-NESTED"><a href="#Propagation-NESTED" class="headerlink" title="Propagation.NESTED"></a>Propagation.NESTED</h4><p>修改的代码部分依旧只有传播行为的属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation = Propagation.NESTED)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:42:59.252 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.DataSourceTransactionManager     : Creating nested transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:42:59.253 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:42:59.253 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:42:59.254 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:42:59.254 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.DataSourceTransactionManager     : Releasing transaction savepoint</span><br><span class="line">2018-12-20 23:42:59.256 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.JdbcTransactionObjectSupport     : Could not explicitly release JDBC savepoint</span><br><span class="line">java.sql.SQLFeatureNotSupportedException: 不支持的特性</span><br></pre></td></tr></table></figure><p>虽然说不支持吧…但是可以看到SQL异常之前的的savepoint<br>这个的意思是标志位<br>他的意思就是说 每一条数据执行完之后都会设置一个标志位，如果后面的数据发生异常，那么就会回滚到当前标志位的数据状态，而不是让所有的数据也回滚。<br>这个标志位在数据库中的名词叫做保存点(save point)</p><h4 id="最后说一点"><a href="#最后说一点" class="headerlink" title="最后说一点"></a>最后说一点</h4><p>NESTED和REQUIRES_NEW 还是有很大的区别的  前者会沿用之前设计的锁和隔离级别，而后者可以完全脱离原本自己设定新的锁和隔离级别</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在互联网的数据库的使用中，对于电商和金融网站，最关注的就是数据库事务，对于热门商品的交易和库存以及金融产品的金额，是不允许发生错误的，当热门商品的抢购时，面临高并发的时候，这时候数据库事务处理就显得格外重要了&lt;/p&gt;
&lt;p&gt;对于事务处理最简单的理解就是当高并发的时候对于数据库事务处理机制，此时数据库将在一个多事务的场景下运行。&lt;/p&gt;
&lt;p&gt;说到事务处理，我的第一反应就是@Transactional这个注解&lt;br&gt;这个注解当时只学习了放到方法上，那么今天就来对这个注解以及背后的数据库事务进行深一步的了解…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(4)访问数据库</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-4-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-4-访问数据库/</id>
    <published>2018-12-23T11:24:11.000Z</published>
    <updated>2018-12-23T13:01:21.919Z</updated>
    
    <content type="html"><![CDATA[<p>关于持久层框架  常用的比如说Hibernate、Mybatis<br>由于现在主流的框架是MyBatis，所以这里就简单说一下MyBatis</p><p>简介：<br>    MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录……….<a id="more"></a></p><p>默认的Spring是不支持Mybatis的，但是Mybatis社区自己整合了Spring并提供出来jar包，所以我们可以在POM文件中添加依赖来使用MyBatis</p><h3 id="在pom文件中添加依赖"><a href="#在pom文件中添加依赖" class="headerlink" title="在pom文件中添加依赖"></a>在pom文件中添加依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--MyBatis基础包  --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>MyBatis是一种基于SqlSessionFactory构建的框架。对于SqlSessionFactory而言，它的作用是生成SqlSession接口对象，这个对象是MyBatis操作的核心 </p><h3 id="属性文件配置"><a href="#属性文件配置" class="headerlink" title="属性文件配置"></a>属性文件配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 该配置节点为独立的节点，不在spring的节点下</span></span><br><span class="line"><span class="comment">## Mybatis 配置</span></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml  <span class="comment">#注意：一定要对应mapper映射xml文件的所在路径</span></span><br><span class="line">  <span class="built_in">type</span>-aliases-package: com.ithwua.entity  <span class="comment"># 注意：对应实体类的路径,配合@Alias注解使用</span></span><br><span class="line">  <span class="comment">#驼峰命名规范 如：数据库字段是  order_id 那么 实体字段就要写成 orderId，</span></span><br><span class="line">  <span class="comment">#这个配置是为我们简化ResultMap的配置</span></span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="使用Mybatis注解实现类别名"><a href="#使用Mybatis注解实现类别名" class="headerlink" title="使用Mybatis注解实现类别名"></a>使用Mybatis注解实现类别名</h3><p>类别名也就是在类的上方使用@Alias(“别名”)，这样的话在对应的mapper文件中 resultType 就可以写成别名了，就不需要从包开始全部写完了。</p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Alias(<span class="string">"user"</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line">       </span><br><span class="line">       private Long id;</span><br><span class="line">       private String user_name;</span><br><span class="line">       private String password;</span><br><span class="line">       //省略get  <span class="built_in">set</span> 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Mapper文件"><a href="#编写Mapper文件" class="headerlink" title="编写Mapper文件"></a>编写Mapper文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.ekingwin.bas.cloud.project.basi.srvgov.dao.PrepareServiceInfoDao"</span> &gt;</span><br><span class="line"></span><br><span class="line">  &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"user"</span>&gt;</span><br><span class="line">       select id,user_name as userName,password from User</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>这里的Mapper 中有几个需要注意的</p><p>1.<strong>namespace</strong>:   这个就是指接口的路径，下面的ID就会和这个接口中的方法名进行匹配。</p><p>2.<strong>select</strong> : 标明这是一个查询SQL</p><p>3.<strong>select</strong>中的id：与上面namespace指的接口中的方法名对应</p><p>4.<strong>resultType</strong>：指定返回集的类型，默认应该是写全名的，这里由于加了@Alias注解，所以可以使用别名user；</p><h3 id="自定义Mybatis插件"><a href="#自定义Mybatis插件" class="headerlink" title="自定义Mybatis插件"></a>自定义Mybatis插件</h3><p>假设存在一个Mybatis插件，其代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(<span class="built_in">type</span>=StatementHandler.class,method=<span class="string">"prepare"</span>,args= &#123;Connection.class,Integer.class&#125;)&#125;)</span><br><span class="line">public class MyPlugin implements Interceptor&#123;</span><br><span class="line">       </span><br><span class="line">       Properties propertise = null;</span><br><span class="line">       </span><br><span class="line">       //拦截器逻辑</span><br><span class="line">       @Override</span><br><span class="line">       public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">              System.out.println(<span class="string">"插件拦截方法"</span>);</span><br><span class="line">              <span class="built_in">return</span> invocation.proceed();//回调方法</span><br><span class="line">       &#125;</span><br><span class="line">       //生成MyBatis拦截器代理对象</span><br><span class="line">       @Override</span><br><span class="line">       public Object plugin(Object target) &#123;</span><br><span class="line">              <span class="built_in">return</span> Plugin.wrap(target, this);</span><br><span class="line">       &#125;</span><br><span class="line">       //设置插件属性</span><br><span class="line">       @Override</span><br><span class="line">       public void setProperties(Properties properties) &#123;</span><br><span class="line">              this.propertise = properties;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一个Mybatis插件就创建出来了，但是没有把他配置到MyBatis中，这个时候完全可以通过application.yml文件中添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br></pre></td></tr></table></figure><p>这样就指定了配置文件的位置，这样我们在对应的路径下创建这个配置值文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">       &lt;plguins&gt;</span><br><span class="line">              &lt;plugin interceptor = <span class="string">"com.wangshun.leaning.plugin.MyPlugin"</span>&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key1"</span> value=<span class="string">"value1"</span>&gt;&lt;/property&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key2"</span> value=<span class="string">"value2"</span>&gt;&lt;/property&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key3"</span> value=<span class="string">"value3"</span>&gt;&lt;/property&gt;</span><br><span class="line">              &lt;/plugin&gt;</span><br><span class="line">       &lt;/plguins&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这样就可以完成对于mybatis 一些组件的配置了，实际编写中可以按照实际的需求来进行编写。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于持久层框架  常用的比如说Hibernate、Mybatis&lt;br&gt;由于现在主流的框架是MyBatis，所以这里就简单说一下MyBatis&lt;/p&gt;
&lt;p&gt;简介：&lt;br&gt;    MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录……….
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(3)AOP编程</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-3-AOP%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-3-AOP编程/</id>
    <published>2018-12-23T03:29:24.000Z</published>
    <updated>2018-12-23T12:23:10.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP理论"><a href="#AOP理论" class="headerlink" title="AOP理论"></a>AOP理论</h2><h3 id="AOP的概念："><a href="#AOP的概念：" class="headerlink" title="AOP的概念："></a>AOP的概念：</h3><p>面向切面编程，其实也就是一定的规则，我就可以把代码织入到事先约定好的流程中。实际上Spring AOP 也是一种约定流程编程…..<a id="more"></a></p><h3 id="为什么要使用AOP"><a href="#为什么要使用AOP" class="headerlink" title="为什么要使用AOP"></a>为什么要使用AOP</h3><p>AOP最为典型的应用就是数据库事务的管控，比如我们要保存一个用户的信息的时候，也需要把这个用户的角色信息保存了(2张表)，如果说数据库事务中的要求是 要么一起成功，要么一起失败的时候，这种情况下OOP是做不到的，那么使用AOP就可以解决这个问题。<br>再比如写入数据库这个操作的过程应该是：获取数据库连接–&gt;执行Sql–&gt;提交事务(或者回滚事务)–&gt;释放数据库连接<br>关于获取连接、提交、释放数据库连接这种重复的操作，就可以使用流程去实现，而不同的地方就在于编写SQL，其实在Spring中有大量的这样类似的代码。<br>比如我们经常会使用的一个事务注解：<strong>@Transactional</strong>,   这个注解就是标明此方法需要事务运行，并没有任何关于数据库打开和关闭的代码，也没有提交和回滚的代码，但是还是实现了这些功能，大致就是Spring帮你把写入的方法织入流程中，而那些 事务操作都帮你默认实现了，也就是它可以把大量重复的流程通过约定的方式抽象出来，然后给予默认的实现，，可见它可以帮助我们减少大量的代码，尤其是那些try….catch…..</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>1.连接点（join point）：对应具体的被拦截的对象，由于Spring只支持方法，所以被拦截的对象往往是指特定的方法。此方法为一个连接点，AOP通过动态代理技术把它织入到对应流程中。</p><p>2.切点(point cut):有时候，我们的切面不单单应用于单个方法，也可能是多各类不同的方法，这时，可以通过正则表达式和指示器的规则去定义，从而适配连接点，切点就是提供这个功能的概念。</p><p>3.通知(advice):就是按照约定的流程下的方法，分为前置通知(before advice) 后置通知(after advice) 环绕通知(around advice) 事后返回通知(afterReturning advice) 和异常通知(afterThrowing advice),他会根据约定织入流程中，需要弄明白他们在流程中的顺序和运行条件。</p><p>4.目标对象(target) ： 即被代理对象，例如：约定编程中的HelloServiceImpl实例就是一个目标对象，它被代理了。</p><p>5.引入(introduction): 是指引入新的类和方法，增强现有Bean的功能。</p><p>6.织入(weaving): 它是一个通过动态代理技术，为原有服务对象生成代理对象，然后与切点定义匹配的连接点拦截，并按照约束将各类通知织入约定流程的过程。</p><p>7.切面(aspect)： 十四一个可以定义切点、各类通知和引入的内容，Spring AOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。<br><img src="/images/SpringBoot/SpringBoot3/sp3-1.png"></p><h2 id="AOP-小例子"><a href="#AOP-小例子" class="headerlink" title="AOP 小例子"></a>AOP 小例子</h2><h3 id="定义Service接口"><a href="#定义Service接口" class="headerlink" title="定义Service接口"></a>定义Service接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 打印用户信息</span><br><span class="line">        * @param user</span><br><span class="line">        */</span><br><span class="line">       public void printUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void printUser(User user) &#123;</span><br><span class="line">             <span class="keyword">if</span>(user==null) &#123;</span><br><span class="line">                    throw new RuntimeException(<span class="string">"检查用户名参数为空"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">"id:"</span>+user.getId());</span><br><span class="line">             System.out.println(<span class="string">"userName:"</span>+ user.getUserName());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">       @Pointcut(<span class="string">"execution(*com.wangshun.leaning.chapter4.service.UserService(..))"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">pointCut</span></span>() &#123;&#125;</span><br><span class="line">       @Before(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public boolean <span class="function"><span class="title">before</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">             <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       @After(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">after</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"after....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       @AfterReturning(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">afterReturning</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"afterReturning....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       @AfterThrowing(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">afterThrowing</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"afterThrowing....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Aspect</strong> 这个注解也就是声明切面的一个注解，就相当于是告诉Spring，这是一个切面。然后@Before 那些注解就和AOP的概念一样的意思，比如前置通知之类的…</p><p><strong>@Pointcut</strong> 此注解用于定义切点，它被标注在方法pointCut上，则后面的通知注解中就可以使用方法的名称来定义了其含义就是对这个切点的引用，而这个注解里面的正则表达式就是告诉Spring 哪些方法需要进行AOP编程</p><p><strong>正则表达式 execution(* com.wangshun.leaning.chapter4.service.UserServiceImpl.printUser(..))</strong></p><p>execution表示在执行的时候，拦截里面的正则匹配的方法;</p><p>*表示任意返回类型的方法;</p><p>com.wangshun.leaning.chapter4.service.UserServiceImpl 指定目标对象的全限定名称;</p><p>printUser 指定目标对象的方法;</p><p>(..)表示任意参数进行匹配。</p><p>这样Spring就可以通过这个正则表达式知道你需要对UserServiceImpl类的printUser方法进行AOP增强，它就会将正则表达式匹配的方法和对应切面的方法织入到约定流程中，从而完成AOP编程。</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       UserService userService;</span><br><span class="line">       </span><br><span class="line">       @GetMapping(<span class="string">"/print"</span>)</span><br><span class="line">       public User printUser(String userName,Long id) &#123;</span><br><span class="line">             User user = new User();</span><br><span class="line">             user.setUserName(userName);</span><br><span class="line">             user.setId(id);</span><br><span class="line">             user.setNote(<span class="string">"note1"</span>);</span><br><span class="line">             userService.printUser(user);</span><br><span class="line">             <span class="built_in">return</span> user;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在地址栏输入：localhost:8080/print，来观察控制台的变化<br><img src="/images/SpringBoot/SpringBoot3/sp3-2.png"><br>从上图中可以看到这个方法被拦截，先执行了before，然后执行我的方法中定义的东西，然后执行了after，没有报错的情况下执行了afterReturning，<strong>注意： after，无论其报错与否都会执行</strong></p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>环绕通知是所有通知中最强大的通知，一般而言，使用它的场景是在你需要大幅度修改原有目标对象的服务逻辑时，环绕通知是一个取代原有目标对象方法的通知，当然它也提供了回调原有目标对象方法的能力~</p><h3 id="在Aspect代码中加入以下部分"><a href="#在Aspect代码中加入以下部分" class="headerlink" title="在Aspect代码中加入以下部分"></a>在Aspect代码中加入以下部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Around(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">             System.out.println(<span class="string">"around.....before"</span>);</span><br><span class="line">             //回调目标对象的原有方法</span><br><span class="line">             jp.proceed();</span><br><span class="line">             System.out.println(<span class="string">"around.....after"</span>);</span><br><span class="line">             </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/images/SpringBoot/SpringBoot3/sp3-3.png"><br>emmmmm这个和我想要的结果好像不太一样，想的应该是先执行before再执行这个，所以说….谨慎使用吧..要改的逻辑好像挺多的…</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在测试AOP的时候，我们打印了用户信息，如果信息为空，则抛出异常，事实上，假设改一下需求，如果信息为空则不打印，假设这里userService不是自己写的，是外部提供的，我们不能修改他，这时Spring允许增强这个接口的功能，我们可以为这个接口引入新的接口，例如要引入一个用户检测的接口<strong>UserValidator</strong></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface UserValidator &#123;</span><br><span class="line">       </span><br><span class="line">       public boolean validator(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserValidatorImpl implements UserValidator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean validator(User user) &#123;</span><br><span class="line">        System.out.println(<span class="string">"引入新的接口"</span> + UserValidator.class.getSimpleName());</span><br><span class="line">        <span class="built_in">return</span> user !=null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在MyAspect-里面引入新接口"><a href="#在MyAspect-里面引入新接口" class="headerlink" title="在MyAspect 里面引入新接口"></a>在MyAspect 里面引入新接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">       * 引入新接口</span><br><span class="line">       */</span><br><span class="line">      @DeclareParents(value=<span class="string">"com.wangshun.leaning.chapter4.service.impl.UserServiceImpl+"</span>,</span><br><span class="line">                   defaultImpl=UserValidatorImpl.class)</span><br><span class="line">      public UserValidator userValidatorService;</span><br></pre></td></tr></table></figure><p><strong>@DeclareParents</strong> 这个注解的意思就是，它的作用就是引入新的类来增强服务，它有2个必须的属性<strong>value</strong>和<strong>defaultImpl</strong>。</p><p>   <strong>value</strong>:只想你要增强的目标对象，这里要增强的是<br>UserServiceImpl对象，因此可以看到配置为com.wangshun.leaning.chapter4.service.impl.UserServiceImpl+(最后那个+不要忘了)</p><p>   <strong>defaultImpl</strong>：引入增强功能的类，这里配置的是UserValidatorImpl，用来提供校验用户是否为空的功能</p><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/vp"</span>)</span><br><span class="line">      public User validateAndPrint(Long id,String userName,String note) &#123;</span><br><span class="line">            User user = new User();</span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setUserName(userName);</span><br><span class="line">            user.setNote(note);</span><br><span class="line">            //强制转换</span><br><span class="line">            UserValidator userValidatorService = (UserValidator) userService;</span><br><span class="line">            <span class="keyword">if</span>(userValidatorService.validator(user)) &#123;</span><br><span class="line">                   userService.printUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> user;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="增强原理"><a href="#增强原理" class="headerlink" title="增强原理"></a>增强原理</h3><p>之前的代码中有一段生成代理对象的代码为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object proxyObject = Proxy.newProxyInstance(Target.class.getClassLoader(), Target.class.getInterfaces(), proxyBean)</span><br></pre></td></tr></table></figure></p><p>这里的<strong>newProxyInstance</strong>的第二个参数作为一个数组，也就是说这里产生代理对象的时候，会把UserService 和UserValidator2个接口传递进去，让代理对象挂到这2个接口下面，这样这个代理对象就可以相互转换并且使用它们的方法了。</p><p>织入是一个生成动态代理服务对象并且将切面和目标对象方法编织成为约定流程的过程，对于流程上的通知，我们一般采用的是接口+实现类的模式，这是Spring推荐的，但是对于是否拥有接口SpringAOP 是不做强制要求的，对于动态代理也有多种实现的方式，比如CGLIB就是不需要接口的，所以Spring中就会做一个判断 如果是接口+实现类 那就用JDK的实现方式 生成代理 ，如果只有类 没有接口 那就用CGLIB的方式实现。</p><h2 id="通知获取参数"><a href="#通知获取参数" class="headerlink" title="通知获取参数"></a>通知获取参数</h2><p>如果我们需要传递参数给通知，这样也是可以的，只需要在切入点加入对应的正则表达式即可，当然对于非环绕型通知，我们还可以使用一个连接点(JoinPoint)类型的参数来获取参数</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Before(<span class="string">"pointCut() &amp;&amp;args(user)"</span>)</span><br><span class="line">       public boolean before(JoinPoint point,User user) &#123;</span><br><span class="line">              Object[] args = point.getArgs();</span><br><span class="line">              System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">              <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>ps：对于非环绕通知的参数，JoinPoint 是可行的，SpringAOP会把它自动传递到通知中，如果是环绕行通知，则可以使用ProceedingJoinPoint</strong></p><p><strong>对于多个切面同时拦截一个接口的时候 可以使用@order注解去进行排序 ，来决定 多个切面的执行顺序。</strong></p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP理论&quot;&gt;&lt;a href=&quot;#AOP理论&quot; class=&quot;headerlink&quot; title=&quot;AOP理论&quot;&gt;&lt;/a&gt;AOP理论&lt;/h2&gt;&lt;h3 id=&quot;AOP的概念：&quot;&gt;&lt;a href=&quot;#AOP的概念：&quot; class=&quot;headerlink&quot; title=&quot;AOP的概念：&quot;&gt;&lt;/a&gt;AOP的概念：&lt;/h3&gt;&lt;p&gt;面向切面编程，其实也就是一定的规则，我就可以把代码织入到事先约定好的流程中。实际上Spring AOP 也是一种约定流程编程…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot(2)SpringBoot日志配置</title>
    <link href="http://yoursite.com/2018/12/23/springBoot-2-SpringBoot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/12/23/springBoot-2-SpringBoot日志配置/</id>
    <published>2018-12-23T03:14:06.000Z</published>
    <updated>2018-12-23T03:27:25.150Z</updated>
    
    <content type="html"><![CDATA[<p>简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程</p><p>很多情况下，我们会需要使用一些日志来查看SpringBoot中的一些东西，比如最常用的就是打印Sql了，在后台显示Sql也可以帮助我们迅速的解决出现的一些Sql问题等等，下面来说说如何在SpringBoot中配置日志……<a id="more"></a></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>首先SpringBoot的日志配置是通过配置文件来完成的，默认支持的两种配置文件分别是properties 和yml。这里推荐使用yml，因为看起来更加简洁、舒适</p><p>显示日志只需要在配置文件中添加以下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##日志配置,这里只是写了显示日志，后面服务器需要可能需要记录日志可以参考battch的博客</span></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    <span class="comment">#root: warn</span></span><br><span class="line">    <span class="comment">#设置Mybatis打印Sql,下面的包是dao层的包路径，不是mapper的路径</span></span><br><span class="line">    com.ithwua.dao: DEBUG</span><br><span class="line">    <span class="comment">#org:</span></span><br><span class="line">      <span class="comment">#hibernate: ERROR</span></span><br><span class="line">      mybatis: INFO</span><br><span class="line">      springframework:</span><br><span class="line">        web: debug</span><br></pre></td></tr></table></figure><h3 id="propertise文件的写法"><a href="#propertise文件的写法" class="headerlink" title="propertise文件的写法:"></a>propertise文件的写法:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root = WARN</span><br><span class="line">logging.level.org.springframework.web = DEBUG</span><br><span class="line">logging.level.org.hibernate = ERROR</span><br><span class="line"></span><br><span class="line"><span class="comment">#比如 mybatis sql日志</span></span><br><span class="line">logging.level.org.mybatis = INFO</span><br><span class="line">logging.level.mapper的Dao所在的包 = DEBUG</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://blog.battcn.com/2018/04/23/springboot/v2-config-logs/" target="_blank" rel="noopener">http://blog.battcn.com/2018/04/23/springboot/v2-config-logs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程&lt;/p&gt;
&lt;p&gt;很多情况下，我们会需要使用一些日志来查看SpringBoot中的一些东西，比如最常用的就是打印Sql了，在后台显示Sql也可以帮助我们迅速的解决出现的一些Sql问题等等，下面来说说如何在SpringBoot中配置日志……
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot(1)使用MyEclipse构建一个SpringBoot</title>
    <link href="http://yoursite.com/2018/12/23/springBoot-1-%E4%BD%BF%E7%94%A8MyEclipse%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AASpringBoot/"/>
    <id>http://yoursite.com/2018/12/23/springBoot-1-使用MyEclipse构建一个SpringBoot/</id>
    <published>2018-12-23T02:38:56.000Z</published>
    <updated>2018-12-23T03:01:18.682Z</updated>
    
    <content type="html"><![CDATA[<p>简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程</p><p>我使用的是MyEclipse2018，接下来就说一下如何使用MyEclipse构建一个SpringBoot项目……<a id="more"></a></p><h3 id="新建Spring-项目"><a href="#新建Spring-项目" class="headerlink" title="新建Spring 项目"></a>新建Spring 项目</h3><p>右击新建一个Spring 项目，搜索Spring，选择Spring Starter Project<br><img src="/images/SpringBoot/SpringBoot1/sp1-1.png"></p><h3 id="输入项目名称-分组-描述-以及起始包"><a href="#输入项目名称-分组-描述-以及起始包" class="headerlink" title="输入项目名称/分组/描述/以及起始包"></a>输入项目名称/分组/描述/以及起始包</h3><p><img src="/images/SpringBoot/SpringBoot1/p2.png"></p><h3 id="选择SpringBoot的版本以及相应的组件-比如web-mybatis等等"><a href="#选择SpringBoot的版本以及相应的组件-比如web-mybatis等等" class="headerlink" title="选择SpringBoot的版本以及相应的组件(比如web/mybatis等等)"></a>选择SpringBoot的版本以及相应的组件(比如web/mybatis等等)</h3><p><img src="/images/SpringBoot/SpringBoot1/p3.png"></p><h3 id="点击finishe即可，其中首次创建会比较慢，因为需要下载jar包-需要提前配置好Maven-。"><a href="#点击finishe即可，其中首次创建会比较慢，因为需要下载jar包-需要提前配置好Maven-。" class="headerlink" title="点击finishe即可，其中首次创建会比较慢，因为需要下载jar包(需要提前配置好Maven)。"></a>点击finishe即可，其中首次创建会比较慢，因为需要下载jar包(需要提前配置好Maven)。</h3><h3 id="可选-为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise-插件参考地址"><a href="#可选-为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise-插件参考地址" class="headerlink" title="(可选) 为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise 插件参考地址"></a>(可选) 为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise 插件<a href="https://blog.csdn.net/qq_31151929/article/details/51121750" target="_blank" rel="noopener">参考地址</a></h3><pre><code>安装完成之后，在windows-&gt;propertise里面选择一下默认即可：</code></pre><p><img src="/images/SpringBoot/SpringBoot1/p4.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程&lt;/p&gt;
&lt;p&gt;我使用的是MyEclipse2018，接下来就说一下如何使用MyEclipse构建一个SpringBoot项目……
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo学习(1)：使用Hexo搭建博客</title>
    <link href="http://yoursite.com/2018/12/21/hello-world/"/>
    <id>http://yoursite.com/2018/12/21/hello-world/</id>
    <published>2018-12-21T15:41:39.000Z</published>
    <updated>2018-12-23T02:51:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>经过一次偶然的机会，我发现了Hexo这个简单快捷的博客框架，这让我想搭建一个博客自己写东西的想法更近了一步，接下来来说说如何使用Hexo 搭建博客…..<a id="more"></a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装Hexo必要的环境"><a href="#安装Hexo必要的环境" class="headerlink" title="安装Hexo必要的环境"></a>安装Hexo必要的环境</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>安装node.js过程暂时省略额<br>确认自己电脑是否安装node.js命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br></pre></td></tr></table></figure></p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>安装git过程暂时省略<br>确认自己电脑是否安装git命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure><h3 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h3><h4 id="使用指令安装Hexo"><a href="#使用指令安装Hexo" class="headerlink" title="使用指令安装Hexo"></a>使用指令安装Hexo</h4><p>确认node  和git 均安装完成后，开始我们的Hexo安装<br>安装的指令也是十分的简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装的过程可能会比较的缓慢，请耐心等待，因为是从gitHub上面下载。<br><img src="/images/HexoExample1/p1.png"><br>2个警告可以不用管</p><h4 id="hexo-初始化"><a href="#hexo-初始化" class="headerlink" title="hexo 初始化"></a>hexo 初始化</h4><p>安装完成后，可以进入指定目录  执行hexo init 也就是初始化，这样它就会在对应的文件夹下，通过git 去下载Hexo所需要的资源，这些资源也是从gitHub上下载的。<br><img src="/images/HexoExample1/p2.png"></p><p>几个警告同样可以不用管，如果是想在当前workspace的下一个文件夹中创建hexo 也可以使用 hexo init test(test就是文件夹的名称)，这样他就会把资源下载到当前目录的test文件夹中，因为一个workspace可能存在多个项目。<br>下载完成后，我们可以使用dir指令来查看究竟下载了那些东西<br><img src="/images/HexoExample1/p3.png">，这些资源是和gitHub上一致的。</p><h4 id="生成Hexo静态页面"><a href="#生成Hexo静态页面" class="headerlink" title="生成Hexo静态页面"></a>生成Hexo静态页面</h4><p>然后使用hexo g 去生成那些个静态页面。<br><img src="/images/HexoExample1/p4.png"></p><p>完成之后可以再次使用dir命令，就可以看到对比刚才，多了一个public文件夹，所有的静态页面的资源都放到这里面了。<br><img src="/images/HexoExample1/p5.png"></p><h4 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h4><p>最后输入以下指令来启动hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p><img src="/images/HexoExample1/p6.png"><br>复制开启后显示的地址，打开浏览器访问即可。<br>就可以看到默认的博客样式了。<br><img src="/images/HexoExample1/p7.png"><br>如果希望更改自己主题以及一些其他的设定请参考<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p><p>参考文档:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过一次偶然的机会，我发现了Hexo这个简单快捷的博客框架，这让我想搭建一个博客自己写东西的想法更近了一步，接下来来说说如何使用Hexo 搭建博客…..
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
