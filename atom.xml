<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卡丘的博客</title>
  
  <subtitle>java新手</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-23T14:53:13.356Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>卡丘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux启动Oracle数据库</title>
    <link href="http://yoursite.com/2018/12/23/linux%E5%90%AF%E5%8A%A8Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/23/linux启动Oracle数据库/</id>
    <published>2018-12-23T14:33:36.000Z</published>
    <updated>2018-12-23T14:53:13.356Z</updated>
    
    <content type="html"><![CDATA[<p>昨天公司服务器重启了….今天数据库连不上了…第一次手动启动服务器 记下一笔….<a id="more"></a></p><h4 id="登录root账户"><a href="#登录root账户" class="headerlink" title="登录root账户"></a>登录root账户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ su - oracle</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 注意中间这个 <strong>-</strong> 一定要加，不加的话会报错 command not found</p><p>因为su只是切换了root身份，但Shell环境仍然是普通用户的Shell；而su -连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误，报command not found的错误<br>当然  直接登录oracle 用户就不会有这个问题</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlplus / as sysdba</span><br></pre></td></tr></table></figure><h4 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ startup</span><br></pre></td></tr></table></figure><h4 id="退出数据库"><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h4 id="检查oracle-监听状态"><a href="#检查oracle-监听状态" class="headerlink" title="检查oracle 监听状态"></a>检查oracle 监听状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl status</span><br></pre></td></tr></table></figure><h4 id="启动oracle-监听"><a href="#启动oracle-监听" class="headerlink" title="启动oracle 监听"></a>启动oracle 监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl start</span><br></pre></td></tr></table></figure><h4 id="撒花截图"><a href="#撒花截图" class="headerlink" title="撒花截图"></a>撒花截图</h4><p><img src="/images/linux/startOracleDatabase/success.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天公司服务器重启了….今天数据库连不上了…第一次手动启动服务器 记下一笔….
    
    </summary>
    
      <category term="linux学习" scheme="http://yoursite.com/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(5)数据库事务处理</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-5-数据库事务处理/</id>
    <published>2018-12-23T12:03:59.000Z</published>
    <updated>2018-12-23T12:59:53.678Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网的数据库的使用中，对于电商和金融网站，最关注的就是数据库事务，对于热门商品的交易和库存以及金融产品的金额，是不允许发生错误的，当热门商品的抢购时，面临高并发的时候，这时候数据库事务处理就显得格外重要了</p><p>对于事务处理最简单的理解就是当高并发的时候对于数据库事务处理机制，此时数据库将在一个多事务的场景下运行。</p><p>说到事务处理，我的第一反应就是@Transactional这个注解<br>这个注解当时只学习了放到方法上，那么今天就来对这个注解以及背后的数据库事务进行深一步的了解…..<a id="more"></a></p><p>在Spring中，数据库事务是通过AOP技术来提供服务的，AOP(面向切面编程)把jdbc中大量的try catch  finally 代码擦出了。看到了非常干净的代码。</p><h2 id="Spring声明式事务的使用"><a href="#Spring声明式事务的使用" class="headerlink" title="Spring声明式事务的使用"></a>Spring声明式事务的使用</h2><p>根据SpringAOP的约定，它会吧我们的代码织入到约定的流程中，同样的，使用AOP的思维后，执行SQL的代码就可以织入到Spring约定的数据库事务的流程中，所以首先来说说这个约定</p><h3 id="Spring声明式数据库事务约定"><a href="#Spring声明式数据库事务约定" class="headerlink" title="Spring声明式数据库事务约定"></a>Spring声明式数据库事务约定</h3><p>对于事务，需要通过标注告诉Spring 在什么地方开启数据库事务，对于声明式事务，是使用@Transactional进行标注的，这个注解可以标注在类或者方法上，当它标注在类上的时候，代表这个类的所有公共非静态方法都将启用事务功能，在@Transactional中，还允许配置了许多属性，比如说事务的隔离级别和传播行为(这2个概念后续会说到)，在比如说异常类型，从而确定方法发生什么异常时回滚事务 或者说什么异常时不回滚事务。这些配置的内容，是在Spring IoC容器在加载的时候就会把这些信息解析出来了，然后把这些信息存到事务定义器(TransactionDefinition接口的实现类中)并且记录哪些类或者方法需要开启事务，采用什么策略去执行事务，这个过程我们就只需要给<strong>Transactional</strong>配置属性而已。</p><p>当Spring 的上下文开始被@Transactional标注的类或者方法的时候，Spring就会产生AOP的功能，当它启动事务的时候，就会根据事务定义器里的配置去设置事务，首先是根据传播行为去确定事务的策略，然后是隔离级别、超时时间、只读等内容，这些都是Spring事务拦截器通过我们对于@Transactional配置的内容来完成的。<br>当执行SQL发生异常之后，Spring数据库拦截器就会根据我们的配置去判断是提交事务 还是回滚(默认不配置的话是回滚)，无论发生异常与否，Spring都会释放事务资源，这样就可以保证数据库连接池正常可用了，这也是由Spring事务拦截器完成的内容。</p><h3 id="Transactional的配置项"><a href="#Transactional的配置项" class="headerlink" title="@Transactional的配置项"></a>@Transactional的配置项</h3><p>数据库的事务属性都是可以通过@Transactional来配置的，下面先来看一下其源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Transactional &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 通过Bean name 来指定事务管理器</span><br><span class="line">        * @see <span class="comment">#transactionManager</span></span><br><span class="line">        */</span><br><span class="line">       @AliasFor(<span class="string">"transactionManager"</span>)</span><br><span class="line">       String value() default <span class="string">""</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 同value属性</span><br><span class="line">        * @since 4.2</span><br><span class="line">        * @see <span class="comment">#value</span></span><br><span class="line">        */</span><br><span class="line">       @AliasFor(<span class="string">"value"</span>)</span><br><span class="line">       String transactionManager() default <span class="string">""</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 指定传播行为</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getPropagationBehavior()</span></span><br><span class="line">        */</span><br><span class="line">       Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line">       /**</span><br><span class="line">        * 指定隔离级别</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getIsolationLevel()</span></span><br><span class="line">        * @see org.springframework.transaction.support.AbstractPlatformTransactionManager<span class="comment">#setValidateExistingTransaction</span></span><br><span class="line">        */</span><br><span class="line">       Isolation isolation() default Isolation.DEFAULT;</span><br><span class="line">       /**</span><br><span class="line">        * 指定超时时间(单位秒)</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#getTimeout()</span></span><br><span class="line">        */</span><br><span class="line">       int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line">       /**</span><br><span class="line">        * 是否只读事务</span><br><span class="line">        * @see org.springframework.transaction.interceptor.TransactionAttribute<span class="comment">#isReadOnly()</span></span><br><span class="line">        * @see org.springframework.transaction.support.TransactionSynchronizationManager<span class="comment">#isCurrentTransactionReadOnly()</span></span><br><span class="line">        */</span><br><span class="line">       boolean readOnly() default <span class="literal">false</span>;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常时回滚，默认所有都回滚</span><br><span class="line">        * @see <span class="comment">#rollbackForClassName</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        *方法在发生指定异常名称时回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#rollbackFor</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       String[] rollbackForClassName() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常时不回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#noRollbackForClassName</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line">       /**</span><br><span class="line">        * 方法在发生指定异常名称时不回滚，默认所有异常都回滚</span><br><span class="line">        * @see <span class="comment">#noRollbackFor</span></span><br><span class="line">        * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute<span class="comment">#rollbackOn(Throwable)</span></span><br><span class="line">        */</span><br><span class="line">       String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是<strong>propagation</strong>和<strong>isolation</strong> 这2个属性，这两个属性是指传播行为和隔离级别，它需要了解数据库特性才能使用，也是企业最为关心的内容之一。<br>关于注解@Transactional  其实它是可以放到接口上的，也可以放在实现类上，只不过Spring推荐我们放在实现类上，因为放在接口上将使得你的类基于接口的代理时他们才会生效，在AOP中，Spring可以使用JDK动态代理，也可以使用CGLIG动态代理，如果使用接口，那么将不能使用CGLIG代理….</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID："><a href="#数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID：" class="headerlink" title="数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID："></a>数据库事务的基本知识，数据库事务具有4个基本特征，也就是ACID：</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a><strong>原子性（Atomicity）</strong></h4><p>　　<br>      原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a><strong>一致性（Consistency）</strong></h4><p>　　<br>     一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>    拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a><strong>隔离性（Isolation）</strong></h4><p>   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　<br>   即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　<br>   关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a><strong>持久性（Durability）</strong></h4><p>　　<br>  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h3 id="两类丢失更新"><a href="#两类丢失更新" class="headerlink" title="两类丢失更新"></a>两类丢失更新</h3><p><img src="/images/SpringBoot/SpringBoot5/sp5-1.png"></p><p>在第二类对视更新中，为了压制丢失更新，数据库标准提出了4类隔离级别，不同程度的压制丢失更新，这4类隔离级别分别是未提交读，读写提交，可重复读和串行化，他们会在不同程度上压制丢失更新的情景。</p><p>4个隔离级别对于压制丢失更新的程度是不同的，同样对服务器的性能影响也是不同的，现有的技术中有完全可以避免丢失更新的情况，但是这种情况要付出锁的代价，即在同一时间只有一个县城可以访问数据，这样在高并发的情况下，会导致大量线程被挂起和恢复，整个系统会十分缓慢。用户体验极差~</p><h3 id="4种隔离级别的区别："><a href="#4种隔离级别的区别：" class="headerlink" title="4种隔离级别的区别："></a>4种隔离级别的区别：</h3><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读:"></a>未提交读:</h4><p>   未提交读是最低级别的隔离级别，其含义是允许一个事务读取另一个事务中未提交的事务，未提交读是一种危险的隔离级别，所以一般在实际开发应用中不多，但是它的优点在于并发能力高，适合那些对于数据一致性没有要求而追求高并发的场景，它最大的坏处就是出现脏读。</p><p><img src="/images/SpringBoot/SpringBoot5/sp5-2.png"></p><p>如图，当T3时刻，由于采用了未提交读，所以事务2可以读取事务1中未提交的库存数据为1，这里当他扣除库存后数据为0，然后它提交了事务，然后事务1在T5时刻回滚了事务，最后的结果就变成了0，这样就出现了错误。<br>        脏读一般是比较危险的隔离级别，在实际应用中并不多，为了克服脏读，数据库隔离级别还提供了读写提交。</p><h4 id="读写提交"><a href="#读写提交" class="headerlink" title="读写提交:"></a>读写提交:</h4><p>读写提交是指一个事务只能读取另一个事务中已提交的数据，不能读取未提交的数据，可以克服脏读。<br><img src="/images/SpringBoot/SpringBoot5/sp5-3.png"></p><p>但是读写提交也会出现上面描述的问题，这就是我最开始想到的，一个事务执行到一半的时候另外一个事务进来了，这样的update操作可能会出现错误。<br>为了克服这个不足，数据库还提出了可重复读。</p><h4 id="可重复读："><a href="#可重复读：" class="headerlink" title="可重复读："></a>可重复读：</h4><p>可重复读是为了克服读写提交中的不可重复读的现象，因为在读写提交的时候，有些值的变化，影响当前事务的执行，如上述库存是个变化的值。</p><p>   简单点来说，就是当一个事务未提交的时候(特指增删改，查询时不会影响其他事务的读取)，数据库将会阻止其他事务对于数据的读取，只有当前第一个事务提交了之后，事务2才会读取库存的值。但是会引发新的问题：幻读：<br>上图~(其实这些东西主要以理解为主，至于我用图是因为我觉得不至于为了这些概念而单独打出来这些东西，理解第一)<br><img src="/images/SpringBoot/SpringBoot5/sp5-4.png"></p><h4 id="串行化："><a href="#串行化：" class="headerlink" title="串行化："></a>串行化：</h4><p>串行化是数据库最高的隔离级别，他要求所有的SQL都按照顺序执行，可以完全保证数据的一致性，但由于单线程锁，导致性能降低很多，可能会导致系统十分慢。</p><h3 id="使用隔离级别"><a href="#使用隔离级别" class="headerlink" title="使用隔离级别"></a>使用隔离级别</h3><p>之前也说过了，使用这些只需要在注解中添加配置即可，剩下的由Spring完成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(isolation=Isolation.SERIALIZABLE)</span><br><span class="line">@Override</span><br><span class="line">public int delete(String appid) &#123;</span><br><span class="line">       log.info(<span class="string">"进入 delete 方法"</span>);</span><br><span class="line">       <span class="built_in">return</span> routeDao.deleteByAppid(appid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果说一个一个方法单独制定隔离级别太麻烦 可以在配置文件中统一指定</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">        tomcat:</span><br><span class="line">        <span class="comment">#指定数据源默认隔离级别；</span></span><br><span class="line">        <span class="comment">#-1：数据库默认隔离级别</span></span><br><span class="line">        <span class="comment">#1 未提交读</span></span><br><span class="line">        <span class="comment">#2，读写提交</span></span><br><span class="line">        <span class="comment">#4 可重复读</span></span><br><span class="line">        <span class="comment">#8  串行化</span></span><br><span class="line">          default-transaction-isolation: 2</span><br></pre></td></tr></table></figure></p><h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><p>传播行为是指方法之间调用事务才去的策略问题，在默认情况下，一个事务调用的所有方法，要么一起成功，要么所有都失败，但是在实际过程中，比如有1000条数据，成功了900条，这时候如果全部回滚的话 这900条成功的数据也就回滚了，此时，我们的真实需求是 如果发生异常，则异常的数据不提交数据，也就是只回滚这些有问题的数据，那些正常的数据正常的提交事务。</p><p>在Spring中，当一个方法调用另外一个方法的时候，可以让事务才去不同的策略工作，比如新建事务或者挂起事务，这就是事务的传播行为。比如说我们在一个事务中for循环批量插入一千条数据，这当每一条数据插入时，这可以理解成整个事务的单个方法，这个方法执行时，可以让这个当个方法不在当前事务中执行，而是单独的信件一个事务去执行方法，我们就会将当前方法调用资方的传播行为为信件事务，此外，还可以让子方法在无事务、独立事务中执行，这完全取决于你的业务需求</p><p>在Spring事务机制中，对于数据存在七中传播行为，它通过枚举类Propagation定义的，下面放源代码！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public  enum Propagation &#123;       </span><br><span class="line">       /**</span><br><span class="line">        * 需要事务，它是默认的传播行为，如果当前存在事务，就沿用当前事务</span><br><span class="line">        * 否则就新建一个事务运行子方法</span><br><span class="line">        */</span><br><span class="line">       REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">       /**</span><br><span class="line">        * 支持事务，如果当前存在事务，就沿用当前事务</span><br><span class="line">        * 如果不存在，则继续采用无事务的方式运行子方法</span><br><span class="line">        */</span><br><span class="line">       SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">       /**</span><br><span class="line">        * 必须使用事务，如果当前没有事务，则会抛出异常</span><br><span class="line">        * 如果存在事务，则沿用当前事务</span><br><span class="line">        */</span><br><span class="line">       MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">       /**</span><br><span class="line">        * 无论当前事务是否存在，都会创建新的事务运行方法，这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立</span><br><span class="line">        */</span><br><span class="line">       REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">       /**</span><br><span class="line">        * 不支持事务，如果当前存在事务将挂起事务，运行方法</span><br><span class="line">        */</span><br><span class="line">       NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">       /**</span><br><span class="line">        * 不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行</span><br><span class="line">        */</span><br><span class="line">       NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">       /**</span><br><span class="line">        * 在当前方法调用子方法时，如果子方法发生异常，只回滚子方法执行的SQL，而不回滚当前方法的事务</span><br><span class="line">        */</span><br><span class="line">       NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line">       private final int value;</span><br><span class="line">       Propagation(int value) &#123; this.value = value; &#125;</span><br><span class="line">       public int <span class="function"><span class="title">value</span></span>() &#123; <span class="built_in">return</span> this.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的也就是 <strong>NESTED(TransactionDefinition.PROPAGATION_NESTED)</strong><br><strong>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)</strong><br><strong>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)</strong></p><p>接下来通过测试来理解几种常用的传播行为</p><h4 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED:"></a><strong>REQUIRED:</strong></h4><p>需要事务，它是默认的传播行为，如果当前存在事务，就沿用当前事务,否则就新建一个事务运行子方法</p><h4 id="Mapper文件编写"><a href="#Mapper文件编写" class="headerlink" title="Mapper文件编写"></a>Mapper文件编写</h4><p><strong>注意:</strong> mapper文件要注意的是在默认执行student赋值的时候，如果不加后面的jdbcTYPE=XXX  会报错无效的列类型..因为他无法默认给你识别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.wangshun.leaning.dao.IStudentDao"</span> &gt;</span><br><span class="line">  &lt;sql id=<span class="string">"BASE_TABLE"</span>&gt;</span><br><span class="line">    student</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;sql id=<span class="string">"BASE_COLUMN"</span>&gt;</span><br><span class="line">    id,name,age,sex</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"student"</span>&gt;</span><br><span class="line">      SELECT</span><br><span class="line">        &lt;include refid=<span class="string">"BASE_COLUMN"</span>/&gt;</span><br><span class="line">      FROM</span><br><span class="line">        &lt;include refid=<span class="string">"BASE_TABLE"</span>/&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">  &lt;insert id=<span class="string">"saveOrUpdate"</span> parameterType=<span class="string">"student"</span>&gt;</span><br><span class="line">    insert into student(id,name,age,sex) VALUES(<span class="comment">#&#123;id,jdbcType=NUMERIC&#125;,#&#123;name,jdbcType=VARCHAR&#125;,#&#123;age,jdbcType=VARCHAR&#125;,#&#123;sex,jdbcType=VARCHAR&#125;)</span></span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><p><strong>注意:</strong> @Alias(“student”) 注解的使用，这个注解必须配合配置文件中的自动扫描 才能使用，否则在mapper文件中是无法使用类别名的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Alias(<span class="string">"student"</span>)</span><br><span class="line">public class Student &#123;</span><br><span class="line">       private int id;</span><br><span class="line">       private String name;</span><br><span class="line">       private String age;</span><br><span class="line">       private String sex;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       public int <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> id;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setId(int id) &#123;</span><br><span class="line">              this.id = id;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> name;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setName(String name) &#123;</span><br><span class="line">              this.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> age;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setAge(String age) &#123;</span><br><span class="line">              this.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">       public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">              <span class="built_in">return</span> sex;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setSex(String sex) &#123;</span><br><span class="line">              this.sex = sex;</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><strong>注意：</strong>配置文件中要注意2个点，一个是日志配置中必须吧springframework  这个的日志打开，否则是看不到测试结果的，第二个就是在Mybatis配置中type-aliases-package: com.wangshun.leaning.entity  # 注意：对应实体类的路径 这个必须和实体类路径必须和你@Alias注解所在的包对应才，这个@Alias 注解才能生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">        tomcat:</span><br><span class="line">        <span class="comment">#指定数据源默认隔离级别；</span></span><br><span class="line">        <span class="comment">#-1：数据库默认隔离级别</span></span><br><span class="line">        <span class="comment">#1 未提交读</span></span><br><span class="line">        <span class="comment">#2，读写提交</span></span><br><span class="line">        <span class="comment">#4 可重复读</span></span><br><span class="line">        <span class="comment">#8  串行化</span></span><br><span class="line">          default-transaction-isolation: 2</span><br><span class="line">        name: oracle_test</span><br><span class="line">        <span class="built_in">type</span>: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">        <span class="comment">#druid相关配置</span></span><br><span class="line">        druid:</span><br><span class="line">          <span class="comment">#监控统计拦截的filters</span></span><br><span class="line">          filters: <span class="built_in">stat</span></span><br><span class="line">          driver-class-name: oracle.jdbc.OracleDriver</span><br><span class="line">          <span class="comment">#基本属性</span></span><br><span class="line">          url: jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class="line">          username: weblogic</span><br><span class="line">          password: password1</span><br><span class="line">          <span class="comment">#配置初始化大小/最小/最大</span></span><br><span class="line">          initial-size: 1</span><br><span class="line">          min-idle: 1</span><br><span class="line">          max-active: 20</span><br><span class="line">          <span class="comment">#获取连接等待超时时间</span></span><br><span class="line">          max-wait: 60000</span><br><span class="line">          <span class="comment">#间隔多久进行一次检测，检测需要关闭的空闲连接</span></span><br><span class="line">          time-between-eviction-runs-millis: 60000</span><br><span class="line">          <span class="comment">#一个连接在池中最小生存的时间</span></span><br><span class="line">          min-evictable-idle-time-millis: 300000</span><br><span class="line">          validation-query: SELECT <span class="string">'x'</span> FROM DUAL</span><br><span class="line">          <span class="built_in">test</span>-while-idle: <span class="literal">true</span></span><br><span class="line">          <span class="built_in">test</span>-on-borrow: <span class="literal">false</span></span><br><span class="line">          <span class="built_in">test</span>-on-return: <span class="literal">false</span></span><br><span class="line">          <span class="comment">#打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false</span></span><br><span class="line">          pool-prepared-statements: <span class="literal">true</span></span><br><span class="line">          max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line"><span class="comment">##日志配置,这里只是写了显示日志，后面服务器需要可能需要记录日志可以参考battch的博客</span></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: warn</span><br><span class="line">    <span class="comment">#设置Mybatis打印Sql,下面的包是dao层的包路径，不是mapper的路径</span></span><br><span class="line">    com.wangshun.leaning.dao: DEBUG</span><br><span class="line">    org:</span><br><span class="line">      mybatis: INFO</span><br><span class="line">      springframework: debug</span><br><span class="line">       </span><br><span class="line"><span class="comment">## Mybatis 配置</span></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml  <span class="comment">#注意：一定要对应mapper映射xml文件的所在路径</span></span><br><span class="line">  <span class="built_in">type</span>-aliases-package: com.wangshun.leaning.entity  <span class="comment"># 注意：对应实体类的路径</span></span><br><span class="line">  <span class="comment">#驼峰命名规范 如：数据库字段是  order_id 那么 实体字段就要写成 orderId，</span></span><br><span class="line">  <span class="comment">#这个配置是为我们简化ResultMap的配置</span></span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface IStudentDao &#123;</span><br><span class="line">       </span><br><span class="line">       List&lt;Student&gt; selectAll();</span><br><span class="line">       </span><br><span class="line">       int saveOrUpdate(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service实现类"><a href="#service实现类" class="headerlink" title="service实现类"></a>service实现类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量类BatchService"><a href="#批量类BatchService" class="headerlink" title="批量类BatchService"></a>批量类BatchService</h4><p>这里是需要2个service的，之前也说了 传播行为是方法与方法之间的，同样这里添加事务注解，并且声明传播行为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BatchStudentImpl implements IBatchStudent&#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       IStudneService stuentService;</span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation=Propagation.REQUIRED)</span><br><span class="line">       public int saveOrUpdate(List&lt;Student&gt; students) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">                     stuentService.saveOrUpdate(student);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">return</span> 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class StudentController &#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       IBatchStudent batchStudent;</span><br><span class="line">       </span><br><span class="line">       /**</span><br><span class="line">        * 测试数据库传播行为</span><br><span class="line">        * @<span class="built_in">return</span></span><br><span class="line">        */</span><br><span class="line">       @GetMapping(<span class="string">"/insertStudents.do"</span>)</span><br><span class="line">       @ResponseBody</span><br><span class="line">       public String <span class="function"><span class="title">insert</span></span>() &#123;</span><br><span class="line">              List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();</span><br><span class="line">              <span class="keyword">for</span>(int i = 0;i&lt;=3;i++) &#123;</span><br><span class="line">                     Student student = new Student();</span><br><span class="line">                     student.setId(i);</span><br><span class="line">                     student.setName(<span class="string">"张三"</span>+i);</span><br><span class="line">                     student.setAge(<span class="string">""</span>+i);</span><br><span class="line">                     list.add(student);</span><br><span class="line">              &#125;</span><br><span class="line">              batchStudent.saveOrUpdate(list);</span><br><span class="line">              <span class="built_in">return</span> <span class="string">"success"</span>;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码 执行<a href="http://localhost:8080/insertStudents.do" target="_blank" rel="noopener">http://localhost:8080/insertStudents.do</a><br>后台日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:03:56.227 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.227 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.228 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 0(Integer), 张三0(String), 0(String), null</span><br><span class="line">2018-12-20 23:03:56.229 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.231 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 1(Integer), 张三1(String), 1(String), null</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:03:56.232 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:03:56.233 DEBUG 16864 --- [nio-8080-exec-3] o.s.j.d.DataSourceTransactionManager     : Participating <span class="keyword">in</span> existing transaction</span><br><span class="line">2018-12-20 23:03:56.233 DEBUG 16864 --- [nio-8080-exec-3] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br></pre></td></tr></table></figure></p><p>注意这个：Participating in existing transaction<br>也就是说 它这里执行后面的sql还是沿用的之前的事务。</p><h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p>改动的代码也就是单条插入的那个service 的实现类中的事务标注的设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:23:03.360  INFO 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2018-12-20 23:23:03.361 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Detected StandardServletMultipartResolver</span><br><span class="line">2018-12-20 23:23:03.373 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : enableLoggingRequestDetails=<span class="string">'false'</span>: request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data</span><br><span class="line">2018-12-20 23:23:03.373  INFO 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 12 ms</span><br><span class="line">2018-12-20 23:23:03.392 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET <span class="string">"/insertStudents.do"</span>, parameters=&#123;&#125;</span><br><span class="line">2018-12-20 23:23:03.400 DEBUG 16640 --- [nio-8080-exec-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to public java.lang.String com.wangshun.leaning.controller.StudentController.insert()</span><br><span class="line"><span class="comment">#创建当前方法事务(com.wangshun.leaning.service.impl.BatchStudentImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.419 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [com.wangshun.leaning.service.impl.BatchStudentImpl.saveOrUpdate]: PROPAGATION_REQUIRED,ISOLATION_READ_COMMITTED</span><br><span class="line">2018-12-20 23:23:03.425 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#设置当前事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.433 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] to 2</span><br><span class="line">2018-12-20 23:23:03.433 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] to manual commit</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.439 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.497 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.499 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.499 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.543 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.658 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 0(Integer), 张三0(String), 0(String), null</span><br><span class="line">2018-12-20 23:23:03.665 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.667 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.667 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.670 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.671 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 1(Integer), 张三1(String), 1(String), null</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.672 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line"><span class="comment">#更改子方法事务的隔离级别</span></span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.704 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.705 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line"><span class="comment">#创建子方法事务(com.wangshun.leaning.service.impl.StudentServiceImpl类的saveOrUpdate方法)</span></span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] <span class="keyword">for</span> JDBC transaction</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Changing isolation level of JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to 2</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] to manual commit</span><br><span class="line">2018-12-20 23:23:03.706 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 3(Integer), 张三3(String), 3(String), null</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.707 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9]</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@a888ec9] after transaction</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.708 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885]</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@6ac5a885] after transaction</span><br><span class="line">2018-12-20 23:23:03.709 DEBUG 16640 --- [nio-8080-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource</span><br><span class="line">2018-12-20 23:23:03.721 DEBUG 16640 --- [nio-8080-exec-1] m.m.a.RequestResponseBodyMethodProcessor : Using <span class="string">'text/html'</span>, given [text/html, application/xhtml+xml, image/webp, image/apng, application/xml;q=0.9, */*;q=0.8] and supported [text/plain, */*, text/plain, */*, application/json, application/*+json, application/json, application/*+json]</span><br><span class="line">2018-12-20 23:23:03.722 DEBUG 16640 --- [nio-8080-exec-1] m.m.a.RequestResponseBodyMethodProcessor : Writing [<span class="string">"success"</span>]</span><br><span class="line">2018-12-20 23:23:03.730 DEBUG 16640 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2018-12-20 23:23:03.755 DEBUG 16640 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : GET <span class="string">"/favicon.ico"</span>, parameters=&#123;&#125;</span><br><span class="line">2018-12-20 23:23:03.757 DEBUG 16640 --- [nio-8080-exec-2] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped to ResourceHttpRequestHandler [class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/], ServletContext resource [/], class path resource []]</span><br><span class="line">2018-12-20 23:23:03.790 DEBUG 16640 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br></pre></td></tr></table></figure><p>通过上图的测试结果可以看出来，每次执行新增操作的时候，它都是启用一个新的数据库事务去执行这个saveOrUpdate方法，并且独立提交，完全脱离了原本事务的管控，每一个事务都可以拥有自己独立的隔离级别和锁。</p><h4 id="Propagation-NESTED"><a href="#Propagation-NESTED" class="headerlink" title="Propagation.NESTED"></a>Propagation.NESTED</h4><p>修改的代码部分依旧只有传播行为的属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl implements IStudneService&#123;</span><br><span class="line">       </span><br><span class="line">       @Autowired</span><br><span class="line">       IStudentDao studentDao;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       @Override</span><br><span class="line">       @Transactional(isolation=Isolation.READ_COMMITTED,propagation = Propagation.NESTED)</span><br><span class="line">       public int saveOrUpdate(Student student) &#123;</span><br><span class="line">              <span class="built_in">return</span> studentDao.saveOrUpdate(student);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 23:42:59.252 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.DataSourceTransactionManager     : Creating nested transaction with name [com.wangshun.leaning.service.impl.StudentServiceImpl.saveOrUpdate]</span><br><span class="line">2018-12-20 23:42:59.253 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt;  Preparing: insert into student(id,name,age,sex) VALUES(?,?,?,?)</span><br><span class="line">2018-12-20 23:42:59.253 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : ==&gt; Parameters: 2(Integer), 张三2(String), 2(String), null</span><br><span class="line">2018-12-20 23:42:59.254 DEBUG 6104 --- [nio-8080-exec-2] c.w.l.dao.IStudentDao.saveOrUpdate       : &lt;==    Updates: 1</span><br><span class="line">2018-12-20 23:42:59.254 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.DataSourceTransactionManager     : Releasing transaction savepoint</span><br><span class="line">2018-12-20 23:42:59.256 DEBUG 6104 --- [nio-8080-exec-2] o.s.j.d.JdbcTransactionObjectSupport     : Could not explicitly release JDBC savepoint</span><br><span class="line">java.sql.SQLFeatureNotSupportedException: 不支持的特性</span><br></pre></td></tr></table></figure><p>虽然说不支持吧…但是可以看到SQL异常之前的的savepoint<br>这个的意思是标志位<br>他的意思就是说 每一条数据执行完之后都会设置一个标志位，如果后面的数据发生异常，那么就会回滚到当前标志位的数据状态，而不是让所有的数据也回滚。<br>这个标志位在数据库中的名词叫做保存点(save point)</p><h4 id="最后说一点"><a href="#最后说一点" class="headerlink" title="最后说一点"></a>最后说一点</h4><p>NESTED和REQUIRES_NEW 还是有很大的区别的  前者会沿用之前设计的锁和隔离级别，而后者可以完全脱离原本自己设定新的锁和隔离级别</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在互联网的数据库的使用中，对于电商和金融网站，最关注的就是数据库事务，对于热门商品的交易和库存以及金融产品的金额，是不允许发生错误的，当热门商品的抢购时，面临高并发的时候，这时候数据库事务处理就显得格外重要了&lt;/p&gt;
&lt;p&gt;对于事务处理最简单的理解就是当高并发的时候对于数据库事务处理机制，此时数据库将在一个多事务的场景下运行。&lt;/p&gt;
&lt;p&gt;说到事务处理，我的第一反应就是@Transactional这个注解&lt;br&gt;这个注解当时只学习了放到方法上，那么今天就来对这个注解以及背后的数据库事务进行深一步的了解…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(4)访问数据库</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-4-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-4-访问数据库/</id>
    <published>2018-12-23T11:24:11.000Z</published>
    <updated>2018-12-23T13:01:21.919Z</updated>
    
    <content type="html"><![CDATA[<p>关于持久层框架  常用的比如说Hibernate、Mybatis<br>由于现在主流的框架是MyBatis，所以这里就简单说一下MyBatis</p><p>简介：<br>    MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录……….<a id="more"></a></p><p>默认的Spring是不支持Mybatis的，但是Mybatis社区自己整合了Spring并提供出来jar包，所以我们可以在POM文件中添加依赖来使用MyBatis</p><h3 id="在pom文件中添加依赖"><a href="#在pom文件中添加依赖" class="headerlink" title="在pom文件中添加依赖"></a>在pom文件中添加依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--MyBatis基础包  --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>MyBatis是一种基于SqlSessionFactory构建的框架。对于SqlSessionFactory而言，它的作用是生成SqlSession接口对象，这个对象是MyBatis操作的核心 </p><h3 id="属性文件配置"><a href="#属性文件配置" class="headerlink" title="属性文件配置"></a>属性文件配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 该配置节点为独立的节点，不在spring的节点下</span></span><br><span class="line"><span class="comment">## Mybatis 配置</span></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml  <span class="comment">#注意：一定要对应mapper映射xml文件的所在路径</span></span><br><span class="line">  <span class="built_in">type</span>-aliases-package: com.ithwua.entity  <span class="comment"># 注意：对应实体类的路径,配合@Alias注解使用</span></span><br><span class="line">  <span class="comment">#驼峰命名规范 如：数据库字段是  order_id 那么 实体字段就要写成 orderId，</span></span><br><span class="line">  <span class="comment">#这个配置是为我们简化ResultMap的配置</span></span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="使用Mybatis注解实现类别名"><a href="#使用Mybatis注解实现类别名" class="headerlink" title="使用Mybatis注解实现类别名"></a>使用Mybatis注解实现类别名</h3><p>类别名也就是在类的上方使用@Alias(“别名”)，这样的话在对应的mapper文件中 resultType 就可以写成别名了，就不需要从包开始全部写完了。</p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Alias(<span class="string">"user"</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line">       </span><br><span class="line">       private Long id;</span><br><span class="line">       private String user_name;</span><br><span class="line">       private String password;</span><br><span class="line">       //省略get  <span class="built_in">set</span> 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Mapper文件"><a href="#编写Mapper文件" class="headerlink" title="编写Mapper文件"></a>编写Mapper文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.ekingwin.bas.cloud.project.basi.srvgov.dao.PrepareServiceInfoDao"</span> &gt;</span><br><span class="line"></span><br><span class="line">  &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"user"</span>&gt;</span><br><span class="line">       select id,user_name as userName,password from User</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>这里的Mapper 中有几个需要注意的</p><p>1.<strong>namespace</strong>:   这个就是指接口的路径，下面的ID就会和这个接口中的方法名进行匹配。</p><p>2.<strong>select</strong> : 标明这是一个查询SQL</p><p>3.<strong>select</strong>中的id：与上面namespace指的接口中的方法名对应</p><p>4.<strong>resultType</strong>：指定返回集的类型，默认应该是写全名的，这里由于加了@Alias注解，所以可以使用别名user；</p><h3 id="自定义Mybatis插件"><a href="#自定义Mybatis插件" class="headerlink" title="自定义Mybatis插件"></a>自定义Mybatis插件</h3><p>假设存在一个Mybatis插件，其代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(<span class="built_in">type</span>=StatementHandler.class,method=<span class="string">"prepare"</span>,args= &#123;Connection.class,Integer.class&#125;)&#125;)</span><br><span class="line">public class MyPlugin implements Interceptor&#123;</span><br><span class="line">       </span><br><span class="line">       Properties propertise = null;</span><br><span class="line">       </span><br><span class="line">       //拦截器逻辑</span><br><span class="line">       @Override</span><br><span class="line">       public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">              System.out.println(<span class="string">"插件拦截方法"</span>);</span><br><span class="line">              <span class="built_in">return</span> invocation.proceed();//回调方法</span><br><span class="line">       &#125;</span><br><span class="line">       //生成MyBatis拦截器代理对象</span><br><span class="line">       @Override</span><br><span class="line">       public Object plugin(Object target) &#123;</span><br><span class="line">              <span class="built_in">return</span> Plugin.wrap(target, this);</span><br><span class="line">       &#125;</span><br><span class="line">       //设置插件属性</span><br><span class="line">       @Override</span><br><span class="line">       public void setProperties(Properties properties) &#123;</span><br><span class="line">              this.propertise = properties;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一个Mybatis插件就创建出来了，但是没有把他配置到MyBatis中，这个时候完全可以通过application.yml文件中添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br></pre></td></tr></table></figure><p>这样就指定了配置文件的位置，这样我们在对应的路径下创建这个配置值文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">       &lt;plguins&gt;</span><br><span class="line">              &lt;plugin interceptor = <span class="string">"com.wangshun.leaning.plugin.MyPlugin"</span>&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key1"</span> value=<span class="string">"value1"</span>&gt;&lt;/property&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key2"</span> value=<span class="string">"value2"</span>&gt;&lt;/property&gt;</span><br><span class="line">                     &lt;property name=<span class="string">"key3"</span> value=<span class="string">"value3"</span>&gt;&lt;/property&gt;</span><br><span class="line">              &lt;/plugin&gt;</span><br><span class="line">       &lt;/plguins&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这样就可以完成对于mybatis 一些组件的配置了，实际编写中可以按照实际的需求来进行编写。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于持久层框架  常用的比如说Hibernate、Mybatis&lt;br&gt;由于现在主流的框架是MyBatis，所以这里就简单说一下MyBatis&lt;/p&gt;
&lt;p&gt;简介：&lt;br&gt;    MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录……….
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(3)AOP编程</title>
    <link href="http://yoursite.com/2018/12/23/SpringBoot-3-AOP%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/23/SpringBoot-3-AOP编程/</id>
    <published>2018-12-23T03:29:24.000Z</published>
    <updated>2018-12-23T12:23:10.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP理论"><a href="#AOP理论" class="headerlink" title="AOP理论"></a>AOP理论</h2><h3 id="AOP的概念："><a href="#AOP的概念：" class="headerlink" title="AOP的概念："></a>AOP的概念：</h3><p>面向切面编程，其实也就是一定的规则，我就可以把代码织入到事先约定好的流程中。实际上Spring AOP 也是一种约定流程编程…..<a id="more"></a></p><h3 id="为什么要使用AOP"><a href="#为什么要使用AOP" class="headerlink" title="为什么要使用AOP"></a>为什么要使用AOP</h3><p>AOP最为典型的应用就是数据库事务的管控，比如我们要保存一个用户的信息的时候，也需要把这个用户的角色信息保存了(2张表)，如果说数据库事务中的要求是 要么一起成功，要么一起失败的时候，这种情况下OOP是做不到的，那么使用AOP就可以解决这个问题。<br>再比如写入数据库这个操作的过程应该是：获取数据库连接–&gt;执行Sql–&gt;提交事务(或者回滚事务)–&gt;释放数据库连接<br>关于获取连接、提交、释放数据库连接这种重复的操作，就可以使用流程去实现，而不同的地方就在于编写SQL，其实在Spring中有大量的这样类似的代码。<br>比如我们经常会使用的一个事务注解：<strong>@Transactional</strong>,   这个注解就是标明此方法需要事务运行，并没有任何关于数据库打开和关闭的代码，也没有提交和回滚的代码，但是还是实现了这些功能，大致就是Spring帮你把写入的方法织入流程中，而那些 事务操作都帮你默认实现了，也就是它可以把大量重复的流程通过约定的方式抽象出来，然后给予默认的实现，，可见它可以帮助我们减少大量的代码，尤其是那些try….catch…..</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>1.连接点（join point）：对应具体的被拦截的对象，由于Spring只支持方法，所以被拦截的对象往往是指特定的方法。此方法为一个连接点，AOP通过动态代理技术把它织入到对应流程中。</p><p>2.切点(point cut):有时候，我们的切面不单单应用于单个方法，也可能是多各类不同的方法，这时，可以通过正则表达式和指示器的规则去定义，从而适配连接点，切点就是提供这个功能的概念。</p><p>3.通知(advice):就是按照约定的流程下的方法，分为前置通知(before advice) 后置通知(after advice) 环绕通知(around advice) 事后返回通知(afterReturning advice) 和异常通知(afterThrowing advice),他会根据约定织入流程中，需要弄明白他们在流程中的顺序和运行条件。</p><p>4.目标对象(target) ： 即被代理对象，例如：约定编程中的HelloServiceImpl实例就是一个目标对象，它被代理了。</p><p>5.引入(introduction): 是指引入新的类和方法，增强现有Bean的功能。</p><p>6.织入(weaving): 它是一个通过动态代理技术，为原有服务对象生成代理对象，然后与切点定义匹配的连接点拦截，并按照约束将各类通知织入约定流程的过程。</p><p>7.切面(aspect)： 十四一个可以定义切点、各类通知和引入的内容，Spring AOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。<br><img src="/images/SpringBoot/SpringBoot3/sp3-1.png"></p><h2 id="AOP-小例子"><a href="#AOP-小例子" class="headerlink" title="AOP 小例子"></a>AOP 小例子</h2><h3 id="定义Service接口"><a href="#定义Service接口" class="headerlink" title="定义Service接口"></a>定义Service接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 打印用户信息</span><br><span class="line">        * @param user</span><br><span class="line">        */</span><br><span class="line">       public void printUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void printUser(User user) &#123;</span><br><span class="line">             <span class="keyword">if</span>(user==null) &#123;</span><br><span class="line">                    throw new RuntimeException(<span class="string">"检查用户名参数为空"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">"id:"</span>+user.getId());</span><br><span class="line">             System.out.println(<span class="string">"userName:"</span>+ user.getUserName());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">       @Pointcut(<span class="string">"execution(*com.wangshun.leaning.chapter4.service.UserService(..))"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">pointCut</span></span>() &#123;&#125;</span><br><span class="line">       @Before(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public boolean <span class="function"><span class="title">before</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">             <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       @After(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">after</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"after....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       @AfterReturning(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">afterReturning</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"afterReturning....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       @AfterThrowing(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void <span class="function"><span class="title">afterThrowing</span></span>() &#123;</span><br><span class="line">             System.out.println(<span class="string">"afterThrowing....."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Aspect</strong> 这个注解也就是声明切面的一个注解，就相当于是告诉Spring，这是一个切面。然后@Before 那些注解就和AOP的概念一样的意思，比如前置通知之类的…</p><p><strong>@Pointcut</strong> 此注解用于定义切点，它被标注在方法pointCut上，则后面的通知注解中就可以使用方法的名称来定义了其含义就是对这个切点的引用，而这个注解里面的正则表达式就是告诉Spring 哪些方法需要进行AOP编程</p><p><strong>正则表达式 execution(* com.wangshun.leaning.chapter4.service.UserServiceImpl.printUser(..))</strong></p><p>execution表示在执行的时候，拦截里面的正则匹配的方法;</p><p>*表示任意返回类型的方法;</p><p>com.wangshun.leaning.chapter4.service.UserServiceImpl 指定目标对象的全限定名称;</p><p>printUser 指定目标对象的方法;</p><p>(..)表示任意参数进行匹配。</p><p>这样Spring就可以通过这个正则表达式知道你需要对UserServiceImpl类的printUser方法进行AOP增强，它就会将正则表达式匹配的方法和对应切面的方法织入到约定流程中，从而完成AOP编程。</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">       @Autowired</span><br><span class="line">       UserService userService;</span><br><span class="line">       </span><br><span class="line">       @GetMapping(<span class="string">"/print"</span>)</span><br><span class="line">       public User printUser(String userName,Long id) &#123;</span><br><span class="line">             User user = new User();</span><br><span class="line">             user.setUserName(userName);</span><br><span class="line">             user.setId(id);</span><br><span class="line">             user.setNote(<span class="string">"note1"</span>);</span><br><span class="line">             userService.printUser(user);</span><br><span class="line">             <span class="built_in">return</span> user;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在地址栏输入：localhost:8080/print，来观察控制台的变化<br><img src="/images/SpringBoot/SpringBoot3/sp3-2.png"><br>从上图中可以看到这个方法被拦截，先执行了before，然后执行我的方法中定义的东西，然后执行了after，没有报错的情况下执行了afterReturning，<strong>注意： after，无论其报错与否都会执行</strong></p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>环绕通知是所有通知中最强大的通知，一般而言，使用它的场景是在你需要大幅度修改原有目标对象的服务逻辑时，环绕通知是一个取代原有目标对象方法的通知，当然它也提供了回调原有目标对象方法的能力~</p><h3 id="在Aspect代码中加入以下部分"><a href="#在Aspect代码中加入以下部分" class="headerlink" title="在Aspect代码中加入以下部分"></a>在Aspect代码中加入以下部分</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Around(<span class="string">"pointCut()"</span>)</span><br><span class="line">       public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">             System.out.println(<span class="string">"around.....before"</span>);</span><br><span class="line">             //回调目标对象的原有方法</span><br><span class="line">             jp.proceed();</span><br><span class="line">             System.out.println(<span class="string">"around.....after"</span>);</span><br><span class="line">             </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/images/SpringBoot/SpringBoot3/sp3-3.png"><br>emmmmm这个和我想要的结果好像不太一样，想的应该是先执行before再执行这个，所以说….谨慎使用吧..要改的逻辑好像挺多的…</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在测试AOP的时候，我们打印了用户信息，如果信息为空，则抛出异常，事实上，假设改一下需求，如果信息为空则不打印，假设这里userService不是自己写的，是外部提供的，我们不能修改他，这时Spring允许增强这个接口的功能，我们可以为这个接口引入新的接口，例如要引入一个用户检测的接口<strong>UserValidator</strong></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface UserValidator &#123;</span><br><span class="line">       </span><br><span class="line">       public boolean validator(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserValidatorImpl implements UserValidator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean validator(User user) &#123;</span><br><span class="line">        System.out.println(<span class="string">"引入新的接口"</span> + UserValidator.class.getSimpleName());</span><br><span class="line">        <span class="built_in">return</span> user !=null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在MyAspect-里面引入新接口"><a href="#在MyAspect-里面引入新接口" class="headerlink" title="在MyAspect 里面引入新接口"></a>在MyAspect 里面引入新接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">       * 引入新接口</span><br><span class="line">       */</span><br><span class="line">      @DeclareParents(value=<span class="string">"com.wangshun.leaning.chapter4.service.impl.UserServiceImpl+"</span>,</span><br><span class="line">                   defaultImpl=UserValidatorImpl.class)</span><br><span class="line">      public UserValidator userValidatorService;</span><br></pre></td></tr></table></figure><p><strong>@DeclareParents</strong> 这个注解的意思就是，它的作用就是引入新的类来增强服务，它有2个必须的属性<strong>value</strong>和<strong>defaultImpl</strong>。</p><p>   <strong>value</strong>:只想你要增强的目标对象，这里要增强的是<br>UserServiceImpl对象，因此可以看到配置为com.wangshun.leaning.chapter4.service.impl.UserServiceImpl+(最后那个+不要忘了)</p><p>   <strong>defaultImpl</strong>：引入增强功能的类，这里配置的是UserValidatorImpl，用来提供校验用户是否为空的功能</p><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/vp"</span>)</span><br><span class="line">      public User validateAndPrint(Long id,String userName,String note) &#123;</span><br><span class="line">            User user = new User();</span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setUserName(userName);</span><br><span class="line">            user.setNote(note);</span><br><span class="line">            //强制转换</span><br><span class="line">            UserValidator userValidatorService = (UserValidator) userService;</span><br><span class="line">            <span class="keyword">if</span>(userValidatorService.validator(user)) &#123;</span><br><span class="line">                   userService.printUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> user;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="增强原理"><a href="#增强原理" class="headerlink" title="增强原理"></a>增强原理</h3><p>之前的代码中有一段生成代理对象的代码为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object proxyObject = Proxy.newProxyInstance(Target.class.getClassLoader(), Target.class.getInterfaces(), proxyBean)</span><br></pre></td></tr></table></figure></p><p>这里的<strong>newProxyInstance</strong>的第二个参数作为一个数组，也就是说这里产生代理对象的时候，会把UserService 和UserValidator2个接口传递进去，让代理对象挂到这2个接口下面，这样这个代理对象就可以相互转换并且使用它们的方法了。</p><p>织入是一个生成动态代理服务对象并且将切面和目标对象方法编织成为约定流程的过程，对于流程上的通知，我们一般采用的是接口+实现类的模式，这是Spring推荐的，但是对于是否拥有接口SpringAOP 是不做强制要求的，对于动态代理也有多种实现的方式，比如CGLIB就是不需要接口的，所以Spring中就会做一个判断 如果是接口+实现类 那就用JDK的实现方式 生成代理 ，如果只有类 没有接口 那就用CGLIB的方式实现。</p><h2 id="通知获取参数"><a href="#通知获取参数" class="headerlink" title="通知获取参数"></a>通知获取参数</h2><p>如果我们需要传递参数给通知，这样也是可以的，只需要在切入点加入对应的正则表达式即可，当然对于非环绕型通知，我们还可以使用一个连接点(JoinPoint)类型的参数来获取参数</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Before(<span class="string">"pointCut() &amp;&amp;args(user)"</span>)</span><br><span class="line">       public boolean before(JoinPoint point,User user) &#123;</span><br><span class="line">              Object[] args = point.getArgs();</span><br><span class="line">              System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">              <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>ps：对于非环绕通知的参数，JoinPoint 是可行的，SpringAOP会把它自动传递到通知中，如果是环绕行通知，则可以使用ProceedingJoinPoint</strong></p><p><strong>对于多个切面同时拦截一个接口的时候 可以使用@order注解去进行排序 ，来决定 多个切面的执行顺序。</strong></p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP理论&quot;&gt;&lt;a href=&quot;#AOP理论&quot; class=&quot;headerlink&quot; title=&quot;AOP理论&quot;&gt;&lt;/a&gt;AOP理论&lt;/h2&gt;&lt;h3 id=&quot;AOP的概念：&quot;&gt;&lt;a href=&quot;#AOP的概念：&quot; class=&quot;headerlink&quot; title=&quot;AOP的概念：&quot;&gt;&lt;/a&gt;AOP的概念：&lt;/h3&gt;&lt;p&gt;面向切面编程，其实也就是一定的规则，我就可以把代码织入到事先约定好的流程中。实际上Spring AOP 也是一种约定流程编程…..
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot(2)SpringBoot日志配置</title>
    <link href="http://yoursite.com/2018/12/23/springBoot-2-SpringBoot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/12/23/springBoot-2-SpringBoot日志配置/</id>
    <published>2018-12-23T03:14:06.000Z</published>
    <updated>2018-12-23T03:27:25.150Z</updated>
    
    <content type="html"><![CDATA[<p>简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程</p><p>很多情况下，我们会需要使用一些日志来查看SpringBoot中的一些东西，比如最常用的就是打印Sql了，在后台显示Sql也可以帮助我们迅速的解决出现的一些Sql问题等等，下面来说说如何在SpringBoot中配置日志……<a id="more"></a></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>首先SpringBoot的日志配置是通过配置文件来完成的，默认支持的两种配置文件分别是properties 和yml。这里推荐使用yml，因为看起来更加简洁、舒适</p><p>显示日志只需要在配置文件中添加以下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##日志配置,这里只是写了显示日志，后面服务器需要可能需要记录日志可以参考battch的博客</span></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    <span class="comment">#root: warn</span></span><br><span class="line">    <span class="comment">#设置Mybatis打印Sql,下面的包是dao层的包路径，不是mapper的路径</span></span><br><span class="line">    com.ithwua.dao: DEBUG</span><br><span class="line">    <span class="comment">#org:</span></span><br><span class="line">      <span class="comment">#hibernate: ERROR</span></span><br><span class="line">      mybatis: INFO</span><br><span class="line">      springframework:</span><br><span class="line">        web: debug</span><br></pre></td></tr></table></figure><h3 id="propertise文件的写法"><a href="#propertise文件的写法" class="headerlink" title="propertise文件的写法:"></a>propertise文件的写法:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root = WARN</span><br><span class="line">logging.level.org.springframework.web = DEBUG</span><br><span class="line">logging.level.org.hibernate = ERROR</span><br><span class="line"></span><br><span class="line"><span class="comment">#比如 mybatis sql日志</span></span><br><span class="line">logging.level.org.mybatis = INFO</span><br><span class="line">logging.level.mapper的Dao所在的包 = DEBUG</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://blog.battcn.com/2018/04/23/springboot/v2-config-logs/" target="_blank" rel="noopener">http://blog.battcn.com/2018/04/23/springboot/v2-config-logs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程&lt;/p&gt;
&lt;p&gt;很多情况下，我们会需要使用一些日志来查看SpringBoot中的一些东西，比如最常用的就是打印Sql了，在后台显示Sql也可以帮助我们迅速的解决出现的一些Sql问题等等，下面来说说如何在SpringBoot中配置日志……
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot(1)使用MyEclipse构建一个SpringBoot</title>
    <link href="http://yoursite.com/2018/12/23/springBoot-1-%E4%BD%BF%E7%94%A8MyEclipse%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AASpringBoot/"/>
    <id>http://yoursite.com/2018/12/23/springBoot-1-使用MyEclipse构建一个SpringBoot/</id>
    <published>2018-12-23T02:38:56.000Z</published>
    <updated>2018-12-23T03:01:18.682Z</updated>
    
    <content type="html"><![CDATA[<p>简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程</p><p>我使用的是MyEclipse2018，接下来就说一下如何使用MyEclipse构建一个SpringBoot项目……<a id="more"></a></p><h3 id="新建Spring-项目"><a href="#新建Spring-项目" class="headerlink" title="新建Spring 项目"></a>新建Spring 项目</h3><p>右击新建一个Spring 项目，搜索Spring，选择Spring Starter Project<br><img src="/images/SpringBoot/SpringBoot1/sp1-1.png"></p><h3 id="输入项目名称-分组-描述-以及起始包"><a href="#输入项目名称-分组-描述-以及起始包" class="headerlink" title="输入项目名称/分组/描述/以及起始包"></a>输入项目名称/分组/描述/以及起始包</h3><p><img src="/images/SpringBoot/SpringBoot1/p2.png"></p><h3 id="选择SpringBoot的版本以及相应的组件-比如web-mybatis等等"><a href="#选择SpringBoot的版本以及相应的组件-比如web-mybatis等等" class="headerlink" title="选择SpringBoot的版本以及相应的组件(比如web/mybatis等等)"></a>选择SpringBoot的版本以及相应的组件(比如web/mybatis等等)</h3><p><img src="/images/SpringBoot/SpringBoot1/p3.png"></p><h3 id="点击finishe即可，其中首次创建会比较慢，因为需要下载jar包-需要提前配置好Maven-。"><a href="#点击finishe即可，其中首次创建会比较慢，因为需要下载jar包-需要提前配置好Maven-。" class="headerlink" title="点击finishe即可，其中首次创建会比较慢，因为需要下载jar包(需要提前配置好Maven)。"></a>点击finishe即可，其中首次创建会比较慢，因为需要下载jar包(需要提前配置好Maven)。</h3><h3 id="可选-为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise-插件参考地址"><a href="#可选-为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise-插件参考地址" class="headerlink" title="(可选) 为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise 插件参考地址"></a>(可选) 为了以后的方便的话，可以去网上安装一些插件，比如说中文propertise 插件<a href="https://blog.csdn.net/qq_31151929/article/details/51121750" target="_blank" rel="noopener">参考地址</a></h3><pre><code>安装完成之后，在windows-&gt;propertise里面选择一下默认即可：</code></pre><p><img src="/images/SpringBoot/SpringBoot1/p4.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程&lt;/p&gt;
&lt;p&gt;我使用的是MyEclipse2018，接下来就说一下如何使用MyEclipse构建一个SpringBoot项目……
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo学习(1)：使用Hexo搭建博客</title>
    <link href="http://yoursite.com/2018/12/21/hello-world/"/>
    <id>http://yoursite.com/2018/12/21/hello-world/</id>
    <published>2018-12-21T15:41:39.000Z</published>
    <updated>2018-12-23T02:51:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>经过一次偶然的机会，我发现了Hexo这个简单快捷的博客框架，这让我想搭建一个博客自己写东西的想法更近了一步，接下来来说说如何使用Hexo 搭建博客…..<a id="more"></a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装Hexo必要的环境"><a href="#安装Hexo必要的环境" class="headerlink" title="安装Hexo必要的环境"></a>安装Hexo必要的环境</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>安装node.js过程暂时省略额<br>确认自己电脑是否安装node.js命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br></pre></td></tr></table></figure></p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>安装git过程暂时省略<br>确认自己电脑是否安装git命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure><h3 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h3><h4 id="使用指令安装Hexo"><a href="#使用指令安装Hexo" class="headerlink" title="使用指令安装Hexo"></a>使用指令安装Hexo</h4><p>确认node  和git 均安装完成后，开始我们的Hexo安装<br>安装的指令也是十分的简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装的过程可能会比较的缓慢，请耐心等待，因为是从gitHub上面下载。<br><img src="/images/HexoExample1/p1.png"><br>2个警告可以不用管</p><h4 id="hexo-初始化"><a href="#hexo-初始化" class="headerlink" title="hexo 初始化"></a>hexo 初始化</h4><p>安装完成后，可以进入指定目录  执行hexo init 也就是初始化，这样它就会在对应的文件夹下，通过git 去下载Hexo所需要的资源，这些资源也是从gitHub上下载的。<br><img src="/images/HexoExample1/p2.png"></p><p>几个警告同样可以不用管，如果是想在当前workspace的下一个文件夹中创建hexo 也可以使用 hexo init test(test就是文件夹的名称)，这样他就会把资源下载到当前目录的test文件夹中，因为一个workspace可能存在多个项目。<br>下载完成后，我们可以使用dir指令来查看究竟下载了那些东西<br><img src="/images/HexoExample1/p3.png">，这些资源是和gitHub上一致的。</p><h4 id="生成Hexo静态页面"><a href="#生成Hexo静态页面" class="headerlink" title="生成Hexo静态页面"></a>生成Hexo静态页面</h4><p>然后使用hexo g 去生成那些个静态页面。<br><img src="/images/HexoExample1/p4.png"></p><p>完成之后可以再次使用dir命令，就可以看到对比刚才，多了一个public文件夹，所有的静态页面的资源都放到这里面了。<br><img src="/images/HexoExample1/p5.png"></p><h4 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h4><p>最后输入以下指令来启动hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p><img src="/images/HexoExample1/p6.png"><br>复制开启后显示的地址，打开浏览器访问即可。<br>就可以看到默认的博客样式了。<br><img src="/images/HexoExample1/p7.png"><br>如果希望更改自己主题以及一些其他的设定请参考<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p><p>参考文档:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过一次偶然的机会，我发现了Hexo这个简单快捷的博客框架，这让我想搭建一个博客自己写东西的想法更近了一步，接下来来说说如何使用Hexo 搭建博客…..
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
