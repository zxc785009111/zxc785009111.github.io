<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王瞬|卡丘</title>
  
  <subtitle>王瞬的私人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-20T16:09:50.597Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王瞬|卡丘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法学习(4)归并排序</title>
    <link href="http://yoursite.com/2019/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/20/算法学习-4-归并排序/</id>
    <published>2019-03-20T15:08:28.000Z</published>
    <updated>2019-03-20T16:09:50.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>归并排序是基于归并操作，简言之就是将两个有序数组归并成一个有序数组。也就是在对于一个数组进行排序之前，可以先(递归地)将这个数组拆分成两个数组分别排序，最后再归并成一个有序数组。<br>它的主要缺点就是所需要的额外空间和数组大小N成正比。</p><h2 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h2><p>实现归并就是将两个有序数组归并到第三个数组中，但是在对于一个大数组进行排序的时候，我们需要很多次归并，这样的情况就是多次创建一个新数组来存储原本的数组值，对于空间消耗较大，而原地归并就是指将数组的前半段排序，再将数组的后半段排序，最后再数组中进行移动，而不需要使用额外的空间。<br>ps:实际这种操作的实现非常复杂…特别是和使用空间来存储的方法相比….但是这种方法的抽象化还是有帮助的.<a id="more"></a></p><h3 id="原地归并抽象方法"><a href="#原地归并抽象方法" class="headerlink" title="原地归并抽象方法"></a>原地归并抽象方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 原地归并算法的抽象方法，适用于将两个不同的有序数组归并到一个新的数组中并保持有序</span><br><span class="line"> * 其原理就是先将所有的元素复制到一个新数组中，然后再归并到原数组中。这样就可以减少归并算法每次归并都需要一个新数组的问题</span><br><span class="line"> * @param a 需要归并的数组</span><br><span class="line"> * @param lo 开始序列</span><br><span class="line"> * @param mid 中间序列</span><br><span class="line"> * @param hi 末尾序列</span><br><span class="line"> */</span><br><span class="line">public static void merga(Comparable [] a,int lo,int mid,int hi) &#123;</span><br><span class="line">int i = lo;</span><br><span class="line">int j = mid+1;</span><br><span class="line">//将原数组复制到一个新的数组中</span><br><span class="line"><span class="keyword">for</span>(int k = 0;k&lt;a.length;k++) &#123;</span><br><span class="line">aux[k] = a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int k = lo;k &lt;= hi;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;mid) &#123;//左边数组的值被取完了，则取右边数组的值</span><br><span class="line">a[k] = aux[j++];//这里是先取的aux[j]的值，再把j+1</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) &#123;//如果右边的值被取完了，则取左边的值。</span><br><span class="line">a[k] = aux[i++];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(less(aux[i], aux[j])) &#123;//右半边当前元素小于左半边。</span><br><span class="line">a[k] = aux[j++];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;//左半边元素小于右半边</span><br><span class="line">a[k] = aux[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于原地归并抽象方法的具体两个实现"><a href="#基于原地归并抽象方法的具体两个实现" class="headerlink" title="基于原地归并抽象方法的具体两个实现"></a>基于原地归并抽象方法的具体两个实现</h2><h3 id="自顶上下归并排序"><a href="#自顶上下归并排序" class="headerlink" title="自顶上下归并排序"></a>自顶上下归并排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.service.impl;</span><br><span class="line">/**</span><br><span class="line"> * 归并算法简介：</span><br><span class="line"> * 优点：它能保证将任意长度为N的数组排序所需要的时间和NlogN成正比。</span><br><span class="line"> * 缺点：他所需要的额外空间和N成正比。</span><br><span class="line"> * 归并算法是一种渐进最优的基于比较排序的算法。</span><br><span class="line"> * </span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年3月19日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class merga &#123;</span><br><span class="line"></span><br><span class="line">private static Comparable [] aux;</span><br><span class="line">public static void sort(Comparable [] a) &#123;</span><br><span class="line">aux = new Comparable [a.length];//一次性分配空间</span><br><span class="line">sort(a, 0, a.length-1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 自顶向下的归并算法。也就大概是归并算法的全过程。</span><br><span class="line"> * 性质：1.对于长度为N的任意数组，自顶向下的归并排序需要1/2NlogN至NlogN次比较</span><br><span class="line"> *    2.对于长度为N的任意数组，自顶向下的归并算法至多需要访问数组6NlogN次</span><br><span class="line"> * @param a</span><br><span class="line"> * @param lo</span><br><span class="line"> * @param hi</span><br><span class="line"> */</span><br><span class="line">public static void sort(Comparable [] a,int lo,int hi) &#123;</span><br><span class="line"><span class="keyword">if</span>(hi&lt;=lo) &#123;</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">int mid = lo + (hi-lo)/2;</span><br><span class="line">sort(a, lo, mid);//将左半边排序</span><br><span class="line">sort(a, mid+1, hi);//将右半边排序</span><br><span class="line">merga(a, lo, mid, hi);//进行原地归并排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 元素比较方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param b</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">private static boolean less(Comparable a,Comparable b) &#123;</span><br><span class="line"><span class="built_in">return</span> b.compareTo(a)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个长度为16个数组，那么这种算法的执行方式就是：<br>sort(a,0,15)–&gt;sort(a,0,7)–&gt;sort(a,0,3)–&gt;sort(a,0,1)–&gt;merga(a,0,0,1)–&gt;sort(a,2,3)–&gt;merga(a,2,2,3)–&gt;merga(a,0,1,3)sort(a,4,7)……</p><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>这种方法呢，就是先将一个大问题分成若干个小问题分别解决，最后再将所有的小问题的答案汇总起来解决这个大问题。<br>简单点来说，先将数组分成长度为1的数组，然后两两归并，然后四四归并…最后归并成了一个大的数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自底向上归并算法，先归并微型数组，然后再把得到的子数组进行归并，简言之先把每个数组长度为1，然后两两归并，</span><br><span class="line"> * 然后归并长度为2(也就是2个长度为1的数组归并的结果)的数组.....依次进行..直到归并完整个数组</span><br><span class="line"> * 对于长度为N的任意数组，自底向上的归并排序需要1/2NlogN至NlogN次比较，需要访问数组6NlogN次。</span><br><span class="line"> * 注：当数组长度为2的N次幂的时候，自顶上下和自底向上排序所用的比较次数和数组访问次数相同。</span><br><span class="line"> * 自底向上排序更适合链表的结构排序。</span><br><span class="line"> * @param a</span><br><span class="line"> */</span><br><span class="line">public static void sortDU(Comparable [] a) &#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">aux = new Comparable [N];</span><br><span class="line"><span class="keyword">for</span>(int i = 1;i&lt;N;i = i+i) &#123;//i为子数组的大小</span><br><span class="line"><span class="keyword">for</span>(int lo = 0;lo &lt; N-i;lo += i+i) &#123;</span><br><span class="line">merga(a, lo, lo+i-1, Math.min(lo+i+i-1, N-1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种排序算法的执行方式就是：首先i会等于1，然后执行merga(a,0,0,1)–&gt;merga(a,2,2,3)…….两两归并完成后，当i=2时，执行merga(a,0,1,3)–&gt;merga(a,4,5,7)…..直到i为最大值，退出循环，排序也就结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;归并排序是基于归并操作，简言之就是将两个有序数组归并成一个有序数组。也就是在对于一个数组进行排序之前，可以先(递归地)将这个数组拆分成两个数组分别排序，最后再归并成一个有序数组。&lt;br&gt;它的主要缺点就是所需要的额外空间和数组大小N成正比。&lt;/p&gt;
&lt;h2 id=&quot;原地归并的抽象方法&quot;&gt;&lt;a href=&quot;#原地归并的抽象方法&quot; class=&quot;headerlink&quot; title=&quot;原地归并的抽象方法&quot;&gt;&lt;/a&gt;原地归并的抽象方法&lt;/h2&gt;&lt;p&gt;实现归并就是将两个有序数组归并到第三个数组中，但是在对于一个大数组进行排序的时候，我们需要很多次归并，这样的情况就是多次创建一个新数组来存储原本的数组值，对于空间消耗较大，而原地归并就是指将数组的前半段排序，再将数组的后半段排序，最后再数组中进行移动，而不需要使用额外的空间。&lt;br&gt;ps:实际这种操作的实现非常复杂…特别是和使用空间来存储的方法相比….但是这种方法的抽象化还是有帮助的.
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法学习(3)希尔排序</title>
    <link href="http://yoursite.com/2019/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/20/算法学习-3-希尔排序/</id>
    <published>2019-03-20T15:08:06.000Z</published>
    <updated>2019-03-20T16:14:13.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>希尔排序算法是一种基于插入排序的快速排序算法，对于大规模乱序数组插入排序很慢，因为它只会交换相邻2个元素的值，因此元素只能一点点的从数组的一端移动到另外一端。希尔排序为了加速，改进了插入排序，是的交换不相邻的元素以对数组进行排序。<br>希尔排序的思想是是的数组中任意间隔为h的元素都是有序的，这样的数组成为h有序数组，一个h有序数组就是h个相互独立的有序数组编织在一起组成的一个数组。<br>希尔排序更高效是因为它权衡了子数组的规模和有序性，排序之初，各个子数组都很短，排序之后子数组又是部分有序的，这两种情况都很适合插入排序.<a id="more"></a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.service.impl;</span><br><span class="line">/**</span><br><span class="line"> * 希尔排序，其代码简洁且不需要使用额外的内存空间</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年3月18日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class shell &#123;</span><br><span class="line">/**</span><br><span class="line"> * 希尔算法：希尔算法比插入算法和选择排序要快很多，并且数组越大越明显，希尔算法的性能方面，其运行时间不到平方级别，最坏情况下算法的比较次数和N的1.5次幂成正比。</span><br><span class="line"> * </span><br><span class="line"> * 希尔算法的性质：使用递增序列1,4,7,10....3h+1的希尔排序所需要的比较次数不超过N的若干倍乘以递增序列的长度</span><br><span class="line"> * @param a</span><br><span class="line"> */</span><br><span class="line">public static void sort(Comparable [] a) &#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">int h = 1;</span><br><span class="line"><span class="keyword">while</span>(h&lt;N/3) &#123;</span><br><span class="line">h = h*3+1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(h&gt;=1) &#123;</span><br><span class="line">//将数组变成h有序</span><br><span class="line"><span class="keyword">for</span>(int i =h;i&lt;N;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(int j = i;j&gt;=h&amp;&amp;less(a[j], a[j-h]);j-=h) &#123;</span><br><span class="line">exch(a, j, j-h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">h = h/3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 比较方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param b</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">private static boolean less(Comparable a,Comparable b) &#123;</span><br><span class="line"><span class="built_in">return</span> b.compareTo(a)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 交换位置方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param i</span><br><span class="line"> * @param j</span><br><span class="line"> */</span><br><span class="line">private static void exch(Comparable [] a,int i,int j) &#123;</span><br><span class="line">Comparable t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序比插入排序和选择排序要快的很多，且数组越大，优势越大。一般情况下，可以优先选择希尔排序对数组或其他情况进行排序。<br>ps:当数组比较小的时候插入排序还是相对超快的….</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;希尔排序算法是一种基于插入排序的快速排序算法，对于大规模乱序数组插入排序很慢，因为它只会交换相邻2个元素的值，因此元素只能一点点的从数组的一端移动到另外一端。希尔排序为了加速，改进了插入排序，是的交换不相邻的元素以对数组进行排序。&lt;br&gt;希尔排序的思想是是的数组中任意间隔为h的元素都是有序的，这样的数组成为h有序数组，一个h有序数组就是h个相互独立的有序数组编织在一起组成的一个数组。&lt;br&gt;希尔排序更高效是因为它权衡了子数组的规模和有序性，排序之初，各个子数组都很短，排序之后子数组又是部分有序的，这两种情况都很适合插入排序.
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法学习(2)插入排序</title>
    <link href="http://yoursite.com/2019/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/20/算法学习-2-插入排序/</id>
    <published>2019-03-20T15:07:18.000Z</published>
    <updated>2019-03-20T15:30:10.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像整理扑克牌一样，将每一张牌插入到其他已经有序的牌的适当位置，在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余元素在插入之前都向右移动一位，这种算法叫做插入排序。</p><p>和选择排序不同，插入排序所需要的时间取决于输入元素的初始顺序，换句话说，当我们要对一个有序数组进行插入操作，使得插入之后其依然有序，或者数组是一个部分有序数组进行排序的时候，插入算法更为合适。它是一种稳定的排序</p><p>对于随机排序数组且主键不重复的情况下，在平均情况下，插入排序需要进行~N²/4次比较和交换，在最坏的情况下，插入排序需要进行N²/2次比较和交换，最好的情况下需要进行N-1次比较和0次交换.<br>插入排序需要的交换 操作和数组中倒置的数量相同，需要比较的次数大于等于倒置的数量，小于等于倒置的数量加上数组的长度减一。<br>对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间时平方级别的，两者之比应该是一个很小的常数。<br>ps:插入排序比选择排序一般情况下要快10倍左右.<a id="more"></a></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.service.impl;</span><br><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> * </span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年3月18日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class Inserttion &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 比较方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param b</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">private static boolean less(Comparable a,Comparable b) &#123;</span><br><span class="line"><span class="built_in">return</span> b.compareTo(a)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 交换位置方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param i</span><br><span class="line"> * @param j</span><br><span class="line"> */</span><br><span class="line">private static void exch(Comparable [] a,int i,int j) &#123;</span><br><span class="line">Comparable t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable []a) &#123;</span><br><span class="line">int N = a.length;</span><br><span class="line"><span class="keyword">for</span>(int i = 1;i &lt; N;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(int j = i;j&gt;0&amp;&amp;less(a[i],a[j-1]);j--) &#123;</span><br><span class="line">exch(a, j, j-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于从1到N-1的每一个i中，将a[i]和a[0]到a[i-1]中比它小的元素一次有序的交换着，在索引i由左向右变化的过程中，它左侧的元素总是有序的，所以当i达到数组最右端时，排序就完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;就像整理扑克牌一样，将每一张牌插入到其他已经有序的牌的适当位置，在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余元素在插入之前都向右移动一位，这种算法叫做插入排序。&lt;/p&gt;
&lt;p&gt;和选择排序不同，插入排序所需要的时间取决于输入元素的初始顺序，换句话说，当我们要对一个有序数组进行插入操作，使得插入之后其依然有序，或者数组是一个部分有序数组进行排序的时候，插入算法更为合适。它是一种稳定的排序&lt;/p&gt;
&lt;p&gt;对于随机排序数组且主键不重复的情况下，在平均情况下，插入排序需要进行~N²/4次比较和交换，在最坏的情况下，插入排序需要进行N²/2次比较和交换，最好的情况下需要进行N-1次比较和0次交换.&lt;br&gt;插入排序需要的交换 操作和数组中倒置的数量相同，需要比较的次数大于等于倒置的数量，小于等于倒置的数量加上数组的长度减一。&lt;br&gt;对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间时平方级别的，两者之比应该是一个很小的常数。&lt;br&gt;ps:插入排序比选择排序一般情况下要快10倍左右.
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法学习(1)选择排序</title>
    <link href="http://yoursite.com/2019/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/20/算法学习-1-选择排序/</id>
    <published>2019-03-20T14:55:05.000Z</published>
    <updated>2019-03-20T15:10:11.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序原理"><a href="#选择排序原理" class="headerlink" title="选择排序原理"></a>选择排序原理</h2><p>   每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。<br>   特点：    1.运行时间与输入无关。<br>              2.数据移动是最小的，选择排序只移动N次，但是在数组中会进行N²/2次访问<br>   性质：  对于长度为N的数组，选择排序需要大概N²/2次比较和N次交换.<a id="more"></a></p><h2 id="算法模版"><a href="#算法模版" class="headerlink" title="算法模版"></a>算法模版</h2><p>所有的算法都基于一个模版，该模版包含了算法所必须的所有的方法：<br>模版如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.service;</span><br><span class="line">/**</span><br><span class="line"> * 排序算法模版接口，规定排序算法必要的几个方法，</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年3月18日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class SortTemplate &#123;</span><br><span class="line"></span><br><span class="line">//注意：每次自定义类必须实现Comparable接口并重写其CompareTo方法。</span><br><span class="line">/**</span><br><span class="line"> * 排序算法</span><br><span class="line"> * @param a</span><br><span class="line"> */</span><br><span class="line">public static void sort(Comparable [] a) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 元素比较方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param b</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">private static boolean less(Comparable a,Comparable b) &#123;</span><br><span class="line"><span class="built_in">return</span> b.compareTo(a)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 交换元素位置方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param i</span><br><span class="line"> * @param j</span><br><span class="line"> */</span><br><span class="line">private static void exch(Comparable [] a,int i,int j) &#123;</span><br><span class="line">Comparable t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 循环输出</span><br><span class="line"> * @param a</span><br><span class="line"> */</span><br><span class="line">private static void show(Comparable []a) &#123;</span><br><span class="line"><span class="keyword">for</span>(int i = 0;i&lt;a.length;i++) &#123;</span><br><span class="line">System.out.println(a[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断当前数组元素是否有序</span><br><span class="line"> * @param a</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">public static boolean isSorted(Comparable [] a) &#123;</span><br><span class="line"><span class="keyword">for</span>(int i = 1;i&lt;a.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(less(a[i], a[i-1])) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.service.impl;</span><br><span class="line"></span><br><span class="line">import com.wangshun.service.SortTemplate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> * 特点：</span><br><span class="line"> * 1.运行时间与输入无关。</span><br><span class="line"> *  2.数据移动是最小的，选择排序只移动N次，但是在数组中会进行N²/2次访问</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年3月18日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class Selection extends SortTemplate&#123;</span><br><span class="line">/**</span><br><span class="line"> * 比较方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param b</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">private static boolean less(Comparable a,Comparable b) &#123;</span><br><span class="line"><span class="built_in">return</span> b.compareTo(a)&lt;0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 交换位置方法</span><br><span class="line"> * @param a</span><br><span class="line"> * @param i</span><br><span class="line"> * @param j</span><br><span class="line"> */</span><br><span class="line">private static void exch(Comparable [] a,int i,int j) &#123;</span><br><span class="line">Comparable t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 排序方法</span><br><span class="line"> * 选择排序会每次将第i个最小的元素放入a[i]中，数组第i个位置左边是i个最小的元素且不会被访问</span><br><span class="line"> * @param a</span><br><span class="line"> */</span><br><span class="line">public static void sort(Comparable [] a) &#123;</span><br><span class="line">int N = a.length;</span><br><span class="line"><span class="keyword">for</span>(int i = 0;i&lt;N;i++) &#123;</span><br><span class="line">int min = i;//取当前第i个的元素当成最小数</span><br><span class="line"><span class="keyword">for</span>(int j = i+1;j&lt;N;j++) &#123;//保证排序过的元素不会被访问</span><br><span class="line"><span class="keyword">if</span>(less(a[j], a[min])) &#123;</span><br><span class="line">min = j;//通过比较找到当前数组中最小元素的下标</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exch(a, i, min);//每内圈循环完一次执行一次交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;选择排序原理&quot;&gt;&lt;a href=&quot;#选择排序原理&quot; class=&quot;headerlink&quot; title=&quot;选择排序原理&quot;&gt;&lt;/a&gt;选择排序原理&lt;/h2&gt;&lt;p&gt;   每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。&lt;br&gt;   特点：    1.运行时间与输入无关。&lt;br&gt;              2.数据移动是最小的，选择排序只移动N次，但是在数组中会进行N²/2次访问&lt;br&gt;   性质：  对于长度为N的数组，选择排序需要大概N²/2次比较和N次交换.
    
    </summary>
    
      <category term="算法学习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(11)服务网关——Gateway</title>
    <link href="http://yoursite.com/2019/01/19/SpringCloud%E5%AD%A6%E4%B9%A0-11-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E2%80%94%E2%80%94Gateway/"/>
    <id>http://yoursite.com/2019/01/19/SpringCloud学习-11-服务网关——Gateway/</id>
    <published>2019-01-19T06:38:58.000Z</published>
    <updated>2019-01-19T11:36:30.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud-GateWay概述"><a href="#Spring-Cloud-GateWay概述" class="headerlink" title="Spring Cloud GateWay概述"></a>Spring Cloud GateWay概述</h2><p>Spring Cloud GateWay 是Spring官方基于Spring5.0、SpringBoot2.0和Porject Reactor等技术开发的网关，旨在为微服务架构提供简单、有效且统一的API路由管理方式，目标是能替换Zuul，其不仅提供了统一的路由方式，而且基于Filter链的方式提供了网关的基本功能，例如:安全、监控/埋点、限流等<a id="more"></a></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>网关提供API全托服务，丰富的API管理功能，包含协议适配、协议转发、安全策略、防刷、流量、监控日志等等</p><h3 id="Gateway-重要的概念"><a href="#Gateway-重要的概念" class="headerlink" title="Gateway 重要的概念"></a>Gateway 重要的概念</h3><p>1.路由：路由是网关组成的最基础部分，路由信息是由一个ID、一个目标url、一组断言工厂和一组Filter组成，如果断言工厂为真，则说明请求的url和配置的路由匹配。<br>2.断言：Java8中的断言函数。Spring Cloud Gateway中的断言函数输入的类型是Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自Http Request中的任何信息，比如请求头和参数。<br>3.过滤器：一个标准的Spring WebFilter,Spring Cloud Gateway包含两种过滤器，分别是Gateway Filter和Global Filter。过滤器会将请求和响应进行修改处理。</p><p>注：目前Spring Cloud Gateway只支持Netty容器</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>使用Spring Cloud Gateway的path路由断言工厂实现url直接转发</p><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes: <span class="comment">#当访问http://localhost:8080/baidu,直接转发到https://www.baidu.com/</span></span><br><span class="line">      - id: baidu_route</span><br><span class="line">        uri: http://baidu.com:80/</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/baidu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging: <span class="comment">## Spring Cloud Gateway的日志配置</span></span><br><span class="line">  level:</span><br><span class="line">    org.springframework.cloud.gateway: TRACE</span><br><span class="line">    org.springframework.http.server.reactive: DEBUG</span><br><span class="line">    org.springframework.web.reactive: DEBUG</span><br><span class="line">    reactor.ipc.netty: DEBUG</span><br><span class="line"><span class="comment">#开启关于Filter以及routes的信息查询。</span></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">'*'</span></span><br><span class="line">  security:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>在Spring Cloud Gateway中提供了一个接口，做了最后那一段配置之后，我们就可以通过一个restFul 的接口来查询route的信息</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动项目，访问地址：<a href="http://localhost:8081/actuator/gateway/routes" target="_blank" rel="noopener">http://localhost:8081/actuator/gateway/routes</a><br>可以看到内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="string">"route_id"</span>: <span class="string">"baidu_route"</span>,</span><br><span class="line"><span class="string">"route_definition"</span>: &#123;</span><br><span class="line"><span class="string">"id"</span>: <span class="string">"baidu_route"</span>,</span><br><span class="line"><span class="string">"predicates"</span>: [&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Path"</span>,</span><br><span class="line"><span class="string">"args"</span>: &#123;</span><br><span class="line"><span class="string">"_genkey_0"</span>: <span class="string">"/baidu"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">"filters"</span>: [],</span><br><span class="line"><span class="string">"uri"</span>: <span class="string">"http://baidu.com:80/"</span>,</span><br><span class="line"><span class="string">"order"</span>: 0</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"order"</span>: 0</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>访问：<a href="http://localhost:8080/baidu" target="_blank" rel="noopener">http://localhost:8080/baidu</a>  就可以进入到百度页面了。</p><h2 id="Spring-Cloud-Gateway-的路由断言"><a href="#Spring-Cloud-Gateway-的路由断言" class="headerlink" title="Spring Cloud Gateway 的路由断言"></a>Spring Cloud Gateway 的路由断言</h2><p>Spring Cloud Gateway的路由匹配的功能是以Spring WebFlux中的Handler Mapping为基础实现的。当Http Request请求进入 Spring Cloud Gateway的时候，网关中的路由断言工厂会根据配置的规则进行匹配，匹配成功则进行下一步处理，失败则直接返回错误信息。</p><h3 id="After路由断言工厂"><a href="#After路由断言工厂" class="headerlink" title="After路由断言工厂"></a>After路由断言工厂</h3><p>After 路由断言工厂中会取一个UTC时间格式的时间参数，当请求传入的当前时间在配置的UTV时间之后，则会成功匹配，否则不能成功匹配。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes: <span class="comment">#当访问http://localhost:8080/baidu,直接转发到https://www.baidu.com/</span></span><br><span class="line">      </span><br><span class="line">      - id: baidu_route</span><br><span class="line">        uri: https://baidu.com:80/</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/baidu</span><br><span class="line">        </span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: https://baidu.com</span><br><span class="line">        predicates:</span><br><span class="line">        - After=2019-01-19T19:00:15.4027685+08:00[Asia/Shanghai]</span><br><span class="line">        - Path=/<span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>其中这里的After的值可以根据一个方法来生成</p><h3 id="生成时间"><a href="#生成时间" class="headerlink" title="生成时间"></a>生成时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.utils;</span><br><span class="line"></span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class UtcTimeUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ZonedDateTime time=  ZonedDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">"zonedDateTime:"</span>+time);</span><br><span class="line"></span><br><span class="line">        String  maxTime=ZonedDateTime.now().plusHours(1).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">        System.out.println(<span class="string">"maxTime："</span>+maxTime);</span><br><span class="line"></span><br><span class="line">        String  minTime=ZonedDateTime.now().minusHours(1).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">        System.out.println(<span class="string">"minTime:"</span>+minTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String str=time.format(formatter);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以先设置一个比现在早的时间，也就是代码中minTime的那个时间，然后启动程序，访问localhost:8081/test，可以看到跳转到百度了。<br>然后设置一个比目前晚的时间，也就是代码中的MaxTime，然后启动程序，访问localhost:8081/test，可以看到页面报错404.<br>同时日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-01-19 17:05:58.772 TRACE 14156 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping   : No RouteDefinition found <span class="keyword">for</span> [Exchange: GET http://localhost:8081/<span class="built_in">test</span>]</span><br><span class="line">2019-01-19 17:05:58.774 DEBUG 14156 --- [ctor-http-nio-2] o.s.w.r.handler.SimpleUrlHandlerMapping  : [d00b460c] Mapped to ResourceWebHandler [<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span>]</span><br><span class="line">2019-01-19 17:05:58.777 DEBUG 14156 --- [ctor-http-nio-2] o.s.w.r.resource.ResourceWebHandler      : [d00b460c] Resource not found</span><br></pre></td></tr></table></figure></p><h3 id="Before-路由断言工厂"><a href="#Before-路由断言工厂" class="headerlink" title="Before 路由断言工厂"></a>Before 路由断言工厂</h3><p>在此时间之前的可以成功匹配，之后则不能匹配，配置文件除了After改成Before没其他区别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">        - Before=2019-01-19T19:00:15.4027685+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure></p><p>###Between 路由断言工厂<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/<span class="built_in">test</span>     </span><br><span class="line">- name: Between</span><br><span class="line">  args:</span><br><span class="line">    datetime1: 2019-01-19T17:00:15.4027685+08:00[Asia/Shanghai]</span><br><span class="line">    datetime2: 2019-01-19T19:00:15.4027685+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure></p><h3 id="Cookie-路由断言工厂"><a href="#Cookie-路由断言工厂" class="headerlink" title="Cookie 路由断言工厂"></a>Cookie 路由断言工厂</h3><p>请求时必须包含同样的Cookie 才能匹配成功，否则匹配失败，Cookie包含两个值，一个是key  一个是Value，下面通过调用来显示其使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/Cookie</span><br><span class="line">- Cookie=chocolate,ch.p</span><br></pre></td></tr></table></figure><p>这种写法的的Cookie  的value 要写成chocolate=ch.p<br>postman调用如下：<br><img src="/images/SpringCloud/Gateway/gateway-1.png"></p><p>同样，我们修改Cookie的值，再次调用就可以看到错误的返回：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"2019-01-19T09:36:27.147+0000"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/Cookie"</span>,</span><br><span class="line">    <span class="string">"status"</span>: 404,</span><br><span class="line">    <span class="string">"error"</span>: <span class="string">"Not Found"</span>,</span><br><span class="line">    <span class="string">"message"</span>: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Header-路由断言工厂"><a href="#Header-路由断言工厂" class="headerlink" title="Header 路由断言工厂"></a>Header 路由断言工厂</h3><p>Header 路由断言工厂由header信息进行匹配，匹配成功则进行转发，否则不进行转发。<br>写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/header</span><br><span class="line">- Header=X-Request-Id,12138</span><br></pre></td></tr></table></figure></p><p>启动测试 ，内容一致看到百度网页，内容不一致看到报错404(懒得一个一一个截图……)</p><h3 id="Host-路由断言工厂"><a href="#Host-路由断言工厂" class="headerlink" title="Host 路由断言工厂"></a>Host 路由断言工厂</h3><p>写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/host</span><br><span class="line">- Host=**.baidu.com:8080</span><br></pre></td></tr></table></figure></p><p>1.需要修改本地host文件， 添加127.0.0.1 对应xxxx.baidu.com<br>然后访问xxxx.baidu.com:8080/host<br>就可以看到百度了….</p><h3 id="Method-路由断言工厂"><a href="#Method-路由断言工厂" class="headerlink" title="Method 路由断言工厂"></a>Method 路由断言工厂</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/method</span><br><span class="line">- Method=GET</span><br></pre></td></tr></table></figure><h3 id="RemoteAddr-路由断言工厂"><a href="#RemoteAddr-路由断言工厂" class="headerlink" title="RemoteAddr 路由断言工厂"></a>RemoteAddr 路由断言工厂</h3><p>这路由断言工厂配置一个IPV4或者IPV6网段的字符串或者ip，当请求ip在网段之内或者和配置的ip相同则进行转发，否则不进行转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicates:</span><br><span class="line">- Path=/remoteAddr</span><br><span class="line">- RemoteAddr=127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="Spring-Cloud-Gateway的内置Filter"><a href="#Spring-Cloud-Gateway的内置Filter" class="headerlink" title="Spring Cloud Gateway的内置Filter"></a>Spring Cloud Gateway的内置Filter</h2><p>gateway中的有很多路由过滤工厂，当然可以根据自己的需要定制自己的路由过滤工厂，路由过滤器允许以某种方式修改请求进来的http请求或者返回的http响应。路由过滤器主要引用语特定的需要修改的路由。</p><h3 id="AddRequestHeader过滤器工厂"><a href="#AddRequestHeader过滤器工厂" class="headerlink" title="AddRequestHeader过滤器工厂"></a>AddRequestHeader过滤器工厂</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line">import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SpringCloudGateway Fliter Bean 配置类</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月19日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class FilterConfig &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对匹配上的请求添加Header头信息</span><br><span class="line"> * @param builder</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public RouteLocator testRouteLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line"><span class="built_in">return</span> builder.routes()</span><br><span class="line">.route(<span class="string">"add_request_header_route"</span>, r -&gt;</span><br><span class="line">r.path(<span class="string">"/test"</span>).filters(f -&gt; f.addRequestHeader(<span class="string">"X-Request-Acme"</span>, <span class="string">"ValueB"</span>))</span><br><span class="line">.uri(<span class="string">"http://localhost:8082/test/head"</span>))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码就是写了一个Controller，然后封装了一下方法。<br>启动2个项目，访问localhost:8081/test，显示404….<br>截取日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-01-19 19:28:23.958 DEBUG 9932 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping   : Mapping [Exchange: GET http://localhost:8081/<span class="built_in">test</span>] to Route&#123;id=<span class="string">'add_request_header_route'</span>, uri=http://localhost:8082/<span class="built_in">test</span>/head, order=0, predicate=org.springframework.cloud.gateway.support.ServerWebExchangeUtils$<span class="variable">$Lambda</span><span class="variable">$333</span>/871153004@4971418e, gatewayFilters=[OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.AddRequestHeaderGatewayFilterFactory$<span class="variable">$Lambda</span><span class="variable">$336</span>/1763750076@12b1367, order=0&#125;]&#125;</span><br><span class="line">2019-01-19 19:28:23.958 DEBUG 9932 --- [ctor-http-nio-2] o.s.c.g.h.RoutePredicateHandlerMapping   : [35f5d11e] Mapped to org.springframework.cloud.gateway.handler.FilteringWebHandler@7e9c099b</span><br><span class="line">2019-01-19 19:28:23.959 DEBUG 9932 --- [ctor-http-nio-2] o.s.c.g.handler.FilteringWebHandler      : Sorted gatewayFilterFactories: [OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@2785db06&#125;, order=-2147482648&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@2e5e6fc4&#125;, order=-1&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardPathFilter@68ab6ab0&#125;, order=0&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.GatewayMetricsFilter@58324c9f&#125;, order=0&#125;, OrderedGatewayFilter&#123;delegate=org.springframework.cloud.gateway.filter.factory.AddRequestHeaderGatewayFilterFactory$<span class="variable">$Lambda</span><span class="variable">$336</span>/1763750076@12b1367, order=0&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@79980d8d&#125;, order=10000&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@61ffd148&#125;, order=2147483646&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@331ff3ac&#125;, order=2147483647&#125;, OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@35d60381&#125;, order=2147483647&#125;]</span><br><span class="line">2019-01-19 19:28:23.967 TRACE 9932 --- [ctor-http-nio-2] o.s.c.g.filter.RouteToRequestUrlFilter   : RouteToRequestUrlFilter start</span><br><span class="line">2019-01-19 19:28:24.274 TRACE 9932 --- [ctor-http-nio-3] o.s.c.g.filter.NettyWriteResponseFilter  : NettyWriteResponseFilter start</span><br><span class="line">2019-01-19 19:28:24.283 TRACE 9932 --- [ctor-http-nio-3] o.s.c.g.filter.GatewayMetricsFilter      : Stopping timer <span class="string">'gateway.requests'</span> with tags [tag(outcome=CLIENT_ERROR),tag(routeId=add_request_header_route),tag(routeUri=http://localhost:8082/<span class="built_in">test</span>/head),tag(status=NOT_FOUND)]</span><br></pre></td></tr></table></figure></p><p>然后我直接访问localhost:8082/test/head 是可以的…<br>在过滤条件中将localhost:8082/test/head  改为百度也是可以访问的….我日…..<br>具体原因未知…..想了一下，应该可以使用服务治理的前缀来进行访问….但是没心情再测试下去了….<br>就此撒花..以后有时间的时候再看看….</p><p>反正我给自己挖的一部分坑…到用的时候我还是自己会填上的….</p><p>参考文献：<br>    《重新定义SpringCloud实战》——许进</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Cloud-GateWay概述&quot;&gt;&lt;a href=&quot;#Spring-Cloud-GateWay概述&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud GateWay概述&quot;&gt;&lt;/a&gt;Spring Cloud GateWay概述&lt;/h2&gt;&lt;p&gt;Spring Cloud GateWay 是Spring官方基于Spring5.0、SpringBoot2.0和Porject Reactor等技术开发的网关，旨在为微服务架构提供简单、有效且统一的API路由管理方式，目标是能替换Zuul，其不仅提供了统一的路由方式，而且基于Filter链的方式提供了网关的基本功能，例如:安全、监控/埋点、限流等
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(10)非入侵APM——SkyWalking</title>
    <link href="http://yoursite.com/2019/01/18/SpringCloud%E5%AD%A6%E4%B9%A0-10-%E9%9D%9E%E5%85%A5%E4%BE%B5APM%E2%80%94%E2%80%94SkyWalking/"/>
    <id>http://yoursite.com/2019/01/18/SpringCloud学习-10-非入侵APM——SkyWalking/</id>
    <published>2019-01-18T10:42:58.000Z</published>
    <updated>2019-01-19T03:13:30.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SkyWalking概述"><a href="#SkyWalking概述" class="headerlink" title="SkyWalking概述"></a>SkyWalking概述</h2><p>SkyWalking 是一个用于追踪、监控和诊断分布式系统，特别是微服务的项目。从5.X进化成一个完成功能的APM系统<a id="more"></a></p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>1.分布式追踪和上下文传输<br>2.应用、实例、服务性能指标分析<br>3.根源分析<br>4.应用拓扑分析<br>5.应用和服务依赖分析<br>6.慢服务检测<br>7.性能优化</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><p>1.多语言探针或者类库<br>    1.1 Java自动探针，追踪和监控程序时，不需要修改源码。<br>    1.2 社区提供语言探针：.NET Core、Node.js<br>2.多种后端存储：ElasticSeach、H2<br>    2.1支持OpenTrancing:Java自动探针和OpenTracing API协同工作<br>3.轻量级、完善的后端聚合和分析功能<br>4.现代化WebUI<br>5.日志集成<br>6.应用、实例和服务的告警<br>7.支持接受其他跟踪器数据格式。<br>    7.1 Zipkin JSON,Thrift,Protobuf v1 和v2格式，由OpenZipkin库提供支持。<br>    7.2 Jaeger采用Zipkin Thrift或JSON v1/v2格式</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>SkyWalking 的整体架构主要由四部分组成：collector、agent、web、storage</p><p>首先是接入部分，接入的话可以使用SDK接入，也可以使用非入侵性Agent形式接入，agent将数据转化成SkyWalking Trace 数据协议，通过Http或者gRPC发送到collector,collector对收集的数据进行分析和聚合，最后存储到ElasticSearch或者H2中，一般情况下H2用于测试。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>本次案例使用2个服务(service-a,service-b)、Zuul网关、Eureka作为注册中心，案例的调用过程是这样的，首先通过访问Zuul网关然后转发到service-a,service-a通过Feign远程调用service-b，最后返回内容。</p><h3 id="注册中心eureka-server-skywalking"><a href="#注册中心eureka-server-skywalking" class="headerlink" title="注册中心eureka-server-skywalking"></a>注册中心eureka-server-skywalking</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- jaxb模块引用 - start --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;javax.activation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;activation&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- jaxb模块引用 - end --&gt;</span><br></pre></td></tr></table></figure><p>jdk8貌似没有后面几个jaxb的包，我不知道是不是我电脑问题。。。。</p><h4 id="添加注解启动Eureka"><a href="#添加注解启动Eureka" class="headerlink" title="添加注解启动Eureka"></a>添加注解启动Eureka</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class SpringCloudLeaning7EurekaServerSkywalkingApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning7EurekaServerSkywalkingApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span></span><br><span class="line">  server:</span><br><span class="line">    <span class="built_in">wait</span>-time-in-ms-when-sync-empty: 0</span><br><span class="line">    <span class="built_in">enable</span>-self-preservation: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>至此，服务端编写完成….没啥特别的…和之前写的差不多。</p><h3 id="zuul-skywalking"><a href="#zuul-skywalking" class="headerlink" title="zuul-skywalking"></a>zuul-skywalking</h3><h4 id="pom文件-1"><a href="#pom文件-1" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="添加注解开启Zuul和服务发现"><a href="#添加注解开启Zuul和服务发现" class="headerlink" title="添加注解开启Zuul和服务发现"></a>添加注解开启Zuul和服务发现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringCloudLeaning7ZuulSkywalkingApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning7ZuulSkywalkingApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: zuul-skywalking</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9020</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    service<span class="_">-a</span>: </span><br><span class="line">      path: /client/**</span><br><span class="line">      serviceId: service<span class="_">-a</span></span><br><span class="line">ribbon:</span><br><span class="line">  eureka:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">  ReadTimeout: 30000</span><br><span class="line">  ConnectTimeout: 30000</span><br><span class="line">  MaxAutoRetries: 0</span><br><span class="line">  MaxAutoRetriesNextServer: 1</span><br><span class="line">  OkToRetryOnAllOperations: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  threadpool:</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 1000 <span class="comment">##并发执行的最大线程数，默认10</span></span><br><span class="line">      maxQueueSize: 1000 <span class="comment">##BlockingQueue的最大队列数</span></span><br><span class="line">      queueSizeRejectionThreshold: 500 <span class="comment">##即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝</span></span><br><span class="line">  <span class="built_in">command</span>:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 120001</span><br></pre></td></tr></table></figure><p>之所以做ribbon和hystrix的配置是为了防止第一次请求进行超时。</p><h3 id="service-a"><a href="#service-a" class="headerlink" title="service-a"></a>service-a</h3><h4 id="pom文件-2"><a href="#pom文件-2" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="主程序添加注解开启Feign和服务发现"><a href="#主程序添加注解开启Feign和服务发现" class="headerlink" title="主程序添加注解开启Feign和服务发现"></a>主程序添加注解开启Feign和服务发现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class SpringCloudLeaning7ServiceASkywalkingApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning7ServiceASkywalkingApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-yml-2"><a href="#application-yml-2" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service<span class="_">-a</span></span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9021</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br></pre></td></tr></table></figure><h4 id="Service接口实现Feign声明式调用"><a href="#Service接口实现Feign声明式调用" class="headerlink" title="Service接口实现Feign声明式调用"></a>Service接口实现Feign声明式调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">@FeignClient(value=<span class="string">"service-b"</span>)</span><br><span class="line">public interface FeignService &#123;</span><br><span class="line">@GetMapping(<span class="string">"/getSendInfo/&#123;serviceName&#125;"</span>)</span><br><span class="line">String getSendInfo(@PathVariable(<span class="string">"serviceName"</span>)String serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.FeignService;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">FeignService feignService;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/send/&#123;serviceName&#125;"</span>)</span><br><span class="line">public String send(@PathVariable(<span class="string">"serviceName"</span>)String serviceName) &#123;</span><br><span class="line"><span class="built_in">return</span> feignService.getSendInfo(serviceName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-b"><a href="#service-b" class="headerlink" title="service-b"></a>service-b</h3><h4 id="pom文件-3"><a href="#pom文件-3" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="主程序添加服务发现注解"><a href="#主程序添加服务发现注解" class="headerlink" title="主程序添加服务发现注解"></a>主程序添加服务发现注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class SpringCloudLeaning7ServiceBSkywalking1Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning7ServiceBSkywalking1Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-yml-3"><a href="#application-yml-3" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-b</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9022</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br></pre></td></tr></table></figure><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class SkySecondController &#123;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/getSendInfo/&#123;serviceName&#125;"</span>)</span><br><span class="line">public String getSendInfo(@PathVariable(<span class="string">"serviceName"</span>)String serviceName) &#123;</span><br><span class="line"><span class="built_in">return</span> serviceName+<span class="string">"------&gt;"</span>+<span class="string">"service-b"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此所有的服务就都编写完成了，当然也可以启动测试一下：<br>启动server、zuul、service-a、service-b<br>访问：<a href="http://localhost:9020/client/send/skywalking" target="_blank" rel="noopener">http://localhost:9020/client/send/skywalking</a><br>可以收到结果skywalking——&gt;service-b就证明接口没问题啦。</p><h2 id="skyWalking-Controller-环境安装-windows"><a href="#skyWalking-Controller-环境安装-windows" class="headerlink" title="skyWalking Controller 环境安装(windows)"></a>skyWalking Controller 环境安装(windows)</h2><p>SkyWalking 6.x需要的基础环境如下：<br>Elasticsearch 6.x (集群模式或者不适用,以后简称es)<br>Sky Walking 6.X使用es作为存储，所以首先下载es，去官网下载最新版即可，我这边目前的最新版是6.5.4<br>下载完成后解压，然后进入目录的bin目录下，启动elasticsearch.bat<br>启动成功的截图如下：<br><img src="/images/SpringCloud/SkyWalking/skyWalking-1.png"></p><p>启动完成后开始下载SkyWalking的相关资料。从Apache官网下载当前SkyWalking发布的版本即可，具体下载地址：<br><a href="http://skywalking.apache.org/downloads" target="_blank" rel="noopener">http://skywalking.apache.org/downloads</a><br>然后根据操作系统选择对应版本下载即可。<br>解压完成的结构图如下：<br><img src="/images/SpringCloud/SkyWalking/skyWalking-2.png"></p><p>这里说一下目录的结构，agen是探针相关，bin中存放的是collectorService和webappService的启动脚本，startup是可以同时启动前面2个脚本的合并命令。<br>config是collector的相关配置信息。log是存放启动collector和web 后生成的日志文件。，webapp存放Sky Walking展示UI的jar和配置文件。默认端口为8080、10800、11800、1280这些端口，如果需要修改，应该在config里面的application.yml和webapp下的webapp.yml配置文件中修改。</p><p>接下来启动collector和web，进入bin目录下双击startup.bat即可。<br>启动成功后访问localhost:8080,使用admin/admin进行登录即可，登录后可看到以下界面。<br><img src="/images/SpringCloud/SkyWalking/skyWalking-3.png"></p><h3 id="使用Agent启动服务和监控查看"><a href="#使用Agent启动服务和监控查看" class="headerlink" title="使用Agent启动服务和监控查看"></a>使用Agent启动服务和监控查看</h3><p>首先在SkyWalking6.5.X的同级目录下创建一个文件夹，然后再文件夹中创建4个文件夹，结构如下图<br><img src="/images/SpringCloud/SkyWalking/skyWalking-4.png"><br>每个文件夹中都有一个agent 文件夹 和一个程序的执行jar，每个应用使用对应的agent进行启动。</p><p>其中agent就是原本下载的SkyWalking中agent的文件夹，复制过来就行，然后修改agent/config里面的agent.conf，修改agent.service_name的值为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.service_name=service-eureka</span><br></pre></td></tr></table></figure></p><p>4个文件夹分别修改 这个属性值为对应的服务名称，和application.name一致或者随意起都可以，其实就是页面显示的名字而已。</p><p>然后再说那4个jar，4个jar是通过maven打包出来的，我是使用的clean install命令打包出来的，然后分别放到对应的文件夹下即可。</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--启动Eureka</span><br><span class="line">java -javaagent:E:/software/skywalking/service-eureka/agent/skywalking-agent.jar -jar SpringCloud-leaning-7-eureka-server-skywalking-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">--启动zuul</span><br><span class="line">java -javaagent:E:/software/skywalking/service-zuul/agent/skywalking-agent.jar -jar SpringCloud-leaning-7-zuul-skywalking-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">--启动service<span class="_">-a</span></span><br><span class="line">java -javaagent:E:/software/skywalking/service<span class="_">-a</span>/agent/skywalking-agent.jar -jar SpringCloud-leaning-7-service<span class="_">-a</span>-skywalking-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">--启动serice -b</span><br><span class="line">java -javaagent:E:/software/skywalking/service-b/agent/skywalking-agent.jar -jar SpringCloud-leaning-7-service-b-skywalking-1-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>这里要注意两点，一个是skywalking-agent.jar 是当前目录下的，复制的时候不要忘了改，不然拓扑图不显示…（自己懒省事挖的坑解决了好久…..）<br>另外一个是启动顺序是固定的，eureka–&gt;zuul–&gt;service-a –&gt;service-b，不然会报错比如eureka拒绝访问等等<br>启动完成后 刷新localhost:8080可以看到以下界面:<br><img src="/images/SpringCloud/SkyWalking/skyWalking-5.png"></p><p>重新执行<a href="http://localhost:9020/client/send/skywalking" target="_blank" rel="noopener">http://localhost:9020/client/send/skywalking</a><br>可以看到页面监控的响应时间等信息。<br>其他的一些详情信息可以点击左侧的各项指标进行查看，比如服务地图等等….<br><img src="/images/SpringCloud/SkyWalking/skyWalking-6.png"></p><p>参考文献：<br>    《重新定义SpringCloud实战》——许进</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SkyWalking概述&quot;&gt;&lt;a href=&quot;#SkyWalking概述&quot; class=&quot;headerlink&quot; title=&quot;SkyWalking概述&quot;&gt;&lt;/a&gt;SkyWalking概述&lt;/h2&gt;&lt;p&gt;SkyWalking 是一个用于追踪、监控和诊断分布式系统，特别是微服务的项目。从5.X进化成一个完成功能的APM系统
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(9)全链路监控</title>
    <link href="http://yoursite.com/2019/01/16/SpringCloud%E5%AD%A6%E4%B9%A0-9-%E5%85%A8%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/01/16/SpringCloud学习-9-全链路监控/</id>
    <published>2019-01-16T11:36:50.000Z</published>
    <updated>2019-01-17T11:38:20.381Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务的架构下，服务按照不同的维度进行拆分，一次请求可能会涉及到多个服务，并且有可能是由不同的团队开发。因此，就需要一些可以帮助理解系统行为，用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。</p><p>这些工具就是APM，其中最出名的就是谷歌公开论文提到的Dapper</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>Spring Cloud Sleuth 是Spring Cloud的分布式调用链解决方案，Sleuth对于大部分用户来说都是透明的，系统间的交互信息都是能够被自动采集，用户可以通过日志文件获取链路数据，也可以将数据发给远程服务进行统一收集展示。<a id="more"></a></p><p>基本术语：<br>    1.Span:基本工作单元，比如，发送一次RPC请求就是一个新的Span，Span通过一个六十四位的ID标识，还包含有描述、事件时间戳、标签、调用它的Span的ID、处理器ID(一般为IP地址)。注意：第一个Span为rootSpan，它的ID值和trace的ID值一样。<br>    2.Trace：一系列Span组成的树状结构，简言之就是一次调用请求。<br>    3.Annotation：标注，用来描述时间的实时状态。事件有一下几种状态<br>        3.1 cs：Client Send。客户端发起请求，它表示一个Span的开始<br>        3.2 sr: Server Received。服务方接收到请求并开始处理，它减去CS的时间就是网络延迟时间。<br>        3.3 ss：Server Send。它标识请求处理完成，将相应数据返回给客户端。它减去sr的时间就是服务方处理的时间。<br>        3.4 ce：Client Received。 它标识客户端收到服务方的返回值，是当前span结束的新号，它减去cs就是本次请求的完整时间。</p><h3 id="Brave-和Zipkin"><a href="#Brave-和Zipkin" class="headerlink" title="Brave 和Zipkin"></a>Brave 和Zipkin</h3><p>Brave 是一个用于捕捉分布式系统之间调用信息的工具库，然后将这些信息以Span的形式发送给Zipkin。<br>从SpringBoot2.0开始，Sleuth不再自己存储上下文信息，而是使用Brave作为调用链工具库并且遵循Brave的命名和标记管理。</p><p>Zipkin是一个分布式跟踪系统，它手机系统的延时数据并提供展示界面，以便于用户排查问题。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Zipkin-安装与部署"><a href="#Zipkin-安装与部署" class="headerlink" title="Zipkin 安装与部署"></a>Zipkin 安装与部署</h3><p>官网地址：<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">https://github.com/openzipkin/zipkin</a><br>打开git bash<br>执行 curl -sSL <a href="https://zipkin.io/quickstart.sh" target="_blank" rel="noopener">https://zipkin.io/quickstart.sh</a> | bash -s<br>然后执行java -jar zipkin.jar 就可以了。<br>部署后的默认端口为9411，可以访问<a href="http://localhost:9411/zipkin/，看到以下界面就说明部署成功了。" target="_blank" rel="noopener">http://localhost:9411/zipkin/，看到以下界面就说明部署成功了。</a><br><img src="/images/SpringCloud/Sleuth/Sleuth-1.png"></p><p>接下来创建2个项目，Sleuth-consumer,Sleuth-provider</p><h3 id="Sleuth-consumer"><a href="#Sleuth-consumer" class="headerlink" title="Sleuth-consumer"></a>Sleuth-consumer</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sleuth-provider</span><br></pre></td></tr></table></figure><h4 id="启动项添加-EnableFeignClients注解启动Feign"><a href="#启动项添加-EnableFeignClients注解启动Feign" class="headerlink" title="启动项添加@EnableFeignClients注解启动Feign"></a>启动项添加@EnableFeignClients注解启动Feign</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class SpringCloudLeaning5ConsulConfig1Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning5ConsulConfig1Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义线程数和RestTemplate"><a href="#自定义线程数和RestTemplate" class="headerlink" title="自定义线程数和RestTemplate"></a>自定义线程数和RestTemplate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.sleuth.instrument.async.TraceableExecutorService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * 配置类，用于注册RestTemplate 和ExecutorService</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月16日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line">@Configuration</span><br><span class="line">public class ConsumerConfiguration &#123;</span><br><span class="line">@Autowired</span><br><span class="line">BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate <span class="function"><span class="title">restTemplate</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 简单起见，注册固定大小线程池</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ExecutorService <span class="function"><span class="title">executorService</span></span>() &#123;</span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line"><span class="built_in">return</span> new TraceableExecutorService(beanFactory, executorService);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Feign-Service接口"><a href="#Feign-Service接口" class="headerlink" title="Feign Service接口"></a>Feign Service接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">@FeignClient(name=<span class="string">"sleuth-provifer"</span>,url=<span class="string">"localhost:8082"</span>)</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">String hello(@PathVariable(<span class="string">"name"</span>)String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个要注意的地方就是这个URL，url是必须要写的，如果不写会默认开启Ribbon负载均衡，会由于找不到而报错。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.HelloService;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line">private static Logger <span class="built_in">log</span> = LoggerFactory.getLogger(ConsumerController.class); </span><br><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private HelloService helloService;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">public String helloByFeign(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line">log.info(<span class="string">"client send,Feign方式,参数:&#123;&#125;"</span>,name);</span><br><span class="line">String result = helloService.hello(name);</span><br><span class="line">log.info(<span class="string">"client send,Feign方式,结果:&#123;&#125;"</span>,result);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(<span class="string">"/helloByRestTemplate/&#123;name&#125;"</span>)</span><br><span class="line">public String helloByRestTemplate(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line">String url = <span class="string">"http://sleuth-provifer/hello/&#123;name&#125;"</span>;</span><br><span class="line">log.info(<span class="string">"client send,RestTemplate方式,参数:&#123;&#125;"</span>,name);</span><br><span class="line">String result = restTemplate.getForObject(url, String.class,name);</span><br><span class="line">log.info(<span class="string">"client send,RestTemplate方式,结果：&#123;&#125;"</span>,result);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/helloByNewThread/&#123;name&#125;"</span>)</span><br><span class="line">public String helloByNewThread(@PathVariable(<span class="string">"name"</span>)String name) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">log.info(<span class="string">"client send,子线程方式,参数：&#123;&#125;"</span>,name);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(()-&gt;&#123;</span><br><span class="line">String result = helloService.hello(name);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">String result = future.get();</span><br><span class="line">log.info(<span class="string">"client send,子线程方式,结果：&#123;&#125;"</span>,result);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sleuth-provider"><a href="#Sleuth-provider" class="headerlink" title="Sleuth-provider"></a>Sleuth-provider</h3><h4 id="pon文件"><a href="#pon文件" class="headerlink" title="pon文件"></a>pon文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sleuth-provider</span><br></pre></td></tr></table></figure><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">private static Logger <span class="built_in">log</span> = LoggerFactory.getLogger(HelloController.class); </span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">public String hello(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line">log.info(<span class="string">"server received:参数"</span>,name);</span><br><span class="line">String result = <span class="string">"hello:"</span>+name;</span><br><span class="line">log.info(<span class="string">"server sent:参数"</span>,result);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些写法其实和之前的没啥区别……</p><p>然后访问<a href="http://localhost:8081/hello/wangs" target="_blank" rel="noopener">http://localhost:8081/hello/wangs</a>  可以看到日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-16 23:06:35.097  INFO [sleuth-consumer,05405b326d8b3b7e,05405b326d8b3b7e,<span class="literal">false</span>] 14376 --- [nio-8081-exec-1] c.w.l.controller.ConsumerController      : client send,Feign方式,参数:wangs</span><br><span class="line">2019-01-16 23:06:35.276  INFO [sleuth-provider,05405b326d8b3b7e,724c042d4602c8e8,<span class="literal">false</span>] 5272 --- [nio-8082-exec-1] c.w.leaning.controller.HelloController   : server received:参数</span><br><span class="line">2019-01-16 23:06:35.291  INFO [sleuth-provider,05405b326d8b3b7e,724c042d4602c8e8,<span class="literal">false</span>] 5272 --- [nio-8082-exec-1] c.w.leaning.controller.HelloController   : server sent:参数</span><br><span class="line">2019-01-16 23:06:35.323  INFO [sleuth-consumer,05405b326d8b3b7e,05405b326d8b3b7e,<span class="literal">false</span>] 14376 --- [nio-8081-exec-1] c.w.l.controller.ConsumerController      : client send,Feign方式,结果:hello:wangs</span><br></pre></td></tr></table></figure></p><p>所以说这里使用了sleuth的包之后，我们的日志就会自动打印出span的信息，然而Span信息不仅可以携带feign、restTemplate信息，还可以在父子线程之间传递。</p><h2 id="Sleuth深入用法"><a href="#Sleuth深入用法" class="headerlink" title="Sleuth深入用法"></a>Sleuth深入用法</h2><h3 id="TraceFilter"><a href="#TraceFilter" class="headerlink" title="TraceFilter"></a>TraceFilter</h3><p>对于Http接口来说，Sleuth可以通过Brave的TracingFilter来打到获取Span信息的目的。<br>如果你想对Span信息有一些自定义的修改，比如增加tag或者响应头信息，那么只需要注册一个你自己的Filter就可以做到了。</p><p>注：你的Filter必须要比TracingFilter的优先级要低，否则你无法拿到TracingFilter处理之后的信息。</p><h3 id="Baggage"><a href="#Baggage" class="headerlink" title="Baggage"></a>Baggage</h3><p>Baggage 是存储在Span的上下文的一组K/V键值对，跟traceId和spanId不同，他不是必选项。<br>Baggage是一个非常有用的功能，它相当于Sleuth暴露在外的一个功能接口，通过它你可以让你的数据跟着Sleuth一起往后传递。</p><p>最典型的应用就是登录信息的传递。</p><p>接下来沿用刚才写的俩项目，做一些改动<br>其中，consumer使用自定义Filter获取前端传来的SessionId，放入Baggage中，通过Feign调用方式将SessionId传递给provider。</p><h3 id="sleuth-consumer"><a href="#sleuth-consumer" class="headerlink" title="sleuth-consumer"></a>sleuth-consumer</h3><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.filter;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.sleuth.instrument.web.SleuthWebProperties;</span><br><span class="line">import org.springframework.cloud.sleuth.instrument.web.TraceWebServletAutoConfiguration;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.filter.GenericFilterBean;</span><br><span class="line"></span><br><span class="line">import brave.propagation.ExtraFieldPropagation;</span><br><span class="line">@Component</span><br><span class="line">@Order(TraceWebServletAutoConfiguration.TRACING_FILTER_ORDER+1)</span><br><span class="line">public class SessionFilter extends GenericFilterBean&#123;</span><br><span class="line"></span><br><span class="line">private Pattern skipPattern = Pattern.compile(SleuthWebProperties.DEFAULT_SKIP_PATTERN);</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line"><span class="keyword">if</span>(!(request instanceof HttpServletRequest)||!(response instanceof HttpServletResponse)) &#123;</span><br><span class="line">throw new ServletException(<span class="string">"Filter 只支持 Http Request"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">boolean skip = skipPattern.matcher(httpServletRequest.getRequestURI()).matches();</span><br><span class="line"><span class="keyword">if</span>(!skip) &#123;</span><br><span class="line">//将SessionId放入Baggage中</span><br><span class="line">ExtraFieldPropagation.set(<span class="string">"SessionId"</span>, httpServletRequest.getSession().getId());</span><br><span class="line">System.out.println(ExtraFieldPropagation.get(<span class="string">"SessionId"</span>));</span><br><span class="line">&#125;</span><br><span class="line">filterChain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点需要注意：就是Order这个注解，这个其实就是设置优先级，之前也说过，自定义的Filter的优先级必须要比TracingFilter的优先级要低，否则你无法拿到TracingFilter处理之后的信息。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/helloWithSessionId/&#123;name&#125;"</span>)</span><br><span class="line">String helloWithSessionId(@PathVariable(<span class="string">"name"</span>)String name);</span><br></pre></td></tr></table></figure><p>添加了一个方法，和之前做区分，同理Controller 和provider的controller 也要做同样的方法，当然 如果直接修改原有方法也是可以的。</p><h4 id="application-yml-2"><a href="#application-yml-2" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sleuth-consumer</span><br><span class="line">  sleuth:</span><br><span class="line">    baggage-keys: <span class="comment">#注意：SpringBoot2.0之后必须声明才可以生效</span></span><br><span class="line">    - SessionId</span><br></pre></td></tr></table></figure><h3 id="sleuth-provider"><a href="#sleuth-provider" class="headerlink" title="sleuth-provider"></a>sleuth-provider</h3><h4 id="applicaiotn-yml"><a href="#applicaiotn-yml" class="headerlink" title="applicaiotn.yml"></a>applicaiotn.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sleuth-provider</span><br><span class="line">  sleuth:</span><br><span class="line">    baggage-keys:</span><br><span class="line">    - SessionId</span><br></pre></td></tr></table></figure><h4 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/helloWithSessionId/&#123;name&#125;"</span>)</span><br><span class="line">public String helloWithSessionId(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line">log.info(<span class="string">"server received:参数"</span>,name);</span><br><span class="line">String string = ExtraFieldPropagation.get(<span class="string">"SessionId"</span>);</span><br><span class="line">String result = <span class="string">"hello:"</span>+name+<span class="string">"SessionId为："</span>+ExtraFieldPropagation.get(<span class="string">"SessionId"</span>);</span><br><span class="line">log.info(<span class="string">"server sent:参数"</span>,result);</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后启动provider 和consumer<br>访问<a href="http://localhost:8081/helloWithSessionId/wangs" target="_blank" rel="noopener">http://localhost:8081/helloWithSessionId/wangs</a><br>可以看到页面的显示为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello:wangsSessionId为：852D3F212FB8C1C5768DCD6D71FEDE60</span><br></pre></td></tr></table></figure></p><p>完美撒花~</p><p>参考文献：<br>    《重新定义SpringCloud实战》——许进</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务的架构下，服务按照不同的维度进行拆分，一次请求可能会涉及到多个服务，并且有可能是由不同的团队开发。因此，就需要一些可以帮助理解系统行为，用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。&lt;/p&gt;
&lt;p&gt;这些工具就是APM，其中最出名的就是谷歌公开论文提到的Dapper&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;Spring-Cloud-Sleuth&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Sleuth&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Sleuth&quot;&gt;&lt;/a&gt;Spring Cloud Sleuth&lt;/h3&gt;&lt;p&gt;Spring Cloud Sleuth 是Spring Cloud的分布式调用链解决方案，Sleuth对于大部分用户来说都是透明的，系统间的交互信息都是能够被自动采集，用户可以通过日志文件获取链路数据，也可以将数据发给远程服务进行统一收集展示。
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(8)服务治理组件Consul</title>
    <link href="http://yoursite.com/2019/01/15/SpringCloud%E5%AD%A6%E4%B9%A0-8-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%BB%84%E4%BB%B6Consul/"/>
    <id>http://yoursite.com/2019/01/15/SpringCloud学习-8-服务治理组件Consul/</id>
    <published>2019-01-15T13:19:50.000Z</published>
    <updated>2019-01-15T16:35:32.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Consul简介"><a href="#Consul简介" class="headerlink" title="Consul简介"></a>Consul简介</h2><h3 id="什么是Consul"><a href="#什么是Consul" class="headerlink" title="什么是Consul"></a>什么是Consul</h3><p>Consul是一个分布式高可用的服务网络解决方案，提供包含服务发现、配置和分段功能在内的全功能控制面板，这些功能每一个可以单独使用，也可以一起使用以构建完整的服务网络。<a id="more"></a></p><p>###Consul的特点<br>1.采用go语言编写，以Http方式对外提供服务<br>2.Consul支持多数据中心，这是其特色<br>3.Consul除了服务发现之外，还有一些别的功能<br>4.Consul的一致性协议是Raft</p><h3 id="Consul能做什么"><a href="#Consul能做什么" class="headerlink" title="Consul能做什么"></a>Consul能做什么</h3><p>1.服务发现，服务可以通过DNS或者HTTP直接找到它所依赖的服务。<br>2.健康检查，Consul提供了健康检查机制，从简单的服务端返回是否是200响应到较为复杂的内存使用率是否低于百分之90<br>3.K/V存储，应用程序可以根据需要使用Consul的Key/Value存储。Consul提供了简单的http请求来满足用户的动态配置、特征标记、协调、leader选举等需求。<br>4.多数据中心。Consul原生支持多数据库中心。用户不必为了多数据中心而自己做抽象。</p><h3 id="Consul安装"><a href="#Consul安装" class="headerlink" title="Consul安装"></a>Consul安装</h3><p>去官网下载对应的版本<br>官网地址：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a></p><p>windows 版本直接解压 然后进入对应的文件夹路径 打开cmd 执行consul agent -dev即可<br>下面是成功图<br><img src="/images/SpringCloud/Consul/consul-1.png"></p><p>然后访问<a href="http://localhost:8500/" target="_blank" rel="noopener">http://localhost:8500/</a> 就可以看到界面了。<br><img src="/images/SpringCloud/Consul/consul-2.png"></p><p>##Spring Cloud Consul</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Cloud Consul 是通过自动配置，对Spring 环境绑定和其他惯用的Spring模块编程，为SpringBoot应用提供了Consul集成，只需要一些简单的注解，就可以快速启动和配置Consul，并用它构建大型分布式系统。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.Spring Cloud Consul 作为Spring Cloud 和Consul 的桥梁，对两者都有良好的支持。<br>2.服务发现。实例可以向Consul注册服务，客户端可以使用Spring bean来发现服务的提供方<br>3.支持Ribbon，客户端负载均衡。<br>4.支持Zuul，服务网关。<br>5.分布式配置中心，使用的Consul的K/V存储。<br>6.控制总线，使用的是Consul enents。</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="consul-provider"><a href="#consul-provider" class="headerlink" title="consul-provider"></a>consul-provider</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-provider</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.comtroller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">//注意：新版Spring Cloud Consul默认注册的健康检查地址为/actuator/health</span><br><span class="line">@GetMapping(<span class="string">"/actuator/health"</span>)</span><br><span class="line">public String <span class="function"><span class="title">health</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">public String hello(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"Hello:"</span>+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consul-consumer"><a href="#consul-consumer" class="headerlink" title="consul-consumer"></a>consul-consumer</h3><p>客户端总体和之前Feign写的客户端基本一致….毕竟只是换了一个服务治理的框。</p><h4 id="pom文件-1"><a href="#pom文件-1" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里由于选择Feign作为服务调用的组件。</p><h4 id="启动项添加-EnableFeignClients注解"><a href="#启动项添加-EnableFeignClients注解" class="headerlink" title="启动项添加@EnableFeignClients注解"></a>启动项添加@EnableFeignClients注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringCloudLeaning5ConsulConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning5ConsulConsumerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br></pre></td></tr></table></figure><h4 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">@FeignClient(<span class="string">"consul-provider"</span>)</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">@GetMapping(value=<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">String sayHello(@PathVariable(<span class="string">"name"</span>)String name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.HelloService;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">HelloService helloService;</span><br><span class="line">//注意：新版Spring Cloud Consul默认注册的健康检查地址为/actuator/health</span><br><span class="line">@GetMapping(<span class="string">"/actuator/health"</span>)</span><br><span class="line">public String <span class="function"><span class="title">health</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">public String sayHello(@PathVariable(<span class="string">"name"</span>)String name) &#123;</span><br><span class="line"><span class="built_in">return</span> helloService.sayHello(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动consul ，server，client<br>访问<a href="http://localhost:8082/hello/wangs" target="_blank" rel="noopener">http://localhost:8082/hello/wangs</a><br>页面显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello:wangs</span><br></pre></td></tr></table></figure></p><p>成功~</p><h3 id="consul-config"><a href="#consul-config" class="headerlink" title="consul-config"></a>consul-config</h3><p>整体来讲，写法和Spring Cloud Config基本一致~</p><h4 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-consul-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="application-yml-2"><a href="#application-yml-2" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-config</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br></pre></td></tr></table></figure><h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">@RefreshScope//参数值修改后自动刷新</span><br><span class="line">public class ConfigEntity &#123;</span><br><span class="line">@Value(<span class="string">"<span class="variable">$&#123;foo.bar.name&#125;</span>"</span>)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.ConfigEntity;</span><br><span class="line">@RestController</span><br><span class="line">public class EntityController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">ConfigEntity configEntity;</span><br><span class="line">@GetMapping(<span class="string">"/getName"</span>)</span><br><span class="line">public String <span class="function"><span class="title">getEntityName</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> configEntity.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/actuator/health"</span>)</span><br><span class="line">public String <span class="function"><span class="title">health</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>启动Consul，访问：<a href="http://localhost:8500/ui/dc1/kv，或者访问http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500/ui/dc1/kv，或者访问http://localhost:8500</a>  后点击Key/Value，<br>点击创建，然后输入如下K/V<br><img src="/images/SpringCloud/Consul/consul-3.png"><br>这里解释一下<br>参数的K为config/consul-config/foo.bar.name<br>也就是config文件夹下的consul-config(application name)下的foo.bar.name 这个参数<br>然后value就对应这个参数。</p><p>然后访问<a href="http://localhost:8083/getName" target="_blank" rel="noopener">http://localhost:8083/getName</a>  就可以看到显示的参数为你设置的Value，然后修改参数，再刷新<a href="http://localhost:8083/getName" target="_blank" rel="noopener">http://localhost:8083/getName</a>  就可以看到数值已经修改啦。<br>至此，参数自动刷新已完成。</p><p>参考文献<br>    《重新定义SpringCloud实战》——许进</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Consul简介&quot;&gt;&lt;a href=&quot;#Consul简介&quot; class=&quot;headerlink&quot; title=&quot;Consul简介&quot;&gt;&lt;/a&gt;Consul简介&lt;/h2&gt;&lt;h3 id=&quot;什么是Consul&quot;&gt;&lt;a href=&quot;#什么是Consul&quot; class=&quot;headerlink&quot; title=&quot;什么是Consul&quot;&gt;&lt;/a&gt;什么是Consul&lt;/h3&gt;&lt;p&gt;Consul是一个分布式高可用的服务网络解决方案，提供包含服务发现、配置和分段功能在内的全功能控制面板，这些功能每一个可以单独使用，也可以一起使用以构建完整的服务网络。
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(7)刷新配置中心信息</title>
    <link href="http://yoursite.com/2019/01/14/SpringCloud%E5%AD%A6%E4%B9%A0-7-%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2019/01/14/SpringCloud学习-7-刷新配置中心信息/</id>
    <published>2019-01-14T14:47:56.000Z</published>
    <updated>2019-01-15T12:44:55.781Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们学习了如何通过配置中心客户端获取服务端的配置信息，但是配置信息可能会发生变动，所以这次来学习一下如何手动刷新配置信息，这样不用重启项目也可以获取最新的配置信息</p><p>注：本次代码是延续上次服务端和客户端的代码<a id="more"></a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>在之前的Client客户端的基础上添加以下依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--做简单的安全和端点开放  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个包是安全的依赖，需要进行权限过滤，不进行端点拦截</p><h3 id="application-properties文件"><a href="#application-properties文件" class="headerlink" title="application.properties文件"></a>application.properties文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.health.show-details=always</span><br></pre></td></tr></table></figure><p>由于F版的权限提高了(因为我默认使用的是目前的最新版本SpringBoot2.1.1RELEASE，其自动下载的Cloud包也是最新版，也就是F版)，所以需要额外添加上面的内容。<br>management.endpoints.web.exposure.include=* 这个的意思就是说包含所有端点信息，默认情况下，只是打开了health、info的端点，management.endpoints.health.show-details=always表示总是以详细的信息展示。</p><h3 id="添加安全配置"><a href="#添加安全配置" class="headerlink" title="添加安全配置"></a>添加安全配置</h3><p>创建SecurityConfiguration类继承WebSecurityConfigurerAdapter。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">@Configuration</span><br><span class="line">public class SecurityConfiguration extends WebSecurityConfigurerAdapter&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">http.csrf().<span class="built_in">disable</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码主要是关闭端点的安全效验</p><h3 id="Controller类变更"><a href="#Controller类变更" class="headerlink" title="Controller类变更"></a>Controller类变更</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.comtroller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.ConfigInfoPropertise;</span><br><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private ConfigInfoPropertise configInfoPropertise;</span><br><span class="line">@GetMapping(<span class="string">"/getConfigInfo"</span>)</span><br><span class="line">public String <span class="function"><span class="title">getConfigInfo</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> configInfoPropertise.getConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了一个注解@RefreshScope。</p><h3 id="ConfigInfoPropertise类变更"><a href="#ConfigInfoPropertise类变更" class="headerlink" title="ConfigInfoPropertise类变更"></a>ConfigInfoPropertise类变更</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigInfoPropertise &#123;</span><br><span class="line">@Value(<span class="string">"<span class="variable">$&#123;cn.springcloud.book.config&#125;</span>"</span>)</span><br><span class="line">private String config;</span><br><span class="line"></span><br><span class="line">public String <span class="function"><span class="title">getConfig</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setConfig(String config) &#123;</span><br><span class="line">this.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说说@RefreshScope这个注解的意思吧，被这个注解修饰的Bean都是延时加载的，只有在第一次访问的时候才会被初始化，刷新Bean也是同理，下次访问时会创建一个新的对象。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动server 和client  ，访问<a href="http://localhost:9091/getConfigInfo，页面显示" target="_blank" rel="noopener">http://localhost:9091/getConfigInfo，页面显示</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am the git configuration file from <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>然后修改测试的配置文件，并提交到git上。这时候刷新页面发现内容并没有变化，这时候需要手动刷新一次，访问地址：<a href="http://localhost:9091/actuator/refresh" target="_blank" rel="noopener">http://localhost:9091/actuator/refresh</a><br>注:需要使用post请求方式，请自行使用postman或者soapUI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">"config.client.version"</span>,</span><br><span class="line">    <span class="string">"cn.springcloud.book.config"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后再刷新那个页面，就可以看到显示的内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am the git configuration file from <span class="built_in">test</span> edit2</span><br></pre></td></tr></table></figure></p><p>ps:这是我刚刚改的…..</p><h2 id="案例2-结合Spring-Cloud-Bus-实现热刷新"><a href="#案例2-结合Spring-Cloud-Bus-实现热刷新" class="headerlink" title="案例2 结合Spring Cloud Bus 实现热刷新"></a>案例2 结合Spring Cloud Bus 实现热刷新</h2><p>如果每次都要用户手动刷新的话，那么当服务特别多的时候，那么就会显得特别麻烦，而且如果遗漏的话会导致大量错误，所以我们需要热刷新</p><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p>用户更新配置信息时，检查到git hook变化，触发hook配置地址的调用，Config Server 接收到请求并发布消息，Bus将消息发送到config client,当config client接收到信息后会重新发送请求加载配置信息。<br>所以这里需要用到MQ，这里使用的是RabbitMQ</p><h3 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h3><p>新建项目 config-server-bus</p><h4 id="pom文件-1"><a href="#pom文件-1" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里由于需要用到RabbitMQ，和SpringCloudBus，所以需要导入spring-cloud-starter-bus-amqp 这个包，然后由于需要刷新，所以需要actuator包</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/zxc785009111/wangshun-spring-cloud-config.git</span><br><span class="line">          username: 账号</span><br><span class="line">          password: 密码</span><br><span class="line">          search-paths:</span><br><span class="line">          - SPRING-CLOUD-CONFIG</span><br><span class="line">  application:</span><br><span class="line">    name: sc-config-server-bus-git</span><br><span class="line">    <span class="comment">#配置rabbitmq</span></span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9090</span><br></pre></td></tr></table></figure><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.health.show-details=always</span><br></pre></td></tr></table></figure><h4 id="关闭端点验证"><a href="#关闭端点验证" class="headerlink" title="关闭端点验证"></a>关闭端点验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">@Configuration</span><br><span class="line">/**</span><br><span class="line"> * 关闭端点安全认证</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月15日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class SecurityConfiguration extends WebSecurityConfigurerAdapter&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">http.csrf().<span class="built_in">disable</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类添加-EnableConfigServer注解"><a href="#启动类添加-EnableConfigServer注解" class="headerlink" title="启动类添加@EnableConfigServer注解"></a>启动类添加@EnableConfigServer注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringCloudLeaning4ConfigServerBusApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning4ConfigServerBusApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端编写"><a href="#客户端编写" class="headerlink" title="客户端编写"></a>客户端编写</h3><p>新建项目 config-client-bus</p><h4 id="pom文件-2"><a href="#pom文件-2" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9091</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-client</span><br></pre></td></tr></table></figure><h4 id="appplication-properties"><a href="#appplication-properties" class="headerlink" title="appplication.properties"></a>appplication.properties</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.health.show-details=always</span><br></pre></td></tr></table></figure><h4 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master</span><br><span class="line">      uri:</span><br><span class="line">      - http://localhost:9090</span><br><span class="line">      name: config-info</span><br><span class="line">      profile: <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigInfoPropertise &#123;</span><br><span class="line">@Value(<span class="string">"<span class="variable">$&#123;cn.springcloud.book.config&#125;</span>"</span>)</span><br><span class="line">private String config;</span><br><span class="line"></span><br><span class="line">public String <span class="function"><span class="title">getConfig</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setConfig(String config) &#123;</span><br><span class="line">this.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭端点验证-1"><a href="#关闭端点验证-1" class="headerlink" title="关闭端点验证"></a>关闭端点验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">@Configuration</span><br><span class="line">public class SecurityConfiguration extends WebSecurityConfigurerAdapter&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">http.csrf().<span class="built_in">disable</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.comtroller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.ConfigInfoPropertise;</span><br><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private ConfigInfoPropertise configInfoPropertise;</span><br><span class="line">@GetMapping(<span class="string">"/getConfigInfo"</span>)</span><br><span class="line">public String <span class="function"><span class="title">getConfigInfo</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> configInfoPropertise.getConfig();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的代码基本一致，除了添加了bus的依赖和ribbonMQ，但是添加完成后可以自动实现消息队列的分发还是挺厉害的=。=</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>启动server 和client 访问：<a href="http://localhost:9091/getConfigInfo" target="_blank" rel="noopener">http://localhost:9091/getConfigInfo</a> 显示结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am the git configuration file from <span class="built_in">test</span> will edit4</span><br></pre></td></tr></table></figure></p><p>修改文件并提交到gitHub上，使用soapUI或者postman调用<a href="http://localhost:9090/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:9090/actuator/bus-refresh</a>    (post请求)<br>可以看到client 的日志如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2019-01-15 20:25:10.636  INFO 13752 --- [o-CmCQS57RHFA-1] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration'</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$53af4ef3</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2019-01-15 20:25:11.774  INFO 13752 --- [o-CmCQS57RHFA-1] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://localhost:9090</span><br><span class="line">2019-01-15 20:25:13.617  INFO 13752 --- [o-CmCQS57RHFA-1] c.c.c.ConfigServicePropertySourceLocator : Located environment: name=config-info, profiles=[<span class="built_in">test</span>], label=master, version=56744539e95cf807ac461f2e40faf57304c1dbd8, state=null</span><br><span class="line">2019-01-15 20:25:13.617  INFO 13752 --- [o-CmCQS57RHFA-1] b.c.PropertySourceBootstrapConfiguration : Located property <span class="built_in">source</span>: CompositePropertySource &#123;name=<span class="string">'configService'</span>, propertySources=[MapPropertySource &#123;name=<span class="string">'configClient'</span>&#125;, MapPropertySource &#123;name=<span class="string">'https://github.com/zxc785009111/wangshun-spring-cloud-config.git/SPRING-CLOUD-CONFIG/config-info-test.yml'</span>&#125;]&#125;</span><br><span class="line">2019-01-15 20:25:13.619  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.boot.SpringApplication               : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2019-01-15 20:25:13.626  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.boot.SpringApplication               : Started application <span class="keyword">in</span> 3.902 seconds (JVM running <span class="keyword">for</span> 172.463)</span><br><span class="line">2019-01-15 20:25:13.832  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.cloud.bus.event.RefreshListener      : Received remote refresh request. Keys refreshed []</span><br><span class="line">2019-01-15 20:25:13.911  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [localhost:5672]</span><br><span class="line">2019-01-15 20:25:13.919  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory.publisher<span class="comment">#3c96d22f:0/SimpleConnection@7ca14907 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 49513]</span></span><br><span class="line">2019-01-15 20:25:13.922  INFO 13752 --- [o-CmCQS57RHFA-1] o.s.amqp.rabbit.core.RabbitAdmin         : Auto-declaring a non-durable, auto-delete, or exclusive Queue (springCloudBus.anonymous.0kohNHeDSo-CmCQS57RHFA) durable:<span class="literal">false</span>, auto-delete:<span class="literal">true</span>, exclusive:<span class="literal">true</span>. It will be redeclared <span class="keyword">if</span> the broker stops and is restarted <span class="keyword">while</span> the connection factory is alive, but all messages will be lost.</span><br></pre></td></tr></table></figure></p><p>然后重新访问<a href="http://localhost:9091/getConfigInfo，可以看到显示如下：" target="_blank" rel="noopener">http://localhost:9091/getConfigInfo，可以看到显示如下：</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am the git configuration file from <span class="built_in">test</span> will edit5</span><br></pre></td></tr></table></figure></p><p>这样就说明结合bus做热刷新成功了。<br>当然我们总不能每次配置完成后都手动执行这个刷新的事情，因此可以将地址配置在WebHooks上面，在提交文件之后自动执行刷新的动作。<br>点击项目设置中找到Hooks 即可，当然这是本地项目所以还是有点难度的….</p><p>参考文献：<br>    《重新定义SpringCloud实战》——许进<br>    <a href="https://blog.csdn.net/qq_35098526/article/details/80009424" target="_blank" rel="noopener">https://blog.csdn.net/qq_35098526/article/details/80009424</a> (RabbitMQ安装启动问题)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们学习了如何通过配置中心客户端获取服务端的配置信息，但是配置信息可能会发生变动，所以这次来学习一下如何手动刷新配置信息，这样不用重启项目也可以获取最新的配置信息&lt;/p&gt;
&lt;p&gt;注：本次代码是延续上次服务端和客户端的代码
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(6)配置中心Config</title>
    <link href="http://yoursite.com/2019/01/14/SpringCloud%E5%AD%A6%E4%B9%A0-6-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Config/"/>
    <id>http://yoursite.com/2019/01/14/SpringCloud学习-6-配置中心Config/</id>
    <published>2019-01-14T12:09:58.000Z</published>
    <updated>2019-01-14T14:40:36.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud-Config-配置中心概述"><a href="#Spring-Cloud-Config-配置中心概述" class="headerlink" title="Spring Cloud Config 配置中心概述"></a>Spring Cloud Config 配置中心概述</h2><h3 id="什么是配置中心"><a href="#什么是配置中心" class="headerlink" title="什么是配置中心"></a>什么是配置中心</h3><h4 id="配置中心的由来"><a href="#配置中心的由来" class="headerlink" title="配置中心的由来"></a>配置中心的由来</h4><p>在集中式的开发时代，配置文件基本能够满足，因为那时候配置管理不会成为一个很大的问题，但是在互联网时代，应用都是分布式系统，部署在N台服务器上，想要去献上一台服务器重启肯定不靠谱，而且维护成本也很高，所以配置中心应运而生，配置中心被作用于几种管理不同的欢迎(dev、pr、qa)和不同的集群配置，以及在修改配置后可以将实时动态推送到应用上进行刷新.<a id="more"></a></p><h4 id="配置中心应具有的功能"><a href="#配置中心应具有的功能" class="headerlink" title="配置中心应具有的功能"></a>配置中心应具有的功能</h4><p>1.open API<br>2.业务无关性<br>3.配置生效监控<br>4.一致性K-V存储<br>5.统一配置实时推送<br>6.配合灰度与更新<br>7.配置全局恢复、备份和力士<br>8.高可用集群</p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SpringCloudConfig是一个集中化外部配置的分布式系统，由服务端和客户端组成，不依赖于注册中心，是一个独立的配置中心。其支持多种存储配置文件形态，例如jdbc、Vault、Native、svn、git，其中默认为git</p><h4 id="git版工作原理"><a href="#git版工作原理" class="headerlink" title="git版工作原理"></a>git版工作原理</h4><p>配置客户端启动时会向服务端发起请求，服务端接受到客户端的请求后，根据配置的仓库地址，将git上的文件克隆到本地的一个临时目录中，这个目录是git的本地仓库目录，然后服务端再读取本地文件返回给客户端。这样做的好处是，当git服务器故障或者网络请求异常时，保证服务端仍然可以正常工作。</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="Config-Server创建"><a href="#Config-Server创建" class="headerlink" title="Config Server创建"></a>Config Server创建</h3><h4 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="添加-EnableConfigServer注解开启SpringCloudConfig的服务功能"><a href="#添加-EnableConfigServer注解开启SpringCloudConfig的服务功能" class="headerlink" title="添加@EnableConfigServer注解开启SpringCloudConfig的服务功能"></a>添加@EnableConfigServer注解开启SpringCloudConfig的服务功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class SpringCloudLeaning4ConfigApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning4ConfigApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yml文件配置"><a href="#yml文件配置" class="headerlink" title="yml文件配置"></a>yml文件配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/zxc785009111/wangshun-spring-cloud-config.git</span><br><span class="line">          username: 你的git用户名</span><br><span class="line">          password: 你的git密码</span><br><span class="line">          search-paths:</span><br><span class="line">          - SPRING-CLOUD-CONFIG</span><br><span class="line">  application:</span><br><span class="line">    name: sc-config-git</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9090</span><br></pre></td></tr></table></figure><p>然后建立一个仓库~建立完成之后，在其中创建一个文件夹，这里我起名为SPRING-CLOUD-CONFIG，然后在该目录下创建1个文件，config-info-test.yml,在配置文件中添加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cn: </span><br><span class="line">  springcloud: </span><br><span class="line">    book: </span><br><span class="line">      config: i am the git configuration file from <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>在创建文件之后肯定是要把它上传到gitHub上面的，那么来说说如何在本地上传文件到gitHub 和从gitHub上下载代码<br>上传文件：<a href="https://blog.csdn.net/qq_42815754/article/details/83746492" target="_blank" rel="noopener">https://blog.csdn.net/qq_42815754/article/details/83746492</a><br>下载项目到本地：<a href="https://blog.csdn.net/qq_42815754/article/details/83747583" target="_blank" rel="noopener">https://blog.csdn.net/qq_42815754/article/details/83747583</a><br>上面2个地址写的挺详细的。上传文件大概就是这几个命令git status 、git add xxx、git commit -m “标注” 、git push origin master</p><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>启动项目，访问：<a href="http://localhost:9090/config-info/test/master" target="_blank" rel="noopener">http://localhost:9090/config-info/test/master</a> 可以看到日志中输出了这么一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-14 21:44:29.944  INFO 8020 --- [nio-9090-exec-1] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property <span class="built_in">source</span>: file:/C:/Users/王瞬/AppData/Local/Temp/config-repo-12429596664206551063/SPRING-CLOUD-CONFIG/config-info-test.yml</span><br></pre></td></tr></table></figure></p><p>页面上显示的内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"config-info"</span>,</span><br><span class="line"><span class="string">"profiles"</span>: [<span class="string">"test"</span>],</span><br><span class="line"><span class="string">"label"</span>: <span class="string">"master"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"0911b43ed1eacf8d93d2ccbb5968744bc98b2e36"</span>,</span><br><span class="line"><span class="string">"state"</span>: null,</span><br><span class="line"><span class="string">"propertySources"</span>: [&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"https://github.com/zxc785009111/wangshun-spring-cloud-config.git/SPRING-CLOUD-CONFIG/config-info-test.yml"</span>,</span><br><span class="line"><span class="string">"source"</span>: &#123;</span><br><span class="line"><span class="string">"cn.springcloud.book.config"</span>: <span class="string">"i am the git configuration file from test"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里的话，服务端的配置就暂时告一段落了。接下来说说客户端的配置</p><h3 id="Config-Client-创建"><a href="#Config-Client-创建" class="headerlink" title="Config Client 创建"></a>Config Client 创建</h3><p>创建一个新的项目，config-client</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>为了更好的观察拉去到git上面的配置，这里需要创建一个Controller用于访问返回信息，同时需要创建一个实体，用于注入远程配置上的信息</p><h4 id="实体类代码"><a href="#实体类代码" class="headerlink" title="实体类代码"></a>实体类代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix=<span class="string">"cn.springcloud.book"</span>)</span><br><span class="line">public class ConfigInfoPropertise &#123;</span><br><span class="line"></span><br><span class="line">private String config;</span><br><span class="line"></span><br><span class="line">public String <span class="function"><span class="title">getConfig</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setConfig(String config) &#123;</span><br><span class="line">this.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a>Controller代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.comtroller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.ConfigInfoPropertise;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private ConfigInfoPropertise configInfoPropertise;</span><br><span class="line">@GetMapping(<span class="string">"/getConfigInfo"</span>)</span><br><span class="line">public String <span class="function"><span class="title">getConfigInfo</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> configInfoPropertise.getConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9091</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-client</span><br></pre></td></tr></table></figure><h4 id="bootstrap-yml-配置"><a href="#bootstrap-yml-配置" class="headerlink" title="bootstrap.yml 配置"></a>bootstrap.yml 配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master</span><br><span class="line">      uri:</span><br><span class="line">      - http://localhost:9090</span><br><span class="line">      name: config-info</span><br><span class="line">      profile: <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这里说一下，由于在SpringBoot中，bootstrap.yml是比application.yml优先加载的，所以它会优先加载远程的配置信息，到此客户端中配置完成<br>然后说一下bootstrap.yml中的各个属性<br>label:代表的是请求哪个git分支，这里我是采用的主分支<br>url：代表请求的config-server地址<br>name：代表请求哪个名称的文件，可以写多个，通过逗号隔开<br>profile：代表哪个分支的文件，比如dev、test、prod</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动项目，server 和client 均启动后，可以在client 的控制台看到这么一条日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-01-14 22:19:09.529  INFO 12628 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://localhost:9090</span><br><span class="line">2019-01-14 22:19:21.927  INFO 12628 --- [           main] c.c.c.ConfigServicePropertySourceLocator : Located environment: name=config-info, profiles=[<span class="built_in">test</span>], label=master, version=0911b43ed1eacf8d93d2ccbb5968744bc98b2e36, state=null</span><br></pre></td></tr></table></figure></p><p>也就是说他去服务端那边获取配置信息去了。</p><p>然后访问<a href="http://localhost:9091/getConfigInfo" target="_blank" rel="noopener">http://localhost:9091/getConfigInfo</a><br>页面显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am the git configuration file from <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>参考文献：<br>    <a href="https://blog.csdn.net/qq_42815754/article/details/83746492" target="_blank" rel="noopener">https://blog.csdn.net/qq_42815754/article/details/83746492</a><br>    <a href="https://blog.csdn.net/qq_42815754/article/details/83747583" target="_blank" rel="noopener">https://blog.csdn.net/qq_42815754/article/details/83747583</a><br>    《重新定义SpringCloud实战》——许进</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Cloud-Config-配置中心概述&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Config-配置中心概述&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Config 配置中心概述&quot;&gt;&lt;/a&gt;Spring Cloud Config 配置中心概述&lt;/h2&gt;&lt;h3 id=&quot;什么是配置中心&quot;&gt;&lt;a href=&quot;#什么是配置中心&quot; class=&quot;headerlink&quot; title=&quot;什么是配置中心&quot;&gt;&lt;/a&gt;什么是配置中心&lt;/h3&gt;&lt;h4 id=&quot;配置中心的由来&quot;&gt;&lt;a href=&quot;#配置中心的由来&quot; class=&quot;headerlink&quot; title=&quot;配置中心的由来&quot;&gt;&lt;/a&gt;配置中心的由来&lt;/h4&gt;&lt;p&gt;在集中式的开发时代，配置文件基本能够满足，因为那时候配置管理不会成为一个很大的问题，但是在互联网时代，应用都是分布式系统，部署在N台服务器上，想要去献上一台服务器重启肯定不靠谱，而且维护成本也很高，所以配置中心应运而生，配置中心被作用于几种管理不同的欢迎(dev、pr、qa)和不同的集群配置，以及在修改配置后可以将实时动态推送到应用上进行刷新.
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(5)路由网关Zuul</title>
    <link href="http://yoursite.com/2019/01/13/SpringCloud%E5%AD%A6%E4%B9%A0-5-%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3Zuul/"/>
    <id>http://yoursite.com/2019/01/13/SpringCloud学习-5-路由网关Zuul/</id>
    <published>2019-01-13T07:21:39.000Z</published>
    <updated>2019-01-14T07:36:46.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Zuul作为路由网关组件，在微服务架构中有着非常重要的作用，用于构建便捷服务(Edge-Service)，致力于动态路由、过滤、监控、弹性伸缩和安全，主要体现在以下六个方面<br>1.Zuul、Ribbon以及Eureka相结合，可以实现智能路由和负载均衡，Zuul等能够将请求流量按照某种策略分发到集群状态的多个服务实例。<br>2.网关将所有服务的API接口整合，并统一对外暴露，外接系统调用API接口时，都是由网关对外暴露的API接口，外接系统不需要知道微服务中个服务相互调用的复杂性。微服务系统也保护了其内部微服务单元的API接口，防止被外界接口调用导致服务敏感信息对外暴露。<br>3.网关服务可以做用户身份认证和权限认证，防止非法请求操作API接口，对服务器起到保护作用。<br>4.网关可以实现监控功能，实时日志输出，对请求进行记录。<br>5.网关可以实现流量监控，在高流量的情况下，对服务进行降级。<br>6.API接口从内部服务器分离出来，方便做测试。<br>……<a id="more"></a></p><h3 id="Zuul的工作原理"><a href="#Zuul的工作原理" class="headerlink" title="Zuul的工作原理"></a>Zuul的工作原理</h3><p>Zuul是通过Servlet来实现的，Zuul通过自定义的ZuulServlet(类似于SpringMVC的DispatcherServlet)来对请求进行控制，Zuul的核心是一系列的过滤器，可以在Http请求发起和响应返回期间执行一系列的过滤器。Zuul包含以下四种过滤器<br>1.PRE过滤器：它是请求路由到具体服务之前执行的，这种类型的过滤器可以作为安全验证，如参数验证，身份验证等等。<br>2.ROUTING过滤器：它用于请求路由到具体的微服务实例，在默认情况下，它使用Http Client进行网络请求。<br>3.POST过滤器：它是在请求已经被路由到微服务后执行的，一般情况下，用作收集统计信息、指标，以及将相应传输给客户端。<br>4.ERROR过滤器:它是在其他过滤器发生错误时执行的。</p><p>Zuul采取动态读取、编译和运行这些过滤器，过滤器之间不能直接相互通信，而是通过RequestContext对象来共享数据，每个请求都会创建一个这样的对象。Zuul过滤器具有以下关键特征<br>1.TYPE:Zuul过滤器的类型，这个类型决定了过滤器在请求的那个阶段起作用。<br>2.Execution Order：规定了过滤器的执行顺序，order值越小，越先执行。<br>3.Criteria：Filter执行所需要的条件<br>4.Action:若符合执行条件，则执行Action(即逻辑代码)。</p><p>当一个客户端Request请求进入Zuul网关服务时，网关首先进入”pre filter”,进行一系列的验证、操作或者判断。然后交给”routing filter”进行路由转发，转发到具体的服务实例进行逻辑处理、返回数据，将Response信息返回给客户端。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="搭建Zuul服务"><a href="#搭建Zuul服务" class="headerlink" title="搭建Zuul服务"></a>搭建Zuul服务</h3><p>创建项目，选择引入Web、Eureka-client、Zuul的包</p><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="在启动类上添加-EnableZuulProxy注解"><a href="#在启动类上添加-EnableZuulProxy注解" class="headerlink" title="在启动类上添加@EnableZuulProxy注解"></a>在启动类上添加@EnableZuulProxy注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">public class SpringCloudLeaning3ZuulClientApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning3ZuulClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-zuul</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br><span class="line">      </span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    hiapi: </span><br><span class="line">      path: /hiapi/**</span><br><span class="line">      serviceId: eureka-client</span><br><span class="line">      </span><br><span class="line">    ribbonapi: </span><br><span class="line">      path: /ribbonapi/**</span><br><span class="line">      serviceId: eureka-ribbon-client</span><br><span class="line">    feignapi: </span><br><span class="line">      path: /feignclient/**</span><br><span class="line">      serviceId: eureka-feign-client</span><br></pre></td></tr></table></figure><p>这里着重说一下这个配置文件中Zuul的配置，在本案例中，Zuul.routes.hiapi.path 和serviceId，这两个配置就可以将所有的/hiapi开头的Url路由到eureka-client服务，其中这个”hiapi”是自己定义的，需要制定它的url和serviceId，如果某个服务存在多个实例，那么Zuul结合Ribbon会做负载均衡，将请求均分的部分路由到不同的服务实例。</p><p>启动eureka-server,eureka-client（启动两个）,eureka-ribbon-client、eureka-fegin-client，在浏览器多次访问<a href="http://localhost:5000/hiapi/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:5000/hiapi/hello/785009111@qq.com</a> ，浏览器会交替显示如下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port:8762 Email:785009111@qq.com</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port:8763 Email:785009111@qq.com</span><br></pre></td></tr></table></figure><p>同理：访问<a href="http://localhost:5000/feignclient/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:5000/feignclient/hello/785009111@qq.com</a>  因为其集成了Feign，同样会交替显示上面的2个内容</p><p>如果说你不需要做Ribbon做负载均衡，可以指定服务实例的Url，用zuul.routes.hiapi.url配置指定，这样就不需要配置serviceId了，但是一般情况不使用这种，除非是此请求比较大，单开服务器这种等等..</p><p>如果说你想指定Url，还想做负载均衡，那么就需要你自己维护负载均衡服务注册列表。首先，需要把ribbon.eureka.enable改成false，然后需要自己维护一份注册列表，以之前写好的hiapi-v1为例，通过配置hiapi-v1.ribbon.listOfServers来配置多个负载均衡，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-zuul</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br><span class="line">ribbon:</span><br><span class="line">  eureka:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    hiapi: </span><br><span class="line">      path: /hiapi/**</span><br><span class="line">      serviceId: hiapi-v1</span><br><span class="line">      </span><br><span class="line">    ribbonapi: </span><br><span class="line">      path: /ribbonapi/**</span><br><span class="line">      serviceId: eureka-ribbon-client</span><br><span class="line">    feignapi: </span><br><span class="line">      path: /feignclient/**</span><br><span class="line">      serviceId: eureka-feign-client</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">hiapi-v1: </span><br><span class="line">  ribbon: </span><br><span class="line">    listOfServers: http://localhost:8762,http://localhost:8763</span><br></pre></td></tr></table></figure></p><h4 id="Zuul-使用熔断器"><a href="#Zuul-使用熔断器" class="headerlink" title="Zuul 使用熔断器"></a>Zuul 使用熔断器</h4><p>想在Zuul中实现熔断器，需要实现FallbackProvider 接口，此接口有一个getRoute()方法，用于指定熔断器功能应用于那些路由服务</p><h5 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.hystrix;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.http.client.ClientHttpResponse;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class ZuulHtstrix implements FallbackProvider&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123;</span><br><span class="line"><span class="built_in">return</span> new <span class="function"><span class="title">ClientHttpResponse</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public HttpHeaders <span class="function"><span class="title">getHeaders</span></span>() &#123;</span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line"><span class="built_in">return</span> headers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public InputStream getBody() throws IOException &#123;</span><br><span class="line"><span class="built_in">return</span> new ByteArrayInputStream(<span class="string">"error!i am the fallback!"</span>.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String getStatusText() throws IOException &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public HttpStatus getStatusCode() throws IOException &#123;</span><br><span class="line"><span class="built_in">return</span> HttpStatus.OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getRawStatusCode() throws IOException &#123;</span><br><span class="line"><span class="built_in">return</span> 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">close</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">getRoute</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"eureka-client"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动eureka-server和zuul-client  然后访问地址：<a href="http://localhost:5000/hiapi/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:5000/hiapi/hello/785009111@qq.com</a><br>页面会显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error!i am the fallback!</span><br></pre></td></tr></table></figure></p><p>如果需要所有的服务都加熔断功能，只需要在getRoute()方法上返回一个*<br>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">getRoute</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"*"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="在Zuul中使用过滤器"><a href="#在Zuul中使用过滤器" class="headerlink" title="在Zuul中使用过滤器"></a>在Zuul中使用过滤器</h4><p>自定义一个过滤器其实并不复杂，只需要集成ZuulFilter，并实现其中的抽象方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.filters;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line">import com.netflix.zuul.exception.ZuulException;</span><br><span class="line">@Component</span><br><span class="line">public class MyZuulFilter extends ZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object run() throws ZuulException &#123;</span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request = ctx.getRequest();</span><br><span class="line">String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(token)) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ctx.getResponse().getWriter().write(<span class="string">"token is empty"</span>);</span><br><span class="line">ctx.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean <span class="function"><span class="title">shouldFilter</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int <span class="function"><span class="title">filterOrder</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">filterType</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"pre"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>filterType()这个方法是指设置条件类型，就和之前说的4个一致。<br>filterOrder()是指过滤顺序，数字越小越先执行<br>shouldFilter()这个表示该过滤器是否过滤逻辑，如果为true,则执行run方法，否则不执行<br>run()  就是执行判断逻辑</p><p>这里有一点需要注意的：就是重写response的时候  一定要写ctx.setSendZuulResponse(false);</p><p>否则会报错Caused by: java.lang.IllegalStateException: getWriter() has already been called for this response</p><p>启动eureka-server,zuul-client,访问<a href="http://localhost:5001/hiapi/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:5001/hiapi/hello/785009111@qq.com</a><br>显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token is empty</span><br></pre></td></tr></table></figure></p><p>访问：<a href="http://localhost:5001/hiapi/hello/785009111@qq.com?token=123" target="_blank" rel="noopener">http://localhost:5001/hiapi/hello/785009111@qq.com?token=123</a><br>显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error!i am the fallback!</span><br></pre></td></tr></table></figure></p><p>没毛病emmmm因为我eureka-client没启动…..</p><p>参考文献：<br>    《深入理解Spring Cloud与微服务构建》——方志朋</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Zuul作为路由网关组件，在微服务架构中有着非常重要的作用，用于构建便捷服务(Edge-Service)，致力于动态路由、过滤、监控、弹性伸缩和安全，主要体现在以下六个方面&lt;br&gt;1.Zuul、Ribbon以及Eureka相结合，可以实现智能路由和负载均衡，Zuul等能够将请求流量按照某种策略分发到集群状态的多个服务实例。&lt;br&gt;2.网关将所有服务的API接口整合，并统一对外暴露，外接系统调用API接口时，都是由网关对外暴露的API接口，外接系统不需要知道微服务中个服务相互调用的复杂性。微服务系统也保护了其内部微服务单元的API接口，防止被外界接口调用导致服务敏感信息对外暴露。&lt;br&gt;3.网关服务可以做用户身份认证和权限认证，防止非法请求操作API接口，对服务器起到保护作用。&lt;br&gt;4.网关可以实现监控功能，实时日志输出，对请求进行记录。&lt;br&gt;5.网关可以实现流量监控，在高流量的情况下，对服务进行降级。&lt;br&gt;6.API接口从内部服务器分离出来，方便做测试。&lt;br&gt;……
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(4)熔断器Hystrix</title>
    <link href="http://yoursite.com/2019/01/13/SpringCloud%E5%AD%A6%E4%B9%A0-4-%E7%86%94%E6%96%AD%E5%99%A8Hystrix/"/>
    <id>http://yoursite.com/2019/01/13/SpringCloud学习-4-熔断器Hystrix/</id>
    <published>2019-01-13T04:50:56.000Z</published>
    <updated>2019-01-14T08:14:03.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hystrix简介"><a href="#Hystrix简介" class="headerlink" title="Hystrix简介"></a>Hystrix简介</h2><h3 id="Hystrix是什么"><a href="#Hystrix是什么" class="headerlink" title="Hystrix是什么"></a>Hystrix是什么</h3><p>在分布式系统中，服务与服务之间的依赖错综复杂，不可避免的情况就是某些服务出现故障，导致依赖于它们的其他服务出现远程调用的线程阻塞，Hystrix是Netfix公司开源的一个项目，它提供了熔断器的功能，能够阻止分布式系统中出现联动故障。Hystrix是通过隔离服务的访问点阻止联动故障的，并提供了故障的解决方案，从而提高整个分布式系统的弹性。</p><h3 id="Hystrix解决了什么问题"><a href="#Hystrix解决了什么问题" class="headerlink" title="Hystrix解决了什么问题"></a>Hystrix解决了什么问题</h3><p>假设某一个应用程序依赖了30个服务，每个服务的正常运行时间为99.99%，对于单个服务而言，这几乎是完美的，但是30个服务一起就只有99.7%的正常运行时间和百分之0.3的不可用时间，那么10亿次请求中就有三百万次的失败，实际情况比这可能还要糟糕。<br>当某个服务出现网络故障的时候，整个用户的请求会出现阻塞状态，在高并发的情况下，单个服务的不可用会导致整个请求都处于延迟状态，可能在几秒钟就会导致整个服务先整负载饱和导致宕机。这就是雪崩效应。</p><p>为了防止雪崩效应，因此产生了熔断器模型，Hystrix是在目前表现非常好的一个熔断器模型实现的开源组件，它是SpringCloud组件不可或缺的一部分……<a id="more"></a></p><h3 id="Hystrix设计原则"><a href="#Hystrix设计原则" class="headerlink" title="Hystrix设计原则"></a>Hystrix设计原则</h3><p>1.防止单个服务的故障耗尽整个服务的Servlet容器的线程资源</p><p>2.快速失败机制，如果某一个服务出现故障，则调用该服务的请求快速失败，而不是线程等待。</p><p>3.提供回退(fallback)方案，在请求发生故障时，提供设定好的回退方案</p><p>4.使用熔断机制，防止故障扩散到其他服务</p><p>5.提供熔断器的监控组件Hystrix Dashboard，可以实时监控熔断器的状态</p><h3 id="Hystrix工作机制"><a href="#Hystrix工作机制" class="headerlink" title="Hystrix工作机制"></a>Hystrix工作机制</h3><p>首先，当某个API接口的失败次数在一定时间内小于设定的阈值时，熔断器处于关闭，该API正常提供服务，当该API接口处理请求失败次数大于设定阈值时，Hystrix判定该API出现故障，打开熔断器，此时请求该API的接口会执行快速失败逻辑(即fallback回退的逻辑)，不执行业务逻辑，请求的线程不会出于阻塞状态。处于打开状态的熔断器，在一段时间之后会处于半打开的状态，并将一定数量的请求执行正常逻辑，其他的会执行快速失败，若执行正常的请求失败了，则熔断器继续打开，否则熔断器关闭，这样熔断器就具有了自我修复的能力。</p><h2 id="在RestTemplate和Ribbon-上使用熔断器"><a href="#在RestTemplate和Ribbon-上使用熔断器" class="headerlink" title="在RestTemplate和Ribbon 上使用熔断器"></a>在RestTemplate和Ribbon 上使用熔断器</h2><h3 id="pom文件添加依赖"><a href="#pom文件添加依赖" class="headerlink" title="pom文件添加依赖"></a>pom文件添加依赖</h3><p>首先在之前写过的基于RestTemplate和Ribbon的项目中的pom文件中添加以下依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="项目启动项添加-EnableHystrix注解"><a href="#项目启动项添加-EnableHystrix注解" class="headerlink" title="项目启动项添加@EnableHystrix注解"></a>项目启动项添加@EnableHystrix注解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class SpringCloudLeaning1RibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1RibbonApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造Service"><a href="#改造Service" class="headerlink" title="改造Service"></a>改造Service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RibbonService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@HystrixCommand(fallbackMethod=<span class="string">"helloError"</span>)</span><br><span class="line">public String hello(String email) &#123;</span><br><span class="line"><span class="built_in">return</span> restTemplate.getForObject(<span class="string">"http://PRODUCT/hello?email="</span>+email,String.class );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String helloError(String email) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"helllo"</span>+email+<span class="string">",sorry,error"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上加入@HystrixCommand  这样这个方法就开启了熔断器功能，其中fallbackMethod是为了处理回退所执行的方法。</p><p>运行服务端，客户端和ribbon客户端，访问<a href="http://localhost:8764/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:8764/hello/785009111@qq.com</a><br>这里页面返回的结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helllo785009111@qq.com,sorry,error</span><br></pre></td></tr></table></figure></p><p>直接就执行了错误的方法，原因是因为我之前在写Feign的时候把application-name给改了..改成了eureka-client，而这里还是沿用的product，将product改成eureka-client 再执行一次就可以发现正常的响应了。</p><p>除了这种出现方式，正常的测试应该是将服务提供方的客户端关闭，使得无法调用来测试，当然前缀写错也是无法调用的233333</p><h2 id="在Feign上使用熔断器"><a href="#在Feign上使用熔断器" class="headerlink" title="在Feign上使用熔断器"></a>在Feign上使用熔断器</h2><h3 id="pon文件添加依赖"><a href="#pon文件添加依赖" class="headerlink" title="pon文件添加依赖"></a>pon文件添加依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置文件中配置开启hystrix"><a href="#配置文件中配置开启hystrix" class="headerlink" title="配置文件中配置开启hystrix"></a>配置文件中配置开启hystrix</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-feign-client</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8765</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br><span class="line">      </span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>只有最后那一部分是额外添加的，开始hystrix功能</p><p>Feign中对于熔断逻辑的配置是在@FeignClient注解上的，其写法为callback=xxx.class，其中xxx必须实现被@FeignClient注解修饰的接口,最后需要以SpringBean的形式注入到IOC容器中</p><h3 id="熔断器处理逻辑类"><a href="#熔断器处理逻辑类" class="headerlink" title="熔断器处理逻辑类"></a>熔断器处理逻辑类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IEurekaClientFeign;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class HiHystrix implements IEurekaClientFeign&#123;</span><br><span class="line">@Override</span><br><span class="line">public String sayHelloFromEurekaClient(String email) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"hi:"</span>+email+<span class="string">",sorry,error!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改IEurekaClientFeign接口"><a href="#修改IEurekaClientFeign接口" class="headerlink" title="修改IEurekaClientFeign接口"></a>修改IEurekaClientFeign接口</h3><p>其实就是在注解后面加一个fallback=xxx.class<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.config.FeignConfig;</span><br><span class="line">import com.wangshun.leaning.service.impl.HiHystrix;</span><br><span class="line"></span><br><span class="line">@FeignClient(value=<span class="string">"eureka-client"</span>,configuration=FeignConfig.class,fallback=HiHystrix.class)</span><br><span class="line">public interface IEurekaClientFeign &#123;</span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;email&#125;"</span>)</span><br><span class="line">String sayHelloFromEurekaClient(@PathVariable(<span class="string">"email"</span>) String email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="测试，启动server，client和feign-client-访问http-localhost-8765-hello-785009111-qq-com"><a href="#测试，启动server，client和feign-client-访问http-localhost-8765-hello-785009111-qq-com" class="headerlink" title="测试，启动server，client和feign-client,访问http://localhost:8765/hello/785009111@qq.com"></a>测试，启动server，client和feign-client,访问<a href="http://localhost:8765/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:8765/hello/785009111@qq.com</a></h3><p>显示内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port:8762 Email:785009111@qq.com</span><br></pre></td></tr></table></figure></p><p>关闭eureka-client，重新访问<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi:785009111@qq.com,sorry,error!</span><br></pre></td></tr></table></figure></p><h2 id="使用Hystrix-DashBoard-监控熔断器状态"><a href="#使用Hystrix-DashBoard-监控熔断器状态" class="headerlink" title="使用Hystrix DashBoard 监控熔断器状态"></a>使用Hystrix DashBoard 监控熔断器状态</h2><p>Hystrix DashBoard 是监控Hystrix的熔断器状况的一个组件，提供了数据监控和友好的展示界面</p><h3 id="在RestTemplate中使用"><a href="#在RestTemplate中使用" class="headerlink" title="在RestTemplate中使用"></a>在RestTemplate中使用</h3><h4 id="pom文件中添加依赖"><a href="#pom文件中添加依赖" class="headerlink" title="pom文件中添加依赖"></a>pom文件中添加依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="在程序启动类上添加-注解开启Hystrix-DashBoard的功能"><a href="#在程序启动类上添加-注解开启Hystrix-DashBoard的功能" class="headerlink" title="在程序启动类上添加 注解开启Hystrix DashBoard的功能"></a>在程序启动类上添加 注解开启Hystrix DashBoard的功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line">import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class SpringCloudLeaning1RibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1RibbonApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动server ，eureka-client和ribbon-client，访问<a href="http://localhost:8764/hystrix，即可看到以下界面" target="_blank" rel="noopener">http://localhost:8764/hystrix，即可看到以下界面</a><br><img src="/images/SpringCloud/Hystrix/hystrix-1.png"><br>参考文献：<br>    《深入理解Spring Cloud与微服务构建》——方志朋</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hystrix简介&quot;&gt;&lt;a href=&quot;#Hystrix简介&quot; class=&quot;headerlink&quot; title=&quot;Hystrix简介&quot;&gt;&lt;/a&gt;Hystrix简介&lt;/h2&gt;&lt;h3 id=&quot;Hystrix是什么&quot;&gt;&lt;a href=&quot;#Hystrix是什么&quot; class=&quot;headerlink&quot; title=&quot;Hystrix是什么&quot;&gt;&lt;/a&gt;Hystrix是什么&lt;/h3&gt;&lt;p&gt;在分布式系统中，服务与服务之间的依赖错综复杂，不可避免的情况就是某些服务出现故障，导致依赖于它们的其他服务出现远程调用的线程阻塞，Hystrix是Netfix公司开源的一个项目，它提供了熔断器的功能，能够阻止分布式系统中出现联动故障。Hystrix是通过隔离服务的访问点阻止联动故障的，并提供了故障的解决方案，从而提高整个分布式系统的弹性。&lt;/p&gt;
&lt;h3 id=&quot;Hystrix解决了什么问题&quot;&gt;&lt;a href=&quot;#Hystrix解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;Hystrix解决了什么问题&quot;&gt;&lt;/a&gt;Hystrix解决了什么问题&lt;/h3&gt;&lt;p&gt;假设某一个应用程序依赖了30个服务，每个服务的正常运行时间为99.99%，对于单个服务而言，这几乎是完美的，但是30个服务一起就只有99.7%的正常运行时间和百分之0.3的不可用时间，那么10亿次请求中就有三百万次的失败，实际情况比这可能还要糟糕。&lt;br&gt;当某个服务出现网络故障的时候，整个用户的请求会出现阻塞状态，在高并发的情况下，单个服务的不可用会导致整个请求都处于延迟状态，可能在几秒钟就会导致整个服务先整负载饱和导致宕机。这就是雪崩效应。&lt;/p&gt;
&lt;p&gt;为了防止雪崩效应，因此产生了熔断器模型，Hystrix是在目前表现非常好的一个熔断器模型实现的开源组件，它是SpringCloud组件不可或缺的一部分……
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(3)声明式调用Feign</title>
    <link href="http://yoursite.com/2019/01/12/SpringCloud%E5%AD%A6%E4%B9%A0-3-%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B0%83%E7%94%A8Feign/"/>
    <id>http://yoursite.com/2019/01/12/SpringCloud学习-3-声明式调用Feign/</id>
    <published>2019-01-12T07:24:07.000Z</published>
    <updated>2019-01-12T10:23:12.652Z</updated>
    
    <content type="html"><![CDATA[<p>在之前学习了如何使用RestTemplate来消费服务，如何结合Ribbon在消费服务的时候实现负载均衡，这次来说说Feign…….<a id="more"></a></p><p>Feign采用的是声明式API的接口风格，将 Java Http客户端绑定在其内部，Feign的首要目标是将Java Http客户端的调用过程变得简单。</p><h2 id="写一个Feign客户端"><a href="#写一个Feign客户端" class="headerlink" title="写一个Feign客户端"></a>写一个Feign客户端</h2><p>新建一个SpringBoot项目，例如eureka-feign-client</p><h3 id="pon依赖"><a href="#pon依赖" class="headerlink" title="pon依赖"></a>pon依赖</h3><p>这里需要依赖eureka client 和feign的包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-feign-client</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8764</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br></pre></td></tr></table></figure><p>配置文件和之前的差距不大，基本一致</p><h3 id="启动项添加-EnableFeignClients开启Fegin"><a href="#启动项添加-EnableFeignClients开启Fegin" class="headerlink" title="启动项添加@EnableFeignClients开启Fegin"></a>启动项添加@EnableFeignClients开启Fegin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class SpringCloudLeaning2FeiginClientApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning2FeiginClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三步结束之后，该程序就已经具备了Feign的功能，接下来来写一个程序来远程调用eureka-client的”/hello”接口<br>在写这个接口之前，先来说说这个接口需要什么，这个接口需要使用一个注解@FeignClient来声明这是一个Feign Client，注解中需要使用2个属性 value 指的是远程服务的服务名，configuration指的是其客户端的配置类，</p><h3 id="Feign-配置类"><a href="#Feign-配置类" class="headerlink" title="Feign 配置类"></a>Feign 配置类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import feign.Retryer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line">@Bean</span><br><span class="line">public Retryer <span class="function"><span class="title">feignRetruer</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Retryer.Default(100, TimeUnit.SECONDS.toMillis(1), 5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了Retryer 这个Bean的注入，这样的话Feign在远程调用失败以后会自动进行重试。</p><h3 id="Feign-接口"><a href="#Feign-接口" class="headerlink" title="Feign 接口"></a>Feign 接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.config.FeignConfig;</span><br><span class="line"></span><br><span class="line">@FeignClient(value=<span class="string">"eureka-client"</span>,configuration=FeignConfig.class)</span><br><span class="line">public interface IEurekaClientFeign &#123;</span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;email&#125;"</span>)</span><br><span class="line">String sayHelloFromEurekaClient(@PathVariable(<span class="string">"email"</span>) String emal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是@FeignClient，这个注解是开启Feign客户端，只能用于接口的一个注解，后面的2个属性value  就是指定其访问的服务提供方的客户端名称，config就是这个客户端的配置类。</p><p>这里要注意的是首先是接口中的方法，方法上面的注解是比如和你要调用的接口的内容一致的，比如我们调用的是一个get接口，地址为/hello/{email}（这里服务提供方的接口被我改动了，改成了restful的接口风格，配置文件中服务名也被我从product 改成了eureka-client）,那么这里的地址也要这么写，请求方式为get，那么这里可以requestMapping注解中添加属性，或者直接@GetMapping都可以。</p><p>再说说方法中的参数，这里默认的传参注解和你要调用的方法中的内容是要写的完全一致~，我刚才尝试了把@PathVariable改成了@requestParam(“email”)，这样也是可以的，但是最好默认和调用接口保持一致。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IEurekaClientFeign;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class HelloService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IEurekaClientFeign eurekaClientFeign;</span><br><span class="line"></span><br><span class="line">public String hello(String email) &#123;</span><br><span class="line"><span class="built_in">return</span> eurekaClientFeign.sayHelloFromEurekaClient(email);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.impl.HelloService;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class Controller &#123;</span><br><span class="line">@Autowired</span><br><span class="line">HelloService helloService;</span><br><span class="line">@RequestMapping(<span class="string">"/hello/&#123;email&#125;"</span>)</span><br><span class="line">public String hello(@PathVariable(<span class="string">"email"</span>)String email) &#123;</span><br><span class="line"><span class="built_in">return</span> helloService.hello(email);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用SOAPui 或者postMan测试一下就可以了，访问<a href="http://localhost:8765/hello/785009111@qq.com，页面会轮流显示port:8762" target="_blank" rel="noopener">http://localhost:8765/hello/785009111@qq.com，页面会轮流显示port:8762</a> Email:<a href="mailto:785009111@qq.com" target="_blank" rel="noopener">785009111@qq.com</a>  和port:8763 Email:<a href="mailto:785009111@qq.com" target="_blank" rel="noopener">785009111@qq.com</a></p><p>目前测试的结果，Feign对于2个节点的负载均衡的概率大概是1比1  感觉比Ribbon 原本的要好一些~</p><p>参考文献：<br>    《深入理解Spring Cloud与微服务构建》——方志朋</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前学习了如何使用RestTemplate来消费服务，如何结合Ribbon在消费服务的时候实现负载均衡，这次来说说Feign…….
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(2)负载均衡Ribbon与RestTemplate结合</title>
    <link href="http://yoursite.com/2019/01/10/SpringCloud%E5%AD%A6%E4%B9%A0-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Ribbon/"/>
    <id>http://yoursite.com/2019/01/10/SpringCloud学习-2-负载均衡Ribbon/</id>
    <published>2019-01-10T13:18:58.000Z</published>
    <updated>2019-01-12T07:24:52.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="负载均衡简介"><a href="#负载均衡简介" class="headerlink" title="负载均衡简介"></a>负载均衡简介</h2><p>负载均衡是指将负载分摊到多个执行单元上，常见的负载均衡有两种，一种是独立进程单元，通过负载均衡策略，将请求分发到不同的执行单元上，例如Nginx，另一种是将负载均衡逻辑以代码的型视封装到服务消费者的客户端上，服务消费者通过客户端维护了一份服务提供者的列表，有了信息列表，通过负载均衡策略将请求分摊到多个服务提供者，从而达到负载均衡的目的</p><h2 id="Ribbon-简介"><a href="#Ribbon-简介" class="headerlink" title="Ribbon 简介"></a>Ribbon 简介</h2><p>Ribbon 是Netfix公司开源的一个负载均衡的组件，它属于上述的第二种方式，是将负载均衡的逻辑封装再客户端，并运行在客户端的进程里。Ribbon是一个经过云端测试的IPC库，可以很好的控制HTTP和TCP客户端的负载均衡行为</p><p>在SpringCloud中，Ribbon作为服务消费者的负载均衡，有两种使用方式，一种是和RestTemplate结合，还有一种是和Feign结合，这次先说前者……<a id="more"></a></p><h2 id="Ribbon-结合RestTemplate实现负载均衡"><a href="#Ribbon-结合RestTemplate实现负载均衡" class="headerlink" title="Ribbon 结合RestTemplate实现负载均衡"></a>Ribbon 结合RestTemplate实现负载均衡</h2><p>在之前的项目中，写过一个eureka server  一个eureka client ，先启动eureka server 在启动2个eureka client (启动一次修改端口号就好)  然后访问localhost:8761,可以看到以下的图</p><p><img src="/images/SpringCloud/Ribbon/ribbon-1.png">    </p><p>再创建一个项目，也是一个客户端，采用restTemplate  来远程调用之前写好的API接口 ，实现负载均衡</p><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="yml文件"><a href="#yml文件" class="headerlink" title="yml文件"></a>yml文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-ribbon-client</span><br><span class="line">server:</span><br><span class="line">  port: 8764</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br></pre></td></tr></table></figure><p>配置文件的服务注册的地址依旧是指向之前的服务端</p><h3 id="RestApi-接口"><a href="#RestApi-接口" class="headerlink" title="RestApi 接口"></a>RestApi 接口</h3><p>接下来需要用到一个Restful API，在API中使用我们之前client写好的接口，即服务消费，在调用client的时候，我们希望轮流访问这2个实例，这时候也就需要使用RestTemplate和Ribbon</p><h4 id="注入RestTemplate-并且开启负载均衡"><a href="#注入RestTemplate-并且开启负载均衡" class="headerlink" title="注入RestTemplate 并且开启负载均衡"></a>注入RestTemplate 并且开启负载均衡</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RibbonConfig &#123;</span><br><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">RestTemplate <span class="function"><span class="title">restTemplate</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把RestTemplate注入到IOC容器中并加上@LoadBalanced注解，两者即可结合在一起。</p><h4 id="Service-类编写"><a href="#Service-类编写" class="headerlink" title="Service 类编写"></a>Service 类编写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RibbonService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">public String hello(String email) &#123;</span><br><span class="line"><span class="built_in">return</span> restTemplate.getForObject(<span class="string">"http://PRODUCT/hello?email="</span>+email,String.class );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实有一个很神奇的地方就是我http后面跟的是客户端的application-name，这样居然可以访问….没见过…</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.RibbonService;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RibbonController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">RibbonService ribbonService;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/hello/&#123;email&#125;"</span>)</span><br><span class="line">public String hillo(@PathVariable(<span class="string">"email"</span>) String email) &#123;</span><br><span class="line"><span class="built_in">return</span> ribbonService.hello(email);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写完之后启动项目，先启动服务端，启动2个客户端和这个ribbon 客户端。<br>然后访问localhost:8761，可以看到下图<br><img src="/images/SpringCloud/Ribbon/ribbon-2.png">    </p><p>然后使用postman进行测试，访问<a href="http://localhost:8764/hello/785009111@qq.com" target="_blank" rel="noopener">http://localhost:8764/hello/785009111@qq.com</a><br>负载均衡测试图如下：</p><p><img src="/images/SpringCloud/Ribbon/ribbon-3.png"><br><img src="/images/SpringCloud/Ribbon/ribbon-4.png">    </p><p>至此，测试完成，客户端ribbon 实现了对于product 客户端负载均衡。</p><p>参考文献：<br>    《深入理解Spring Cloud与微服务构建》——方志朋</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;负载均衡简介&quot;&gt;&lt;a href=&quot;#负载均衡简介&quot; class=&quot;headerlink&quot; title=&quot;负载均衡简介&quot;&gt;&lt;/a&gt;负载均衡简介&lt;/h2&gt;&lt;p&gt;负载均衡是指将负载分摊到多个执行单元上，常见的负载均衡有两种，一种是独立进程单元，通过负载均衡策略，将请求分发到不同的执行单元上，例如Nginx，另一种是将负载均衡逻辑以代码的型视封装到服务消费者的客户端上，服务消费者通过客户端维护了一份服务提供者的列表，有了信息列表，通过负载均衡策略将请求分摊到多个服务提供者，从而达到负载均衡的目的&lt;/p&gt;
&lt;h2 id=&quot;Ribbon-简介&quot;&gt;&lt;a href=&quot;#Ribbon-简介&quot; class=&quot;headerlink&quot; title=&quot;Ribbon 简介&quot;&gt;&lt;/a&gt;Ribbon 简介&lt;/h2&gt;&lt;p&gt;Ribbon 是Netfix公司开源的一个负载均衡的组件，它属于上述的第二种方式，是将负载均衡的逻辑封装再客户端，并运行在客户端的进程里。Ribbon是一个经过云端测试的IPC库，可以很好的控制HTTP和TCP客户端的负载均衡行为&lt;/p&gt;
&lt;p&gt;在SpringCloud中，Ribbon作为服务消费者的负载均衡，有两种使用方式，一种是和RestTemplate结合，还有一种是和Feign结合，这次先说前者……
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(1)服务治理与服务发现——Eurka</title>
    <link href="http://yoursite.com/2019/01/09/SpringCloud%E5%AD%A6%E4%B9%A0-1-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%8F%91%E7%8E%B0%E2%80%94%E2%80%94Eurka/"/>
    <id>http://yoursite.com/2019/01/09/SpringCloud学习-1-服务治理与服务发发现——Eurka/</id>
    <published>2019-01-09T14:21:05.000Z</published>
    <updated>2019-01-09T16:29:17.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h2><p>1.是纯正的 servlet 应用，需构建成jar/war包部署</p><p>2.使用了 Jersey 框架实现自身的 RESTful HTTP接口</p><p>3.peer之间的同步与服务的注册全部通过 HTTP 协议实现</p><p>4.定时任务(发送心跳、定时清理过期服务、节点同步等)通过 JDK 自带的 Timer 实现</p><p>5.内存缓存使用Google的guava包实现….<a id="more"></a></p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.activation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;activation&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之所以要引入除了eureka之外的包，是因为我只引入这一个包的时候启动项目报错了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.ClassNotFoundException: javax.xml.bind.JAXBContext</span><br></pre></td></tr></table></figure></p><p>网上查了一下，说是jdk9的新特性不再默认加载这些包，好，那和我JDK8有鸡毛关系！（鄙视MyEclipse）<br>鄙视归鄙视，该需要的包还是要加上去的..</p><h3 id="配置文件编写"><a href="#配置文件编写" class="headerlink" title="配置文件编写"></a>配置文件编写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761  <span class="comment">#官方写的就是 8761</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: server <span class="comment">#一个微服务的标识，如果第二个微服务启动时，也将这个配置成server，则Spring Cloud会认为它也是server这个微服务的一个节点</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost <span class="comment">#配置主机名</span></span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span> <span class="comment">#配置服务注册中心是否以自己为客户端进行注册(配置false)</span></span><br><span class="line">    fetch-registry: <span class="literal">false</span> <span class="comment">#是否取得注册信息(配置false)</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</span><br><span class="line">      <span class="comment">#配置eureka客户端的缺省域(该配置可能没有提示,请复制或者手动输入,切勿使用有提示的service-url会引起内置tomcat报错)</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot-启动项加入注解-EnableEurekaServer"><a href="#SpringBoot-启动项加入注解-EnableEurekaServer" class="headerlink" title="SpringBoot 启动项加入注解@EnableEurekaServer"></a>SpringBoot 启动项加入注解@EnableEurekaServer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class SpringCloudLeaning1EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1EurekaServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目 访问<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> 看到以下图就证明没问题啦~<br><img src="/images/SpringCloud/Eureka/eureka-1.png"></p><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>注册服务就会用到服务发现，这里新建一个SpringBoot工程，并且引入Eureka Client需要的包</p><h3 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: product <span class="comment">#一个微服务的标识，如果第二个微服务启动时，也将这个配置成product，则Spring Cloud会认为它也是product这个微服务的一个节点</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost   <span class="comment">#配置主机名</span></span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:8761/eureka/</span><br><span class="line">      <span class="comment">#配置eureka客户端的缺省域(该配置可能没有提示,请复制或者手动输入,切勿使用有提示的service-url会引起内置tomcat报错)</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>本次启动类基于spring-cloud-starter-netflix-eureka-client不需要添加额外注解。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringCloudLeaning1EurekaClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringCloudLeaning1EurekaClientApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller类必须要写，如果不写的话，服务注册上去一秒就会关闭….,你再刷新页面就看不到服务了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Value(<span class="string">"<span class="variable">$&#123;spring.application.name&#125;</span>"</span>)</span><br><span class="line">    String applicationName;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/hello"</span>)</span><br><span class="line">    public String home(@RequestParam String email) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"My Name's :"</span> + applicationName + <span class="string">" Email:"</span> + email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后先启动服务端，再启动客户端</p><p>访问localhost:8761<br>你就可以看到我们的服务实例已经注册上去了，当然一个错误的声明警告也有…这个警告在使用服务治理的单机中经常出现，是Eureka server的一种自我保护 检测心跳的失败比率是否在15s内低于百分之85%，不用管他。</p><p><img src="/images/SpringCloud/Eureka/eureka-2.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>访问<a href="http://localhost:9001/hello?email=785009111@qq.com" target="_blank" rel="noopener">http://localhost:9001/hello?email=785009111@qq.com</a></p><p>显示：My Name’s :product Email:<a href="mailto:785009111@qq.com" target="_blank" rel="noopener">785009111@qq.com</a>   就大功告成啦~</p><p>参考文献：<br>    <a href="https://blog.csdn.net/hadues/article/details/79188793" target="_blank" rel="noopener">https://blog.csdn.net/hadues/article/details/79188793</a><br>    <a href="https://blog.battcn.com/2017/07/25/springcloud/dalston/spring-cloud-discovery/" target="_blank" rel="noopener">https://blog.battcn.com/2017/07/25/springcloud/dalston/spring-cloud-discovery/</a><br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Eureka简介&quot;&gt;&lt;a href=&quot;#Eureka简介&quot; class=&quot;headerlink&quot; title=&quot;Eureka简介&quot;&gt;&lt;/a&gt;Eureka简介&lt;/h2&gt;&lt;p&gt;1.是纯正的 servlet 应用，需构建成jar/war包部署&lt;/p&gt;
&lt;p&gt;2.使用了 Jersey 框架实现自身的 RESTful HTTP接口&lt;/p&gt;
&lt;p&gt;3.peer之间的同步与服务的注册全部通过 HTTP 协议实现&lt;/p&gt;
&lt;p&gt;4.定时任务(发送心跳、定时清理过期服务、节点同步等)通过 JDK 自带的 Timer 实现&lt;/p&gt;
&lt;p&gt;5.内存缓存使用Google的guava包实现….
    
    </summary>
    
      <category term="SpringCloud学习" scheme="http://yoursite.com/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>oracle数据库增加表空间</title>
    <link href="http://yoursite.com/2019/01/08/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%8A%A0%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2019/01/08/oracle数据库增加表空间/</id>
    <published>2019-01-08T13:30:56.000Z</published>
    <updated>2019-01-08T13:40:27.102Z</updated>
    
    <content type="html"><![CDATA[<p>今天数据库表空间满了导致插入不了新的数据了，第一次扩容，记下一笔</p><h2 id="报错截图"><a href="#报错截图" class="headerlink" title="报错截图"></a>报错截图</h2><p><img src="/images/linux/oracleDatanaseAdd/reson.png"></p><p>原因大概在网上查了查，是指USERS这个表空间满了所以导致的新数据insert失败。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>注意：以下操作均需要DBA权限。</p><h3 id="查询表空间使用情况"><a href="#查询表空间使用情况" class="headerlink" title="查询表空间使用情况"></a>查询表空间使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT UPPER(F.TABLESPACE_NAME) <span class="string">"表空间名"</span>, </span><br><span class="line">D.TOT_GROOTTE_MB <span class="string">"表空间大小(M)"</span>, </span><br><span class="line">D.TOT_GROOTTE_MB - F.TOTAL_BYTES <span class="string">"已使用空间(M)"</span>, </span><br><span class="line">TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),<span class="string">'990.99'</span>) <span class="string">"使用比"</span>, </span><br><span class="line">F.TOTAL_BYTES <span class="string">"空闲空间(M)"</span>, </span><br><span class="line">F.MAX_BYTES <span class="string">"最大块(M)"</span> </span><br><span class="line">FROM (SELECT TABLESPACE_NAME, </span><br><span class="line">ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES, </span><br><span class="line">ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES </span><br><span class="line">FROM SYS.DBA_FREE_SPACE </span><br><span class="line">GROUP BY TABLESPACE_NAME) F, </span><br><span class="line">(SELECT DD.TABLESPACE_NAME, </span><br><span class="line">ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB </span><br><span class="line">FROM SYS.DBA_DATA_FILES DD </span><br><span class="line">GROUP BY DD.TABLESPACE_NAME) D </span><br><span class="line">WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME </span><br><span class="line">ORDER BY 4 DESC;</span><br></pre></td></tr></table></figure><h3 id="查找表空间文件的路径"><a href="#查找表空间文件的路径" class="headerlink" title="查找表空间文件的路径"></a>查找表空间文件的路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT tablespace_name, </span><br><span class="line">file_id, </span><br><span class="line">file_name, </span><br><span class="line">round(bytes / (1024 * 1024), 0) total_space </span><br><span class="line">FROM dba_data_files </span><br><span class="line">ORDER BY tablespace_name;</span><br></pre></td></tr></table></figure><h3 id="新增表空间并开启自动扩容"><a href="#新增表空间并开启自动扩容" class="headerlink" title="新增表空间并开启自动扩容"></a>新增表空间并开启自动扩容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace USERS</span><br><span class="line">     add datafile <span class="string">' /u02/ORCL/datafile/user02.dbf'</span> size 320000m AUTOEXTEND ON</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天数据库表空间满了导致插入不了新的数据了，第一次扩容，记下一笔&lt;/p&gt;
&lt;h2 id=&quot;报错截图&quot;&gt;&lt;a href=&quot;#报错截图&quot; class=&quot;headerlink&quot; title=&quot;报错截图&quot;&gt;&lt;/a&gt;报错截图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/linu
      
    
    </summary>
    
      <category term="linux学习" scheme="http://yoursite.com/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(3)深入学习Spring5新框架——WebFlux框架</title>
    <link href="http://yoursite.com/2019/01/07/Spring%E7%9B%B8%E5%85%B3-3-WebFlux%E6%A1%86%E6%9E%B6-2/"/>
    <id>http://yoursite.com/2019/01/07/Spring相关-3-WebFlux框架-2/</id>
    <published>2019-01-07T11:21:28.000Z</published>
    <updated>2019-01-07T16:16:37.732Z</updated>
    
    <content type="html"><![CDATA[<p>上次有说过Webflux框架基本的服务端的开发，其最大的好处就是支持异步处理，可以提高性能，那么当今时代，微服务的架构十分盛行的情况下，多个一个大型的系统可能被拆分成多个系统，这样拆分的好处就是，首先各个系统相对独立，便于维护和开发，简化了开发人员的负担，比如一个电商系统，它可能存在产品微服务，用来发布和管理产品，可能还有客户信息微服务等等，当然他们之前并不是孤立的，他们之前可以相互调用的，各个微服务主要以Rest风格请求的接口来实现相互调用的…<a id="more"></a></p><p>为了方便各个微服务之间调用，WebFlux提供了WebClient类供开发者使用，它比RestTemplate还要强大一些，下面来说说它对于我们之前写的几个实现的调用</p><h2 id="客户端开发WebClient"><a href="#客户端开发WebClient" class="headerlink" title="客户端开发WebClient"></a>客户端开发WebClient</h2><h3 id="使用WebClient-请求后端接口"><a href="#使用WebClient-请求后端接口" class="headerlink" title="使用WebClient 请求后端接口"></a>使用WebClient 请求后端接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.client;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.filter.reactive.HiddenHttpMethodFilter;</span><br><span class="line">import org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import org.springframework.web.server.WebFilterChain;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">public class UserWebClient &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">WebClient webClient = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">WebClient webClient2 = WebClient.create(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setId(<span class="string">"1"</span>);</span><br><span class="line">user.setSex(<span class="string">"男"</span>);</span><br><span class="line">user.setNote(<span class="string">"123"</span>);</span><br><span class="line">user.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">//新增用户</span><br><span class="line">insertUser(webClient, user);</span><br><span class="line">//获取用户</span><br><span class="line">getUser(webClient2, user.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void insertUser(WebClient webClient,User user) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.post()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user"</span>)</span><br><span class="line">//设置请求体为Json数据流</span><br><span class="line">.contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求体内容</span><br><span class="line">.body(Mono.just(user),User.class)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"用户ID"</span>+user2.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getUser(WebClient webClient,String id) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.get()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user/&#123;id&#125;"</span>,id)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"用户ID"</span>+user2.getUserName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后先运行SpringBoot的主程序，在运行main方法就可以了。<br>日志太长…不太好整….<br>这里如果是基于SpringBoot2.05版本及其以上，可能在调用2个方法时发生报错(java.lang.IllegalStateException: Only one connection receive subscriber allowed)<br>这个是SpringBoot2.05以上版本的Bug，我个人的解决办法是退回到2.04版本，可以在pom文件中修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></p><p>使用代码修改(这种方法我尝试了…但是失败了)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public HiddenHttpMethodFilter <span class="function"><span class="title">hiddenHttpMethodFilter</span></span>() &#123;</span><br><span class="line">       <span class="built_in">return</span> new <span class="function"><span class="title">HiddenHttpMethodFilter</span></span>() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;</span><br><span class="line">               <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>原文地址：<a href="https://github.com/spring-projects/spring-boot/issues/14509" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues/14509</a></p><h2 id="WebFlux-服务端开发"><a href="#WebFlux-服务端开发" class="headerlink" title="WebFlux 服务端开发"></a>WebFlux 服务端开发</h2><h3 id="类型转换器-Converter"><a href="#类型转换器-Converter" class="headerlink" title="类型转换器 Converter"></a>类型转换器 Converter</h3><p>在之前使用SpringMVC的时候也使用过转换器，当时就是把一个字符串”userName-sex-note”转换成一个User类<br>这次依旧是以字符串为例子，实现WebFlux的转换器</p><h4 id="转换器类代码"><a href="#转换器类代码" class="headerlink" title="转换器类代码"></a>转换器类代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.core.convert.converter.Converter;</span><br><span class="line">import org.springframework.format.FormatterRegistry;</span><br><span class="line">import org.springframework.web.reactive.config.WebFluxConfigurer;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * WebFlux配置类</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月7日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebFluxConfig implements WebFluxConfigurer&#123;</span><br><span class="line"></span><br><span class="line">//注册Converter</span><br><span class="line">@Override</span><br><span class="line">public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">registry.addConverter(stringToUserConverter());</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Converter&lt;String, User&gt; <span class="function"><span class="title">stringToUserConverter</span></span>()&#123;</span><br><span class="line">Converter&lt;String, User&gt; converter = new Converter&lt;String, User&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public User convert(String str) &#123;</span><br><span class="line">String[] split = str.split(<span class="string">"-"</span>);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setUserName(split[0]);</span><br><span class="line">user.setSex(split[1]);</span><br><span class="line">user.setNote(split[2]);</span><br><span class="line"><span class="built_in">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">return</span> converter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是实现WebFluxConfigurer 接口，然后重写其注册Converter的方法addFormatters,然后自己构建一个Bean，也就是转换的Bean，加上@Bean注解就可以了。</p><h4 id="Controller-类编写"><a href="#Controller-类编写" class="headerlink" title="Controller 类编写"></a>Controller 类编写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value=<span class="string">"/user/&#123;user&#125;"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser2(@PathVariable(<span class="string">"user"</span>) User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebClient-测试片段"><a href="#WebClient-测试片段" class="headerlink" title="WebClient 测试片段"></a>WebClient 测试片段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void insertUserByString(WebClient webClient) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient.get()</span><br><span class="line">.uri(<span class="string">"/user/&#123;user&#125;"</span>,<span class="string">"张三-男-gay"</span>).accept(MediaType.APPLICATION_STREAM_JSON).retrieve().bodyToMono(User.class);</span><br><span class="line">User user = userMono.block();</span><br><span class="line">System.out.println(<span class="string">"UserId:"</span>+user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">21:37:33.580 [reactor-http-nio-4] DEBUG reactor.ipc.netty.http.client.HttpClientOperations - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Received response (auto-read:<span class="literal">false</span>) : [Content-Type=application/stream+json;charset=UTF-8, Content-Length=78, Date=Mon, 07 Jan 2019 13:37:33 GMT]</span><br><span class="line">21:37:33.581 [reactor-http-nio-4] DEBUG org.springframework.web.reactive.function.client.ExchangeFunctions - Response received, status: 200 OK</span><br><span class="line">21:37:33.661 [reactor-http-nio-4] DEBUG reactor.ipc.netty.channel.FluxReceive - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Subscribing inbound receiver [pending: 0, cancelled:<span class="literal">false</span>, inboundDone: <span class="literal">false</span>]</span><br><span class="line">21:37:33.666 [reactor-http-nio-4] DEBUG reactor.ipc.netty.http.client.HttpClientOperations - [id: 0x50153790, L:/127.0.0.1:64423 - R:localhost/127.0.0.1:8080] Received last HTTP packet</span><br><span class="line">UserId:5c33561d84cda64d6ce7121e</span><br></pre></td></tr></table></figure><p>至此，转换器就完美撒花了。</p><h3 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h3><p>验证器其实和SpringMVC 的区别不大，分为局部验证器和全局验证器，验证器本身是和MVC一致的，就只是WebFlux 初始化的时候修改一下验证器即可</p><h4 id="User验证器"><a href="#User验证器" class="headerlink" title="User验证器"></a>User验证器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.validator;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">/**</span><br><span class="line"> * 用户验证器</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月7日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class UserValidator implements Validator &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean supports(Class&lt;?&gt; user) &#123;</span><br><span class="line"><span class="built_in">return</span> user.equals(User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void validate(Object target, Errors errors) &#123;</span><br><span class="line">User user = (User) target;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(user.getUserName())) </span><br><span class="line">errors.reject(<span class="string">"userName"</span>,null,<span class="string">"用户名不能为空"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebFlux中添加验证器"><a href="#WebFlux中添加验证器" class="headerlink" title="WebFlux中添加验证器"></a>WebFlux中添加验证器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置全局验证器</span><br><span class="line">@Override</span><br><span class="line">public Validator <span class="function"><span class="title">getValidator</span></span>() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"><span class="built_in">return</span> new UserValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller类加入-Valid注解"><a href="#Controller类加入-Valid注解" class="headerlink" title="Controller类加入@Valid注解"></a>Controller类加入@Valid注解</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value=<span class="string">"/user/&#123;user&#125;"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser2(@Valid @PathVariable(<span class="string">"user"</span>) User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说只希望这一个类使用这个验证器，也可以参照SpringMVC的写法，在Controller类中添加@InitBinder注解<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void InitBinder (DataBinder dataBinder) &#123;</span><br><span class="line">dataBinder.setValidator(new UserValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebFlux-客户端深入开发"><a href="#WebFlux-客户端深入开发" class="headerlink" title="WebFlux 客户端深入开发"></a>WebFlux 客户端深入开发</h2><h3 id="处理服务端的错误"><a href="#处理服务端的错误" class="headerlink" title="处理服务端的错误"></a>处理服务端的错误</h3><p>之前客户端的开发是基于retrieve方法将服务端的数据流转换的，实际上还需要处理错误的数据，比如http返回一个错误的状态码，这时候就需要我们在客户端进行异常处理<br>，假设之前get方法存在get的结果集为空的情况。</p><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void getUser2(WebClient webClient,String id) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient.get().uri(<span class="string">"/user/&#123;id&#125;"</span>,id).accept(MediaType.APPLICATION_STREAM_JSON).retrieve()</span><br><span class="line">.onStatus(</span><br><span class="line">//如果服务端返回4开头或者5开头的状态吗 则返回<span class="literal">true</span> ，4代表客户端错误，5开头是服务器错误 </span><br><span class="line">status -&gt; status.is4xxClientError()||status.is5xxServerError(),</span><br><span class="line">//如果发生异常，则用第二个(下面这个)表达式作为结果</span><br><span class="line">response -&gt; Mono.empty())</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">User user = userMono.block();</span><br><span class="line"><span class="keyword">if</span>(user!=null) &#123;</span><br><span class="line">System.out.println(<span class="string">"success"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h3><p>服务端的代码也就是加一个@RequestHeader(“id”) 类似的注解。</p><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static String insertUser(WebClient webClient,User user) &#123;</span><br><span class="line">Mono&lt;User&gt; userMono = webClient</span><br><span class="line">//定义post请求方式</span><br><span class="line">.post()</span><br><span class="line">//设置请求uri</span><br><span class="line">.uri(<span class="string">"/user"</span>).header(<span class="string">"id"</span>, user.getId())</span><br><span class="line">//设置请求体为Json数据流</span><br><span class="line">.contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求体内容</span><br><span class="line">.body(Mono.just(user),User.class)</span><br><span class="line">//设置请求结果类型</span><br><span class="line">.accept(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">//设置请求结果检索规则</span><br><span class="line">.retrieve()</span><br><span class="line">//将结果转换为一个Mono封装的数据流</span><br><span class="line">.bodyToMono(User.class);</span><br><span class="line">//获取服务器发布的数据流，此时才会发起请求</span><br><span class="line">User user2 = userMono.block();</span><br><span class="line"><span class="built_in">return</span> user2.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是在uri后面加一个.header(key,value).<br>也挺简单的。</p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振<br>    <a href="https://my.oschina.net/thinkgem/blog/2249665?from=timeline" target="_blank" rel="noopener">https://my.oschina.net/thinkgem/blog/2249665?from=timeline</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次有说过Webflux框架基本的服务端的开发，其最大的好处就是支持异步处理，可以提高性能，那么当今时代，微服务的架构十分盛行的情况下，多个一个大型的系统可能被拆分成多个系统，这样拆分的好处就是，首先各个系统相对独立，便于维护和开发，简化了开发人员的负担，比如一个电商系统，它可能存在产品微服务，用来发布和管理产品，可能还有客户信息微服务等等，当然他们之前并不是孤立的，他们之前可以相互调用的，各个微服务主要以Rest风格请求的接口来实现相互调用的…
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(2)Spring5新框架——WebFlux框架</title>
    <link href="http://yoursite.com/2019/01/06/Spring%E7%9B%B8%E5%85%B3-2-WebFlux%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/01/06/Spring相关-2-WebFlux框架/</id>
    <published>2019-01-06T04:04:50.000Z</published>
    <updated>2019-01-07T11:18:12.561Z</updated>
    
    <content type="html"><![CDATA[<p>在当前互联网应用中，存在电商和金融行业等企业，这些企业对于业务逻辑的严谨性要求特别高，因为他们的业务关系到用户和商家账户以及财产安全，对于数据的一致性非常高，所以一般情况下通过锁等其他机制保证数据的一致性，但是这也会造成性能的下降。对于另外一些互联网应用就不一样了，比如游戏，视频，新闻，门户，(毕业设计~=。=)，他们一般不会涉及操作财产和账户，相对更在意的是并发数和响应速度，而传统的开发模式会引入一致性的机制，这也是造成他们性能瓶颈的原因之一，为此就提出了响应式编程的概念。</p><p>在Servlet3.1规范开始，javaEE支持异步处理，即收到请求之后，Servlet线程可以将耗时的操作委派给另外一个线程来完成，在不生成响应的情况下返回给容器，使得Java可以更好的支持响应式编程，也就是在Spring5中发布了新的响应式Web框架——WebFlux,不过要注意的是，Spring2.X才支持WebFlux框架…..<a id="more"></a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Spring-WebFlux-概述："><a href="#Spring-WebFlux-概述：" class="headerlink" title="Spring WebFlux 概述："></a>Spring WebFlux 概述：</h3><p>   在Servlet3.1之前，Web容器都是基于阻塞机制开发的，而Servlet3.1开始，就有了非阻塞的规范(异步)，对于高并发的网站，使用韩说是编程显得更为直观和简易，特别是那些需要高速响应并且对于业务逻辑要求并不十分严格的网站，如游戏，视频等等</p><p>   在Java8 开始，引入了Lambda表达式和Functional接口等新特性，也使得java的语法更加丰富<br>   对于响应式编程而言，分为Router Functions、Spring Webflux和Http/Reactive Streams<br>   Router Functions 是一个路由分发，他会根据请求时间，决定采用什么类的什么方法来处理请求，也就是Selector，不参与实际业务逻辑的处理，只是起到一个分发的作用。</p><p>   Spring WebFlux，也就是控制层，参与实际业务逻辑的处理及Stream 流的返回。</p><p>   Http/ReactiveStream:将结果转换为流的过程。</p><p>   Spring WebFlux 是需要支持Servlet3.1+的容器，比如Tomcat、Netty、Jetty等等， SpringBoot中默认的依赖是Netty库。<br>   最后，说一说数据流的封装，也就是Flux 和Mono。它们都是封装数据流的类，其中Flux 是存放的0~N个数据流序列，响应式编程会一个接一个的将它们发送给客户端；而对于Mono而言，它存放的是0~1个数据流序列，这就是它们之前的不同，当然，它们是可以相互转换的。</p><h3 id="WebHandler接口"><a href="#WebHandler接口" class="headerlink" title="WebHandler接口"></a>WebHandler接口</h3><p>在SpringMVC中，是使用的DispatcherServlet来处理分发请求和响应的，在WebFlux中采用的是WebHandler，它和前者很相似。而对于WebHandler，最重要的就是DispatcherHandler，而在这其中，设计WebFlux流程的就是handle方法，下面放源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class="line">   //日志</span><br><span class="line"><span class="keyword">if</span> (this.handlerMappings == null) &#123;</span><br><span class="line"><span class="built_in">return</span> createNotFoundError();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> Flux</span><br><span class="line">       //Reactive框架封装的数据流类Flux</span><br><span class="line">       //循环HandlerMapping</span><br><span class="line">       .fromIterable(this.handlerMappings)</span><br><span class="line">//找到合适的控制器</span><br><span class="line">       .concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">       //处理第一条合适的记录</span><br><span class="line">.next()</span><br><span class="line">//如果出现找不到处理器的情况</span><br><span class="line">       .switchIfEmpty(createNotFoundError())</span><br><span class="line">//通过反射运行处理器</span><br><span class="line">       .flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line">//解析结果，将其转换成对应的数据流序列</span><br><span class="line">       .flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和SpringMVC一样，都是从HanlerMapping找到对应的处理器，这也就是为什么可以使用@Controller等注解的原因，通过这些配置的路径能够通过getHandler方法找到对应的处理器(和MVC一致，处理器包含控制器逻辑)，找到处理器之后通过invokeHandler方法运行处理器最后将结果通过handlerResult返回，转换成对应的数据流。</p><h2 id="使用SpringMVC开发WebFlux"><a href="#使用SpringMVC开发WebFlux" class="headerlink" title="使用SpringMVC开发WebFlux"></a>使用SpringMVC开发WebFlux</h2><h3 id="pom文件中添加依赖"><a href="#pom文件中添加依赖" class="headerlink" title="pom文件中添加依赖"></a>pom文件中添加依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>上面有3个依赖，一个是WebFlux所需要的依赖，一个是tomcat的依赖，主要说的是MongoDB的依赖，使用WebFlux主要目的就是异步请求相应，也就是非阻塞的数据响应，而目前主流数据库(Oracle、MySql等等都是不支持非阻塞开发的。)所以这里没办法使用工作中经常使用的数据库，这里就可以使用一个Spring-data-Reactive 支持的NoSql数据库(MongoDB)，所以引入的以上相关的一些jar</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line">import org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line">//标记未Mongo文档</span><br><span class="line">@Document</span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 939273844324506896L;</span><br><span class="line">@Id</span><br><span class="line">private String id;</span><br><span class="line"></span><br><span class="line">private String sex;</span><br><span class="line">//在MongoDB中使用user_name 来保存</span><br><span class="line">@Field(<span class="string">"user_name"</span>)</span><br><span class="line">private String userName;</span><br><span class="line">private String note;</span><br><span class="line">/*省略get/<span class="built_in">set</span> 以及构造方法*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类没啥特别需要注意的，也就是需要实现序列化接口</p><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.dao;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">/**</span><br><span class="line"> * 注意：这里需要继承ReactiveMongoRepository接口，这样就相当自动帮我们整合了增删改查</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月6日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">@Repository</span><br><span class="line">public interface IUserDao extends ReactiveMongoRepository&lt;User, Long&gt;&#123;</span><br><span class="line">/**</span><br><span class="line"> * 根据用户名和备注进行模糊查询</span><br><span class="line"> * @param userName</span><br><span class="line"> * @param note</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">Flux&lt;User&gt; findByUserNameLikeAndNoteLike(String userName,String note);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要继承ReactiveMongoRepository 接口，这样就相当于WebFlux为MongoDB封装好了的一个增删改查的接口</p><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">public interface IUserService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mono&lt;User&gt; insertUser(User user);</span><br><span class="line"></span><br><span class="line">Mono&lt;User&gt; updateUser(User user);</span><br><span class="line"></span><br><span class="line">Flux&lt;User&gt; findUsers(String userName,String note);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.dao.IUserDao;</span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IUserService;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IUserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;User&gt; insertUser(User user) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;User&gt; updateUser(User user) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Flux&lt;User&gt; findUsers(String userName, String note) &#123;</span><br><span class="line"><span class="built_in">return</span> userDao.findByUserNameLikeAndNoteLike(userName, note);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IUserService;</span><br><span class="line"></span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">IUserService userService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新用户</span><br><span class="line"> * @param user</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PutMapping(<span class="string">"/user"</span>)</span><br><span class="line">public Mono&lt;User&gt; updateUser(@RequestBody User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.updateUser(user);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 新增用户</span><br><span class="line"> * @param user</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@PostMapping(value=<span class="string">"/user"</span>)</span><br><span class="line">public Mono&lt;User&gt; insertUser(@RequestBody User user)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(<span class="string">"/like/&#123;userName&#125;/&#123;note&#125;"</span>)</span><br><span class="line">public Flux&lt;User&gt; <span class="built_in">test</span>(@PathVariable(<span class="string">"userName"</span>)String userName,@PathVariable(<span class="string">"note"</span>)String note)&#123;</span><br><span class="line"><span class="built_in">return</span> userService.findUsers(userName, note);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: localhost</span><br><span class="line">      username: weblogic</span><br><span class="line">      password: password1</span><br><span class="line">      port: 27017</span><br><span class="line">      database: springboot</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line">import org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">//因为引入了JPA包，所以默认情况下会加载数据源，需要排除原本自动装配的数据源</span><br><span class="line">@EnableAutoConfiguration(exclude= &#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">//驱动Mongo注解</span><br><span class="line">@EnableReactiveMongoRepositories(basePackages=<span class="string">"com.wangshun.leaning.dao"</span>)</span><br><span class="line">public class SpringBootLeaning10WebFluxApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringBootLeaning10WebFluxApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><h4 id="模糊查询方法"><a href="#模糊查询方法" class="headerlink" title="模糊查询方法"></a>模糊查询方法</h4><p><img src="/images/Spring/Spring2/spring1.png"></p><h4 id="save方法："><a href="#save方法：" class="headerlink" title="save方法："></a>save方法：</h4><p><img src="/images/Spring/Spring2/spring2.png"></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h3><p>参考地址：<br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p><h3 id="MongoDB-可视化界面使用-需要git"><a href="#MongoDB-可视化界面使用-需要git" class="headerlink" title="MongoDB 可视化界面使用(需要git)"></a>MongoDB 可视化界面使用(需要git)</h3><p>参考地址：<br><a href="https://www.cnblogs.com/shiweida/p/7692468.html" target="_blank" rel="noopener">https://www.cnblogs.com/shiweida/p/7692468.html</a></p><h3 id="MongoDB创建用户"><a href="#MongoDB创建用户" class="headerlink" title="MongoDB创建用户"></a>MongoDB创建用户</h3><p>注意：需要切换到对应的数据库下进行创建才能连接<br>切换数据库命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use xxxxx（数据库名称）</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">user: <span class="string">"weblogic"</span>,</span><br><span class="line"><span class="built_in">pwd</span>: <span class="string">"password1"</span>,</span><br><span class="line">roles: [&#123;</span><br><span class="line">role: <span class="string">"userAdminAnyDatabase"</span>,</span><br><span class="line">db: <span class="string">"admin"</span></span><br><span class="line">&#125;],</span><br><span class="line">mechanisms: [<span class="string">"SCRAM-SHA-1"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整了一下午才弄好，踩了无数个坑，说几个常见的坑吧：</p><h3 id="错误解决方案"><a href="#错误解决方案" class="headerlink" title="错误解决方案"></a>错误解决方案</h3><h4 id="com-mongodb-MongoSecurityException-Exception-authenticating-MongoCredential-mechanism-SCRAM-SHA-1-userName-’weblogic’-source-’springboot’-password-mechanismProperties-”"><a href="#com-mongodb-MongoSecurityException-Exception-authenticating-MongoCredential-mechanism-SCRAM-SHA-1-userName-’weblogic’-source-’springboot’-password-mechanismProperties-”" class="headerlink" title="com.mongodb.MongoSecurityException:Exception authenticating MongoCredential{mechanism=SCRAM-SHA-1, userName=’weblogic’, source=’springboot’, password=, mechanismProperties={}}”"></a>com.mongodb.MongoSecurityException:Exception authenticating MongoCredential{mechanism=SCRAM-SHA-1, userName=’weblogic’, source=’springboot’, password=<hidden>, mechanismProperties={}}”</hidden></h4><p>这个报错是因为你所配置的数据库不存在这个用户 或者用户名密码错误，正如上面我所说的那样，需要先切换到一些数据库之后再创建用户。</p><h4 id="message”-“E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-nested-exception-is-com-mongodb-MongoWriteException-E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-”"><a href="#message”-“E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-nested-exception-is-com-mongodb-MongoWriteException-E11000-duplicate-key-error-collection-springboot-user-index-id-dup-key-0-”" class="headerlink" title="message”: “E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }; nested exception is com.mongodb.MongoWriteException: E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }”"></a>message”: “E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }; nested exception is com.mongodb.MongoWriteException: E11000 duplicate key error collection: springboot.user index: _id_ dup key: { : 0 }”</h4><p>这个是因为主键冲突了，一般当你把ID定义成int 类型的时候使用@Id 注解之后它第一次确实会给你生成一个ID  是0，但是后续不会自增长，如果说你有需要使用数字主键请自行百度Mongo实现主键自增长，目前我还没有研究出来这个。</p><p>ps：代码Service层没有写默认的根据ID查询的方法是因为  默认的接口中实现是采用Long 类型的参数查询的，而这里Long类型的参数由于没有自定义主键自增长，所以我暂时还没有实现，还有一种方法就是采用另外一种指定参数的查询，现没找到.<br>就先说这么多吧，时间也不早了，吃饭去……</p><p>参考文献：<br>    《深入浅出SpringBoot2.x》——杨开振<br>    <a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a><br>    <a href="https://www.cnblogs.com/shiweida/p/7692468.html" target="_blank" rel="noopener">https://www.cnblogs.com/shiweida/p/7692468.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当前互联网应用中，存在电商和金融行业等企业，这些企业对于业务逻辑的严谨性要求特别高，因为他们的业务关系到用户和商家账户以及财产安全，对于数据的一致性非常高，所以一般情况下通过锁等其他机制保证数据的一致性，但是这也会造成性能的下降。对于另外一些互联网应用就不一样了，比如游戏，视频，新闻，门户，(毕业设计~=。=)，他们一般不会涉及操作财产和账户，相对更在意的是并发数和响应速度，而传统的开发模式会引入一致性的机制，这也是造成他们性能瓶颈的原因之一，为此就提出了响应式编程的概念。&lt;/p&gt;
&lt;p&gt;在Servlet3.1规范开始，javaEE支持异步处理，即收到请求之后，Servlet线程可以将耗时的操作委派给另外一个线程来完成，在不生成响应的情况下返回给容器，使得Java可以更好的支持响应式编程，也就是在Spring5中发布了新的响应式Web框架——WebFlux,不过要注意的是，Spring2.X才支持WebFlux框架…..
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关(1)异步线程池和jms</title>
    <link href="http://yoursite.com/2019/01/05/Spring%E7%9B%B8%E5%85%B3-1-%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8Cjms/"/>
    <id>http://yoursite.com/2019/01/05/Spring相关-1-异步线程池和jms/</id>
    <published>2019-01-05T04:26:29.000Z</published>
    <updated>2019-01-05T09:40:09.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步线程池"><a href="#异步线程池" class="headerlink" title="异步线程池"></a>异步线程池</h2><p>在之前的学习中，除了Redis之外，其他所有的都是同步应用，那么其实在开发的过程中，有些时候我们需要使用异步线程，即一个请求需要2个或者2个异常线程去请求，比如生成报表，运维人员只需要点击生成报表即可，并不是需要立即查看报表，那么生成报表可能需要牵扯大量的数据查询并生成，这如果在同一个线程中是很耗费时间的。而且用户的体验也不是很好，接下来 就来说说异步线程。</p><p>就以上的需求大概的逻辑是这样的，运维人员点击生成报表，启动线程1执行生成报表的一些基本操作，同时启动线程2，由线程2去独立完成生成报表的一些大量操作，而线程一无需等待，直接进入下一步操作，这样的话运维人员就不需要等待线程的完成，可以是很好的用户体验…<a id="more"></a></p><h2 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h2><h3 id="定义线程池和开启异步可用"><a href="#定义线程池和开启异步可用" class="headerlink" title="定义线程池和开启异步可用"></a>定义线程池和开启异步可用</h3><p>在Spring 中存在一个AsyncConfigurer接口，它是一个可以配置异步线程池的接口，他的源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.scheduling.annotation;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">public interface AsyncConfigurer &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取线程池</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">default Executor <span class="function"><span class="title">getAsyncExecutor</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步异常处理器</span><br><span class="line"> */</span><br><span class="line">@Nullable</span><br><span class="line">default AsyncUncaughtExceptionHandler <span class="function"><span class="title">getAsyncUncaughtExceptionHandler</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上代码可以看出方法本身还是比较简单的，其中getAsyncExecutor方法返回的是一个自定义的线程池，这样在开启异步时，线程池就会提空空闲线程来执行异步任务，因为线程中的业务逻辑可能出现异常，所以也定义了一个处理异常的方法，使得异常可以自定义处理，为了使得这个接口方便使用，Spring还提供了空的实现，所以我们只需要实现AsyncConfigurer接口覆盖掉对应的方法即可。</p><p>因此我们只需要java配置文件类，实现AsyncConfigurer接口，实现getAsyncExecutor方法返回的线程池，这样Spring就会将这个线程池作为异步调用的线程。为了使得异步可用，Spring还提供了一个注解@EnableAnsync,如果java配置文件配置它，那么Spring就会开启异步即可，这样就可以使用@Async注解来驱动Spring使用异步调用，接下来用一个例子来进行说明</p><h3 id="异步实例"><a href="#异步实例" class="headerlink" title="异步实例"></a>异步实例</h3><h4 id="java配置类"><a href="#java配置类" class="headerlink" title="java配置类"></a>java配置类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.config;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line">/**</span><br><span class="line"> * 定义线程池和启用异步调用</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月5日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">@EnableAsync</span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig implements AsyncConfigurer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Executor <span class="function"><span class="title">getAsyncExecutor</span></span>() &#123;</span><br><span class="line">//定义线程池</span><br><span class="line">ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class="line">//设置核心线程数</span><br><span class="line">taskExecutor.setCorePoolSize(10);</span><br><span class="line">//设置线程池最大线程数</span><br><span class="line">taskExecutor.setMaxPoolSize(30);</span><br><span class="line">//设置线程队列最大线程数</span><br><span class="line">taskExecutor.setQueueCapacity(2000);</span><br><span class="line">taskExecutor.initialize();</span><br><span class="line"><span class="built_in">return</span> taskExecutor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，注解@EnableAsync 代表开启异步，这样就可以使用@Async驱动Spring使用异步，但是异步需要提供可用的线程池，所以这里的配置类实现了AsyncConfigurer接口，实现其中方法，这样就可以定义一个线程池，并在实现的方法中定义了一些属性和初始化线程池，这样异步就可以使用了。</p><h4 id="Service-实现类-接口省略-，略略略"><a href="#Service-实现类-接口省略-，略略略" class="headerlink" title="Service 实现类(接口省略 ，略略略~)"></a>Service 实现类(接口省略 ，略略略~)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IAsynccService;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class AsyncServiceImpl implements IAsynccService&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//声明采用异步调用</span><br><span class="line">@Async</span><br><span class="line">public void <span class="function"><span class="title">generateReport</span></span>() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(<span class="string">"报表线程名称:"</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IAsynccService;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value=<span class="string">"/async"</span>)</span><br><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IAsynccService asynccService;</span><br><span class="line">@GetMapping(value=<span class="string">"/test"</span>)</span><br><span class="line">public String <span class="function"><span class="title">asyncPage</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"请求线程名称:"</span>+Thread.currentThread().getName());</span><br><span class="line">//开启异步调用</span><br><span class="line">asynccService.generateReport();</span><br><span class="line"><span class="built_in">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试日志"><a href="#测试日志" class="headerlink" title="测试日志"></a>测试日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-05 12:58:23.000  INFO 19264 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 8 ms</span><br><span class="line">请求线程名称:http-nio-8080-exec-6</span><br><span class="line">2019-01-05 12:58:52.122  INFO 19264 --- [nio-8080-exec-6] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService</span><br><span class="line">报表线程名称:ThreadPoolTaskExecutor-1</span><br></pre></td></tr></table></figure><p>通过日志可以看到控制器方法和异步方法是由不同的线程完成的，通过类似的方法就可以在Spring中使用异步调用</p><h2 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h2><p>有时候需要和其他系统集成，最常见的就是短信系统，网站中注册的时候，经常会有点击发送验证码。对于业务系统而言，只需要发送请求到短信系统就可以，短信系统就是一个异步系统，当发送消息之后，短信系统可能没有立刻将短信发出，正如生活中有时候收到短信会慢一样(举报暴雪的邮件系统~)。</p><p>为了给其他系统发送消息，java中引入了JMS(java消息服务)，jms按照其规范分为点对点和发布订阅两种形式，点对点就是将一个系统的消息发布到另外一个指定系统，而订阅就是一个系统约定将消息发布到一个主题中，然后各个系统通过订阅这个主题可以收到发送过来的信息处理对应的业务，大部分情况下是需要采用订阅模式的，因为可以进行更多的扩展(适用于一对多系统)<br>。</p><p>在实际的工作中，JMS服务的规范啊有很多，常见的就是ActiveMQ和分布式kafka。为了更为可靠和安全，还存在AMQP协议，实现它比较常见的有RabbitMQ等等，接下来就说说ActiveMQ和RabbitMQ。</p><h3 id="JMS实例——ActiveMQ"><a href="#JMS实例——ActiveMQ" class="headerlink" title="JMS实例——ActiveMQ"></a>JMS实例——ActiveMQ</h3><h4 id="下载并启动ActiveMQ"><a href="#下载并启动ActiveMQ" class="headerlink" title="下载并启动ActiveMQ"></a>下载并启动ActiveMQ</h4><p>下载的话，地址为：activemq.apache.org，下载完成后解压进入bin目录下，按照计算机操作系统启动其activemq.bat即可。</p><p>启动之后输入<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a>  使用admin/admin登录，就可以看到以下界面了<br><img src="/images/Spring/Spring1/spring1.png"><br>启动完成之后就可以在java中进行使用了</p><h4 id="java中使用ActiveMQ"><a href="#java中使用ActiveMQ" class="headerlink" title="java中使用ActiveMQ"></a>java中使用ActiveMQ</h4><h5 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ActiveMQ依赖  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--ActiveMQ连接依赖  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第一个包是引入ActiveMQ的starter，这样就可以在application.yml文件中对于ActiveMQ进行配置，第二个是引入了连接池机制，有了这些依赖，我们就可以进行配置了。</p><h5 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ActiveMq地址</span></span><br><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line">spring.activemq.user=admin</span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line">spring.activemq.password=admin</span><br><span class="line"><span class="comment">#是否使用发布订阅模式，默认false 采用点对点模式</span></span><br><span class="line">spring.jms.pub-sub-domain=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 默认目标地址</span></span><br><span class="line">spring.jms.template.default-destination=activemq.default.destination</span><br><span class="line"><span class="comment">#是否启用连接池</span></span><br><span class="line">spring.active.pool.enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment">#连接池最大数量配置</span></span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure><p>上面的配置如果启用订阅模式就会报错，我也不知道是为什么…所以暂时采用点对点吧。<br>SpringBoot会根据上述的配置生成许多ActiveMQ相关对象，如jms连接工厂、连接池和jmsTemplate，而对于消息的发送和接收可以通过jmsTemplate处理，关于接收消息，Spring提供了一个注解@JmsListener进一步简化了我们的工作，因此需要定义一个接口，它既能发送jms消息，也可以接收jms消息<br>这里没使用yml文件是因为一样的配置 yml文件配置启动会报错找不到jmsTemplate 对象，我也不知道为什么。。。。。</p><h5 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jms.annotation.JmsListener;</span><br><span class="line">import org.springframework.jms.core.JmsTemplate;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.service.IActiveMqService;</span><br><span class="line"></span><br><span class="line">public class ActiveMqServiceImpl implements IActiveMqService &#123;</span><br><span class="line">/**</span><br><span class="line"> * 注入由SpringBoot自动生产的JMsTemplate、</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">@Autowired</span><br><span class="line">private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sendMsg(String message) &#123;</span><br><span class="line">System.out.println(<span class="string">"发送消息:"</span>+message);</span><br><span class="line">jmsTemplate.convertAndSend(message);</span><br><span class="line">//自定义发送地址</span><br><span class="line">//jmsTemplate.convertAndSend(<span class="string">"your-destinnation"</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//使用注解监听地址发送过来的消息</span><br><span class="line">@JmsListener(destination=<span class="string">"<span class="variable">$spring</span>.jms.template.default-destionation"</span>)</span><br><span class="line">public void receiveMsg(String message) &#123;</span><br><span class="line">System.out.println(<span class="string">"接收到的消息为："</span>+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是注入了jmsTemplate，这个对象是由SpringBoot自动配置机制生成的，接着是sendMsg方法，它是发送jms消息，这里调用的是convertAndSend ，就是转化并发送的方法，把我们传入的消息通过默认的转化器进行转化之后再发送出去，如果我们需要修改转化器，只需要调用sendMessageConvert方法即可。</p><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(<span class="string">"/activemq"</span>)</span><br><span class="line">public class ActiveMqController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private IActiveMqService activeMqService;</span><br><span class="line">@GetMapping(value=<span class="string">"/send/&#123;msg&#125;"</span>)</span><br><span class="line">public Map&lt;String, Object&gt; sendMsg(@PathVariable(value=<span class="string">"msg"</span>)String message)&#123;</span><br><span class="line">Map&lt;String, Object&gt; resultsMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">activeMqService.sendMsg(message);</span><br><span class="line">resultsMap.put(<span class="string">"success"</span>, message);</span><br><span class="line"><span class="built_in">return</span> resultsMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-01-05 15:57:29.774  INFO 27860 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2019-01-05 15:57:29.774  INFO 27860 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">2019-01-05 15:57:29.785  INFO 27860 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> 11 ms</span><br><span class="line">发送消息:123345</span><br><span class="line">接收到的消息为：123345</span><br></pre></td></tr></table></figure><p>当然，我们有时候可能传递的不止是一个String 字符串，比如我们想传递一个对象，就可以这样写：</p><h4 id="AcitiveMQ-传递User对象"><a href="#AcitiveMQ-传递User对象" class="headerlink" title="AcitiveMQ 传递User对象"></a>AcitiveMQ 传递User对象</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 939273844324506896L;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line">private String userName;</span><br><span class="line">private String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类没啥好说的，只有实现Serializable接口，实现序列化~</p><h5 id="Service-实现类"><a href="#Service-实现类" class="headerlink" title="Service 实现类"></a>Service 实现类</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.jms.annotation.JmsListener;</span><br><span class="line">import org.springframework.jms.core.JmsTemplate;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.wangshun.leaning.entity.User;</span><br><span class="line">import com.wangshun.leaning.service.IActiveMqUserService;</span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class ActiveMqUserServiceImpl implements IActiveMqUserService&#123;</span><br><span class="line"></span><br><span class="line">private static final String myDestination = <span class="string">"my-destination"</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注入由SpringBoot自动生产的JMsTemplate、</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">@Autowired</span><br><span class="line">private JmsTemplate jmsTemplate = null;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sendMsg(User user) &#123;</span><br><span class="line">System.out.println(<span class="string">"发送消息:"</span>+user);</span><br><span class="line">//自定义发送地址</span><br><span class="line">jmsTemplate.convertAndSend(myDestination,user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">//使用注解监听地址发送过来的消息</span><br><span class="line">@JmsListener(destination=myDestination)</span><br><span class="line">public void receiveMsg(User user) &#123;</span><br><span class="line">System.out.println(<span class="string">"接收到的消息为："</span>+user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   @Autowired</span><br><span class="line">private IActiveMqUserService activeMqUserService;</span><br><span class="line"></span><br><span class="line">@GetMapping(value=<span class="string">"/send/&#123;id&#125;/&#123;name&#125;"</span>)</span><br><span class="line">public Map&lt;String, Object&gt; sendUserMsg(@PathVariable(value=<span class="string">"id"</span>)Long id,@PathVariable(value=<span class="string">"name"</span>)String name)&#123;</span><br><span class="line">User user = new User(id,name,<span class="string">""</span>);</span><br><span class="line">Map&lt;String, Object&gt; resultsMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">activeMqUserService.sendMsg(user);</span><br><span class="line">resultsMap.put(<span class="string">"success"</span>, user);</span><br><span class="line"><span class="built_in">return</span> resultsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件中添加active信任包"><a href="#配置文件中添加active信任包" class="headerlink" title="配置文件中添加active信任包"></a>配置文件中添加active信任包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.packages.trust-all=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里我尝试过使用个别包的设置,但是失败了…留一个坑….</p><h5 id="测试日志-1"><a href="#测试日志-1" class="headerlink" title="测试日志"></a>测试日志</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送消息:com.wangshun.leaning.entity.User@15f7b9a0</span><br><span class="line">接收到的消息为：com.wangshun.leaning.entity.User@4b08eec1</span><br></pre></td></tr></table></figure><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步线程池&quot;&gt;&lt;a href=&quot;#异步线程池&quot; class=&quot;headerlink&quot; title=&quot;异步线程池&quot;&gt;&lt;/a&gt;异步线程池&lt;/h2&gt;&lt;p&gt;在之前的学习中，除了Redis之外，其他所有的都是同步应用，那么其实在开发的过程中，有些时候我们需要使用异步线程，即一个请求需要2个或者2个异常线程去请求，比如生成报表，运维人员只需要点击生成报表即可，并不是需要立即查看报表，那么生成报表可能需要牵扯大量的数据查询并生成，这如果在同一个线程中是很耗费时间的。而且用户的体验也不是很好，接下来 就来说说异步线程。&lt;/p&gt;
&lt;p&gt;就以上的需求大概的逻辑是这样的，运维人员点击生成报表，启动线程1执行生成报表的一些基本操作，同时启动线程2，由线程2去独立完成生成报表的一些大量操作，而线程一无需等待，直接进入下一步操作，这样的话运维人员就不需要等待线程的完成，可以是很好的用户体验…
    
    </summary>
    
      <category term="Spring相关技术学习" scheme="http://yoursite.com/categories/Spring%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(10)构建Rest风格的网站</title>
    <link href="http://yoursite.com/2019/01/01/SpringBoot-10-%E6%9E%84%E5%BB%BARest%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2019/01/01/SpringBoot-10-构建Rest风格的网站/</id>
    <published>2019-01-01T03:11:58.000Z</published>
    <updated>2019-01-02T13:33:50.307Z</updated>
    
    <content type="html"><![CDATA[<p>Rest接口，又或者是Rest风格的网站，现在已经是非常的流行了，在ESB中Rest是一种协议方式，正如WebService一样，之前我一直以为我使用SSM框架写的那种/xxx/xxx,do这种就是Rest风格，其实不然，有一些细微的差别，Rest风格是有自己的规范的，按照Rest规范构建的才能算是Rest风格。让我第一次接触Rest以及印象深刻的是17年年底在公司看到的面试题：“如何使用Spring构建一个Restful API”emmmmmmm到现在还是不会做……看来我当年进公司纯属幸运……hhh….<a id="more"></a></p><h2 id="Rest简述"><a href="#Rest简述" class="headerlink" title="Rest简述"></a>Rest简述</h2><p>Rest这个词，全拼为Representational State Transfer,翻译过来也就是表现层状态转变，如果一个架构符合Rest的原则，那么它就是Rest风格的架构。</p><h3 id="Http动作"><a href="#Http动作" class="headerlink" title="Http动作"></a>Http动作</h3><p>Rest风格的资源是通过Http的行为去操作资源的，对于资源而言，它存在 创建、修改、访问、删除的状态转换，这样也就对应Http行为的五种动作</p><h4 id="Get-VISIT"><a href="#Get-VISIT" class="headerlink" title="Get(VISIT)"></a>Get(VISIT)</h4><pre><code>访问服务器资源(一个或者多个)</code></pre><h4 id="POST-CREATE"><a href="#POST-CREATE" class="headerlink" title="POST(CREATE)"></a>POST(CREATE)</h4><pre><code>提交服务器资源信息，用来创建新的资源</code></pre><h4 id="PUT-UPDATE"><a href="#PUT-UPDATE" class="headerlink" title="PUT(UPDATE)"></a>PUT(UPDATE)</h4><pre><code>修改服务器已经存在的资源，使用PUT时需要把资源的所有属性一并提交</code></pre><h4 id="PATCH-UPDATE"><a href="#PATCH-UPDATE" class="headerlink" title="PATCH(UPDATE)"></a>PATCH(UPDATE)</h4><pre><code>修改服务器已经存在的资源，使用PATCH时只需要把部分资源的属性提交</code></pre><h4 id="DELETE-DELETE"><a href="#DELETE-DELETE" class="headerlink" title="DELETE(DELETE)"></a>DELETE(DELETE)</h4><pre><code>从服务器删除资源</code></pre><p><strong>除了 以上五种常用的动作，还有两种不常用的动作。</strong></p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><pre><code>获取资源的元数据(content-type)</code></pre><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><pre><code>提供资源可供客户端修改属性信息</code></pre><p>有了以上的动作，接来下说说Rest风格的URL设计</p><h3 id="Rest风格URL设计"><a href="#Rest风格URL设计" class="headerlink" title="Rest风格URL设计"></a>Rest风格URL设计</h3><h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><pre><code>GET /user/1</code></pre><h4 id="查询多个用户信息"><a href="#查询多个用户信息" class="headerlink" title="查询多个用户信息"></a>查询多个用户信息</h4><pre><code>GET /users/{userName}/{note}</code></pre><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><pre><code>POST /user/{userName}/{note}/{sex}</code></pre><h4 id="修改用户全部信息"><a href="#修改用户全部信息" class="headerlink" title="修改用户全部信息"></a>修改用户全部信息</h4><pre><code>PUT /user/{id}/{userName}/{note}/{sex}</code></pre><h4 id="修改用户名称-部分信息"><a href="#修改用户名称-部分信息" class="headerlink" title="修改用户名称(部分信息)"></a>修改用户名称(部分信息)</h4><pre><code>PATCH /user/{id}/{userName}</code></pre><p><strong>注意：</strong> 在URL中并没有出现动词，对于参数主要是通过url设计去获取的，对于参数超过5个的可以考虑采用JSON的方式去传递参数。</p><h3 id="Rest风格的一些误区"><a href="#Rest风格的一些误区" class="headerlink" title="Rest风格的一些误区"></a>Rest风格的一些误区</h3><p>在设计Url时，Rest风格存在一些规范如下：</p><h4 id="1-一般不应在URL中存在动词"><a href="#1-一般不应在URL中存在动词" class="headerlink" title="1.一般不应在URL中存在动词"></a>1.一般不应在URL中存在动词</h4><pre><code>比如：GET /user/get/1应该修改为： GET /user/1</code></pre><h4 id="2-URL中不应该添加版本号"><a href="#2-URL中不应该添加版本号" class="headerlink" title="2.URL中不应该添加版本号"></a>2.URL中不应该添加版本号</h4><pre><code>比如： GET /v1/user/1在Rest风格的资源的URL是唯一的，这有点和微服务的思想有些类似，如果存在版本号，可以通过设置Http请求头来进行区分。例如：Accept：version=1.0</code></pre><h4 id="不推荐采用原本的Get方式传递参数"><a href="#不推荐采用原本的Get方式传递参数" class="headerlink" title="不推荐采用原本的Get方式传递参数"></a>不推荐采用原本的Get方式传递参数</h4><pre><code>例如:PUT /user?username=1&amp;password=1应该修改为 put /user/{username}/{password}</code></pre><h2 id="使用SpringMVC开发Rest风格端点"><a href="#使用SpringMVC开发Rest风格端点" class="headerlink" title="使用SpringMVC开发Rest风格端点"></a>使用SpringMVC开发Rest风格端点</h2><p>Spring 对于Rest风格的机制是基于Spring MVC的设计基础上的。</p><h3 id="SpringMVC整合REST"><a href="#SpringMVC整合REST" class="headerlink" title="SpringMVC整合REST"></a>SpringMVC整合REST</h3><p>在之前也说过了，Rest这种风格，其实也就是使用@RequestMapping然后其中的命名符合Rest的规范即可。<br>那么为了方便Rest接口的开发，Spring现如今还提供了以下5个注解<br>@GetMapping:对应http的Get请求</p><p>@PostMapping:对应http的post请求</p><p>@PutMapping:对应http的Put请求</p><p>@PatchMapping:对应http的Patch请求</p><p>@DeleteMapping:对应http的Delete请求</p><p>而使用了Rest风格的传参风格之后，可以在后台使用@PathVariable注解来获取参数，这样就可以满足Rest风格的传参的要求了。<br>当然，对于字段较多的，还是建议@RequestBody 传递Json</p><h3 id="使用Spring-开发Rest接口"><a href="#使用Spring-开发Rest接口" class="headerlink" title="使用Spring 开发Rest接口"></a>使用Spring 开发Rest接口</h3><p>接下来以一个简单的例子来模拟Rest风格的接口开发</p><h4 id="学生实体类"><a href="#学生实体类" class="headerlink" title="学生实体类"></a>学生实体类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.entity;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line">@Alias(<span class="string">"student"</span>)</span><br><span class="line">public class Student &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String name;</span><br><span class="line">private String age;</span><br><span class="line">private String sex;</span><br><span class="line"></span><br><span class="line">/*省略get/<span class="built_in">set</span>  以及构造方法*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>)</span><br><span class="line">public int insertStudent(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line"><span class="built_in">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(<span class="string">"/student/&#123;id&#125;"</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Student getStudentInfoById(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line"><span class="built_in">return</span> studentService.getStudentById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的类似于Put/Delete等等的也是大同小异，使用Rest风格的接口大多数都是使用@PathVariable注解来获取参数<br>只要命名注意规范其他的都差不多……</p><p>当然，在现在前后端分离的大局势下，返回Json 格式是最常用的一种数据格式了，那么每个接口都写上@ResponsoBody又显得麻烦…所以我们可以在Controller类上面统一加上@RestController注解  这样其类下面的每个方法都相当于添加了@ResponseBody注解</p><p>当然，可能前后端的接口参数可能会有不同，比如前段sex参数传的是男女，后端存数据库的是01 这样的话可能还需要类似于DTO和Entity的转化….这里较懒所以没加入，如果有兴趣的可以添加一下</p><h4 id="RequestMapping-的2个属性"><a href="#RequestMapping-的2个属性" class="headerlink" title="@RequestMapping 的2个属性"></a>@RequestMapping 的2个属性</h4><p>在@RequestMapping、@GetMapping 等等注解中 还有2个参数，一个是produces  另外一个是consumes<br>这个在前面也说过，consumes是指请求体的类型，比如我们可能接收的请求体是文本(text)等等，如果做了限制，其他类型的就无法传入进来了。<br>而produces是指限制返回的媒体类型，比如application/json 等等。<br>比如：@PostMapping(value=”/student”,produces=”application/json;charset=utf-8”,consumes=MediaType.ALL_VALUE)</p><h3 id="处理HTTP状态码、异常和响应头"><a href="#处理HTTP状态码、异常和响应头" class="headerlink" title="处理HTTP状态码、异常和响应头"></a>处理HTTP状态码、异常和响应头</h3><p>再此之前，我们只是讨论了如何能够找到数据并进行资源处理，而没有讨论当没有找到资源处理或者说发生异常了应该如何处理，接下来来说说这些。</p><p>当资源找不到或者程序发生异常以后，我们应该返回给客户端HTTP状态码以及错误消息信息，为了简化这些开发，Spring提供了实体封装类ResponseEntity 以及注解@ResponseStatus，前者可以有效的封装错误信息和状态码，后者可以配置指定的响应码给客户端。</p><p>在大部分情况下，后台请求成功会返回一个200的状态码，代表请求成功，但是这还不够具体，比如说新增用户以后，返回201代表新增成功会更加具体一些，因为201代表新增资源成功，200只是代表请求成功而已。<br>这时候就可以使用ResponseEntity类或者@ResponseStatus注解来标识本次请求的状态码。除了在Http响应头中可以添加响应数据之外，还可以给响应头添加一些信息来提供成功或者失败的消息。下面以修改方法为例。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用注解完成状态码</span><br><span class="line"> * @param student</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@ResponseBody</span><br><span class="line">//指定状态码为201(资源创建成功)</span><br><span class="line">@ResponseStatus(value=HttpStatus.CREATED)</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>,consumes=MediaType.ALL_VALUE)</span><br><span class="line">public int insertStudent(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line"><span class="built_in">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line"> * 使用ResponseEntity返回状态码</span><br><span class="line"> * @param student</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value=<span class="string">"/student"</span>,produces=<span class="string">"application/json;charset=utf-8"</span>,consumes=MediaType.ALL_VALUE)</span><br><span class="line">public ResponseEntity&lt;Student&gt; insertStudent2(@RequestBody Student student) &#123;</span><br><span class="line">int rows = studentService.saveOrUpdate(student);</span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">String success = (rows&gt;0)? <span class="string">"true"</span>:<span class="string">"false"</span>;</span><br><span class="line">//设置响应头，比较常用的方式</span><br><span class="line">headers.add(<span class="string">"success"</span>, success);</span><br><span class="line">//下面是使用集合(List)方式，不太常用</span><br><span class="line">//headers.put(<span class="string">"success"</span>, Arrays.asList(success));</span><br><span class="line">//返回创建的状态码</span><br><span class="line"><span class="built_in">return</span> new ResponseEntity&lt;Student&gt;(student,headers,HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个方法中有一个需要注意的地方，就是返回的时候，构造的ResponseEntity对象的第一个参数不能是int类型，由于我返回的就是int  所以只要写了student</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>student 方法<br><img src="/images/SpringBoot/SpringBoot10/sp10-1.png"></p><p>student2方法<br><img src="/images/SpringBoot/SpringBoot10/sp10-2.png"></p><p>可以看到写的状态码都已经成功返回给客户端了。</p><p>成功的情况讨论完了，来说说失败的情况，失败有很多种，比如get方法获取结果集为空，以及程序本身某处发生异常等等，默认情况下这些不做处理返回页面一个大大的500和报错内容是很不友好的<br>，而且在此之前也学习了一些异常的处理，比如控制层的@ControllerAdvice和@ExceptionHandler等等，当然，网上推荐的那种报错之后页面直接跳转<a href="http://www.baidu.com?pwd=#{exceptionInfo}" target="_blank" rel="noopener">www.baidu.com?pwd=#{exceptionInfo}</a> 也是很不错的一种想法~哈哈哈<br>不开玩笑了，说说正经的处理<br>@ControllerAdvice是用来定义控制器通知的，而@ExceptionHandler是指定异常发生时的处理办法，有这些只是就足以处理异常了。在此之前，先定义查找失败的异常，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.exception;</span><br><span class="line">/**</span><br><span class="line"> * 定义学生类找不到异常</span><br><span class="line">* @author wangshun  </span><br><span class="line">* @date 2019年1月2日  </span><br><span class="line">* @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class NotFoundException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = -2533075100361102139L;</span><br><span class="line">//异常编码</span><br><span class="line">private Integer code;</span><br><span class="line">//异常信息</span><br><span class="line">private String message;</span><br><span class="line">public <span class="function"><span class="title">NotFoundException</span></span>() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public NotFoundException(Integer code, String message) &#123;</span><br><span class="line">super();</span><br><span class="line">this.code = code;</span><br><span class="line">this.message = message;</span><br><span class="line">&#125;</span><br><span class="line">public Integer <span class="function"><span class="title">getCode</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line">public void setCode(Integer code) &#123;</span><br><span class="line">this.code = code;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">getMessage</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">public void setMessage(String message) &#123;</span><br><span class="line">this.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了异常类，其继承于运行时异常类，所以可以在找不到用户时抛出异常，而在控制器抛出异常之后，则可以在控制器(@ControllerAdvice)中处理这些异常，这时候就需要使用注解@ExceptionHandler了，实际上，在SpringBoot的机制中早就准备好了BasicErrorController对象去处理发生的异常，但是它并不是很友好，所以我们还需要自定义一个控制通知。</p><h4 id="定义控制器通知来处理异常"><a href="#定义控制器通知来处理异常" class="headerlink" title="定义控制器通知来处理异常"></a>定义控制器通知来处理异常</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.wangshun.leaning.exception;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@ControllerAdvice(</span><br><span class="line">//指定拦截包的控制器</span><br><span class="line">basePackages= &#123;<span class="string">"com.wangshun.leaning.controller.*"</span>&#125;,</span><br><span class="line">//限定为指定为@RestController  和@Controller 注解的才会被拦截</span><br><span class="line">annotations= &#123;Controller.class,RestController.class&#125;</span><br><span class="line">)</span><br><span class="line">public class StudentAdviceController &#123;</span><br><span class="line">//异常类型，可以定义异常类型进行拦截处理</span><br><span class="line">@ExceptionHandler(value=NotFoundException.class)</span><br><span class="line">@ResponseBody</span><br><span class="line">@ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">public Map&lt;String, Object&gt; exception(HttpServletRequest request,NotFoundException exception)&#123;</span><br><span class="line">Map&lt;String , Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(<span class="string">"code"</span>, exception.getCode());</span><br><span class="line">map.put(<span class="string">"message"</span>, exception.getMessage());</span><br><span class="line"><span class="built_in">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了@ControllerAdvice注解来标注类，说明在定义一个控制器的通知，配合它所拦截的包，限定了那些被标注为@Controller 和@RestController注解的控制器，按照其定义就可以拦截之前写好的控制器，这里的@ExceptionHandler定义了拦截NotFoundException，@ResponseBody标明了返回json格式，而@ResponseStatus注解定义了状态码为500(服务器内部错误)，这样就会把状态码传递给请求者。</p><p>接下来写一个测试类来进行测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/student/&#123;id&#125;"</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Student getStudentInfoById(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line">Student student = studentService.getStudentById(id);</span><br><span class="line"><span class="keyword">if</span>(student == null) &#123;</span><br><span class="line">throw new NotFoundException(1,<span class="string">"找不到用户"</span>+id+<span class="string">"的信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="soapUI测试结果"><a href="#soapUI测试结果" class="headerlink" title="soapUI测试结果"></a>soapUI测试结果</h4><p><img src="/images/SpringBoot/SpringBoot10/sp10-3.png"></p><p>参考文献<br>    《深入浅出SpringBoot2.x》——杨开振</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rest接口，又或者是Rest风格的网站，现在已经是非常的流行了，在ESB中Rest是一种协议方式，正如WebService一样，之前我一直以为我使用SSM框架写的那种/xxx/xxx,do这种就是Rest风格，其实不然，有一些细微的差别，Rest风格是有自己的规范的，按照Rest规范构建的才能算是Rest风格。让我第一次接触Rest以及印象深刻的是17年年底在公司看到的面试题：“如何使用Spring构建一个Restful API”emmmmmmm到现在还是不会做……看来我当年进公司纯属幸运……hhh….
    
    </summary>
    
      <category term="SpringBoot学习" scheme="http://yoursite.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="springBoot" scheme="http://yoursite.com/tags/springBoot/"/>
    
  </entry>
  
</feed>
